import {
  ALPHA_MODES,
  BLEND_MODES,
  BaseTexture,
  BatchDrawCall,
  BatchGeometry,
  BatchTextureArray,
  Bounds,
  Buffer,
  Circle,
  Color,
  Container,
  DRAW_MODES,
  Ellipse,
  ExtensionType,
  Geometry,
  MIPMAP_MODES,
  Matrix,
  ObjectRenderer,
  ObservablePoint,
  PI_2,
  Point,
  Polygon,
  Program,
  QuadUv,
  Rectangle,
  RoundedRectangle,
  SHAPES,
  SVGResource,
  Shader,
  State,
  TYPES,
  Texture,
  TextureMatrix,
  Ticker,
  Transform,
  UPDATE_PRIORITY,
  UniformGroup,
  WRAP_MODES,
  autoDetectRenderer,
  extensions,
  init_lib4 as init_lib,
  init_lib5 as init_lib2,
  lib_exports,
  settings
} from "./chunk-SA2RAD5H.js";
import {
  __esm
} from "./chunk-ROME4SDB.js";

// node_modules/@pixi/text/lib/const.mjs
var TEXT_GRADIENT;
var init_const = __esm({
  "node_modules/@pixi/text/lib/const.mjs"() {
    TEXT_GRADIENT = ((TEXT_GRADIENT2) => {
      TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
      TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
      return TEXT_GRADIENT2;
    })(TEXT_GRADIENT || {});
  }
});

// node_modules/@pixi/sprite/lib/Sprite.mjs
var tempPoint, indices, Sprite;
var init_Sprite = __esm({
  "node_modules/@pixi/sprite/lib/Sprite.mjs"() {
    init_lib();
    init_lib2();
    tempPoint = new Point();
    indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
    Sprite = class _Sprite extends Container {
      constructor(texture) {
        super();
        this._anchor = new ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
        this._texture = null;
        this._width = 0;
        this._height = 0;
        this._tintColor = new Color(16777215);
        this._tintRGB = null;
        this.tint = 16777215;
        this.blendMode = BLEND_MODES.NORMAL;
        this._cachedTint = 16777215;
        this.uvs = null;
        this.texture = texture || Texture.EMPTY;
        this.vertexData = new Float32Array(8);
        this.vertexTrimmedData = null;
        this._transformID = -1;
        this._textureID = -1;
        this._transformTrimmedID = -1;
        this._textureTrimmedID = -1;
        this.indices = indices;
        this.pluginName = "batch";
        this.isSprite = true;
        this._roundPixels = settings.ROUND_PIXELS;
      }
      _onTextureUpdate() {
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this._cachedTint = 16777215;
        if (this._width) {
          this.scale.x = lib_exports.sign(this.scale.x) * this._width / this._texture.orig.width;
        }
        if (this._height) {
          this.scale.y = lib_exports.sign(this.scale.y) * this._height / this._texture.orig.height;
        }
      }
      _onAnchorUpdate() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
      }
      calculateVertices() {
        const texture = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
          return;
        }
        if (this._textureID !== texture._updateID) {
          this.uvs = this._texture._uvs.uvsFloat32;
        }
        this._transformID = this.transform._worldID;
        this._textureID = texture._updateID;
        const wt = this.transform.worldTransform;
        const a = wt.a;
        const b = wt.b;
        const c = wt.c;
        const d = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const vertexData = this.vertexData;
        const trim = texture.trim;
        const orig = texture.orig;
        const anchor = this._anchor;
        let w0 = 0;
        let w1 = 0;
        let h0 = 0;
        let h1 = 0;
        if (trim) {
          w1 = trim.x - anchor._x * orig.width;
          w0 = w1 + trim.width;
          h1 = trim.y - anchor._y * orig.height;
          h0 = h1 + trim.height;
        } else {
          w1 = -anchor._x * orig.width;
          w0 = w1 + orig.width;
          h1 = -anchor._y * orig.height;
          h0 = h1 + orig.height;
        }
        vertexData[0] = a * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;
        vertexData[2] = a * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;
        vertexData[4] = a * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;
        vertexData[6] = a * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
        if (this._roundPixels) {
          const resolution = settings.RESOLUTION;
          for (let i = 0; i < vertexData.length; ++i) {
            vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
          }
        }
      }
      calculateTrimmedVertices() {
        if (!this.vertexTrimmedData) {
          this.vertexTrimmedData = new Float32Array(8);
        } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
          return;
        }
        this._transformTrimmedID = this.transform._worldID;
        this._textureTrimmedID = this._texture._updateID;
        const texture = this._texture;
        const vertexData = this.vertexTrimmedData;
        const orig = texture.orig;
        const anchor = this._anchor;
        const wt = this.transform.worldTransform;
        const a = wt.a;
        const b = wt.b;
        const c = wt.c;
        const d = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const w1 = -anchor._x * orig.width;
        const w0 = w1 + orig.width;
        const h1 = -anchor._y * orig.height;
        const h0 = h1 + orig.height;
        vertexData[0] = a * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;
        vertexData[2] = a * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;
        vertexData[4] = a * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;
        vertexData[6] = a * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
      }
      _render(renderer) {
        this.calculateVertices();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      }
      _calculateBounds() {
        const trim = this._texture.trim;
        const orig = this._texture.orig;
        if (!trim || trim.width === orig.width && trim.height === orig.height) {
          this.calculateVertices();
          this._bounds.addQuad(this.vertexData);
        } else {
          this.calculateTrimmedVertices();
          this._bounds.addQuad(this.vertexTrimmedData);
        }
      }
      getLocalBounds(rect) {
        if (this.children.length === 0) {
          if (!this._localBounds) {
            this._localBounds = new Bounds();
          }
          this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
          this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
          this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
          this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new Rectangle();
            }
            rect = this._localBoundsRect;
          }
          return this._localBounds.getRectangle(rect);
        }
        return super.getLocalBounds.call(this, rect);
      }
      containsPoint(point) {
        this.worldTransform.applyInverse(point, tempPoint);
        const width = this._texture.orig.width;
        const height = this._texture.orig.height;
        const x1 = -width * this.anchor.x;
        let y1 = 0;
        if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
          y1 = -height * this.anchor.y;
          if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
            return true;
          }
        }
        return false;
      }
      destroy(options) {
        super.destroy(options);
        this._texture.off("update", this._onTextureUpdate, this);
        this._anchor = null;
        const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
        if (destroyTexture) {
          const destroyBaseTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.baseTexture;
          this._texture.destroy(!!destroyBaseTexture);
        }
        this._texture = null;
      }
      static from(source, options) {
        const texture = source instanceof Texture ? source : Texture.from(source, options);
        return new _Sprite(texture);
      }
      set roundPixels(value) {
        if (this._roundPixels !== value) {
          this._transformID = -1;
        }
        this._roundPixels = value;
      }
      get roundPixels() {
        return this._roundPixels;
      }
      get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      }
      set width(value) {
        const s = lib_exports.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
      }
      get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      }
      set height(value) {
        const s = lib_exports.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
      }
      get anchor() {
        return this._anchor;
      }
      set anchor(value) {
        this._anchor.copyFrom(value);
      }
      get tint() {
        return this._tintColor.value;
      }
      set tint(value) {
        this._tintColor.setValue(value);
        this._tintRGB = this._tintColor.toLittleEndianNumber();
      }
      get tintValue() {
        return this._tintColor.toNumber();
      }
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this._texture === value) {
          return;
        }
        if (this._texture) {
          this._texture.off("update", this._onTextureUpdate, this);
        }
        this._texture = value || Texture.EMPTY;
        this._cachedTint = 16777215;
        this._textureID = -1;
        this._textureTrimmedID = -1;
        if (value) {
          if (value.baseTexture.valid) {
            this._onTextureUpdate();
          } else {
            value.once("update", this._onTextureUpdate, this);
          }
        }
      }
    };
  }
});

// node_modules/@pixi/sprite/lib/index.mjs
var init_lib3 = __esm({
  "node_modules/@pixi/sprite/lib/index.mjs"() {
    init_Sprite();
  }
});

// node_modules/@pixi/text/lib/TextMetrics.mjs
var contextSettings, _TextMetrics, TextMetrics;
var init_TextMetrics = __esm({
  "node_modules/@pixi/text/lib/TextMetrics.mjs"() {
    init_lib();
    contextSettings = {
      willReadFrequently: true
    };
    _TextMetrics = class {
      static get experimentalLetterSpacingSupported() {
        let result = _TextMetrics._experimentalLetterSpacingSupported;
        if (result !== void 0) {
          const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
          result = _TextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
        }
        return result;
      }
      constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {
        wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
        const font = style.toFontString();
        const fontProperties = _TextMetrics.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        const context = canvas.getContext("2d", contextSettings);
        context.font = font;
        const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;
        const lines = outputText.split(/(?:\r\n|\r|\n)/);
        const lineWidths = new Array(lines.length);
        let maxLineWidth = 0;
        for (let i = 0; i < lines.length; i++) {
          const lineWidth = _TextMetrics._measureText(lines[i], style.letterSpacing, context);
          lineWidths[i] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        let width = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
          width += style.dropShadowDistance;
        }
        const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height += style.dropShadowDistance;
        }
        return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
      }
      static _measureText(text, letterSpacing, context) {
        let useExperimentalLetterSpacing = false;
        if (_TextMetrics.experimentalLetterSpacingSupported) {
          if (_TextMetrics.experimentalLetterSpacing) {
            context.letterSpacing = `${letterSpacing}px`;
            context.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context.letterSpacing = "0px";
            context.textLetterSpacing = "0px";
          }
        }
        let width = context.measureText(text).width;
        if (width > 0) {
          if (useExperimentalLetterSpacing) {
            width -= letterSpacing;
          } else {
            width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
          }
        }
        return width;
      }
      static wordWrap(text, style, canvas = _TextMetrics._canvas) {
        const context = canvas.getContext("2d", contextSettings);
        let width = 0;
        let line = "";
        let lines = "";
        const cache = /* @__PURE__ */ Object.create(null);
        const { letterSpacing, whiteSpace } = style;
        const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);
        const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);
        let canPrependSpaces = !collapseSpaces;
        const wordWrapWidth = style.wordWrapWidth + letterSpacing;
        const tokens = _TextMetrics.tokenize(text);
        for (let i = 0; i < tokens.length; i++) {
          let token = tokens[i];
          if (_TextMetrics.isNewline(token)) {
            if (!collapseNewlines) {
              lines += _TextMetrics.addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width = 0;
              continue;
            }
            token = " ";
          }
          if (collapseSpaces) {
            const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);
            const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache, context);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += _TextMetrics.addLine(line);
              line = "";
              width = 0;
            }
            if (_TextMetrics.canBreakWords(token, style.breakWords)) {
              const characters = _TextMetrics.wordWrapSplit(token);
              for (let j = 0; j < characters.length; j++) {
                let char = characters[j];
                let lastChar = char;
                let k = 1;
                while (characters[j + k]) {
                  const nextChar = characters[j + k];
                  if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  lastChar = nextChar;
                  k++;
                }
                j += k - 1;
                const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache, context);
                if (characterWidth + width > wordWrapWidth) {
                  lines += _TextMetrics.addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width = 0;
                }
                line += char;
                width += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += _TextMetrics.addLine(line);
                line = "";
                width = 0;
              }
              const isLastToken = i === tokens.length - 1;
              lines += _TextMetrics.addLine(token, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
          } else {
            if (tokenWidth + width > wordWrapWidth) {
              canPrependSpaces = false;
              lines += _TextMetrics.addLine(line);
              line = "";
              width = 0;
            }
            if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
              line += token;
              width += tokenWidth;
            }
          }
        }
        lines += _TextMetrics.addLine(line, false);
        return lines;
      }
      static addLine(line, newLine = true) {
        line = _TextMetrics.trimRight(line);
        line = newLine ? `${line}
` : line;
        return line;
      }
      static getFromCache(key, letterSpacing, cache, context) {
        let width = cache[key];
        if (typeof width !== "number") {
          width = _TextMetrics._measureText(key, letterSpacing, context) + letterSpacing;
          cache[key] = width;
        }
        return width;
      }
      static collapseSpaces(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      }
      static collapseNewlines(whiteSpace) {
        return whiteSpace === "normal";
      }
      static trimRight(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (let i = text.length - 1; i >= 0; i--) {
          const char = text[i];
          if (!_TextMetrics.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      }
      static isNewline(char) {
        if (typeof char !== "string") {
          return false;
        }
        return _TextMetrics._newlines.includes(char.charCodeAt(0));
      }
      static isBreakingSpace(char, _nextChar) {
        if (typeof char !== "string") {
          return false;
        }
        return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));
      }
      static tokenize(text) {
        const tokens = [];
        let token = "";
        if (typeof text !== "string") {
          return tokens;
        }
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const nextChar = text[i + 1];
          if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {
            if (token !== "") {
              tokens.push(token);
              token = "";
            }
            tokens.push(char);
            continue;
          }
          token += char;
        }
        if (token !== "") {
          tokens.push(token);
        }
        return tokens;
      }
      static canBreakWords(_token, breakWords) {
        return breakWords;
      }
      static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      }
      static wordWrapSplit(token) {
        return _TextMetrics.graphemeSegmenter(token);
      }
      static measureFont(font) {
        if (_TextMetrics._fonts[font]) {
          return _TextMetrics._fonts[font];
        }
        const properties = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        const canvas = _TextMetrics._canvas;
        const context = _TextMetrics._context;
        context.font = font;
        const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;
        const width = Math.ceil(context.measureText(metricsString).width);
        let baseline = Math.ceil(context.measureText(_TextMetrics.BASELINE_SYMBOL).width);
        const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);
        baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;
        if (width === 0 || height === 0) {
          _TextMetrics._fonts[font] = properties;
          return properties;
        }
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = "#f00";
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = "alphabetic";
        context.fillStyle = "#000";
        context.fillText(metricsString, 0, baseline);
        const imagedata = context.getImageData(0, 0, width, height).data;
        const pixels = imagedata.length;
        const line = width * 4;
        let i = 0;
        let idx = 0;
        let stop = false;
        for (i = 0; i < baseline; ++i) {
          for (let j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line;
          } else {
            break;
          }
        }
        properties.ascent = baseline - i;
        idx = pixels - line;
        stop = false;
        for (i = height; i > baseline; --i) {
          for (let j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line;
          } else {
            break;
          }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        _TextMetrics._fonts[font] = properties;
        return properties;
      }
      static clearMetrics(font = "") {
        if (font) {
          delete _TextMetrics._fonts[font];
        } else {
          _TextMetrics._fonts = {};
        }
      }
      static get _canvas() {
        if (!_TextMetrics.__canvas) {
          let canvas;
          try {
            const c = new OffscreenCanvas(0, 0);
            const context = c.getContext("2d", contextSettings);
            if (context == null ? void 0 : context.measureText) {
              _TextMetrics.__canvas = c;
              return c;
            }
            canvas = settings.ADAPTER.createCanvas();
          } catch (ex) {
            canvas = settings.ADAPTER.createCanvas();
          }
          canvas.width = canvas.height = 10;
          _TextMetrics.__canvas = canvas;
        }
        return _TextMetrics.__canvas;
      }
      static get _context() {
        if (!_TextMetrics.__context) {
          _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);
        }
        return _TextMetrics.__context;
      }
    };
    TextMetrics = _TextMetrics;
    TextMetrics.METRICS_STRING = "|ÉqÅ";
    TextMetrics.BASELINE_SYMBOL = "M";
    TextMetrics.BASELINE_MULTIPLIER = 1.4;
    TextMetrics.HEIGHT_MULTIPLIER = 2;
    TextMetrics.graphemeSegmenter = (() => {
      if (typeof (Intl == null ? void 0 : Intl.Segmenter) === "function") {
        const segmenter = new Intl.Segmenter();
        return (s) => [...segmenter.segment(s)].map((x) => x.segment);
      }
      return (s) => [...s];
    })();
    TextMetrics.experimentalLetterSpacing = false;
    TextMetrics._fonts = {};
    TextMetrics._newlines = [
      10,
      13
    ];
    TextMetrics._breakingSpaces = [
      9,
      32,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8200,
      8201,
      8202,
      8287,
      12288
    ];
  }
});

// node_modules/@pixi/text/lib/TextStyle.mjs
function getColor(color) {
  const temp = Color.shared;
  if (!Array.isArray(color)) {
    return temp.setValue(color).toHex();
  } else {
    return color.map((c) => temp.setValue(c).toHex());
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (const prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}
var genericFontFamilies, _TextStyle, TextStyle;
var init_TextStyle = __esm({
  "node_modules/@pixi/text/lib/TextStyle.mjs"() {
    init_const();
    init_lib();
    genericFontFamilies = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui"
    ];
    _TextStyle = class {
      constructor(style) {
        this.styleID = 0;
        this.reset();
        deepCopyProperties(this, style, style);
      }
      clone() {
        const clonedProperties = {};
        deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);
        return new _TextStyle(clonedProperties);
      }
      reset() {
        deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);
      }
      get align() {
        return this._align;
      }
      set align(align) {
        if (this._align !== align) {
          this._align = align;
          this.styleID++;
        }
      }
      get breakWords() {
        return this._breakWords;
      }
      set breakWords(breakWords) {
        if (this._breakWords !== breakWords) {
          this._breakWords = breakWords;
          this.styleID++;
        }
      }
      get dropShadow() {
        return this._dropShadow;
      }
      set dropShadow(dropShadow) {
        if (this._dropShadow !== dropShadow) {
          this._dropShadow = dropShadow;
          this.styleID++;
        }
      }
      get dropShadowAlpha() {
        return this._dropShadowAlpha;
      }
      set dropShadowAlpha(dropShadowAlpha) {
        if (this._dropShadowAlpha !== dropShadowAlpha) {
          this._dropShadowAlpha = dropShadowAlpha;
          this.styleID++;
        }
      }
      get dropShadowAngle() {
        return this._dropShadowAngle;
      }
      set dropShadowAngle(dropShadowAngle) {
        if (this._dropShadowAngle !== dropShadowAngle) {
          this._dropShadowAngle = dropShadowAngle;
          this.styleID++;
        }
      }
      get dropShadowBlur() {
        return this._dropShadowBlur;
      }
      set dropShadowBlur(dropShadowBlur) {
        if (this._dropShadowBlur !== dropShadowBlur) {
          this._dropShadowBlur = dropShadowBlur;
          this.styleID++;
        }
      }
      get dropShadowColor() {
        return this._dropShadowColor;
      }
      set dropShadowColor(dropShadowColor) {
        const outputColor = getColor(dropShadowColor);
        if (this._dropShadowColor !== outputColor) {
          this._dropShadowColor = outputColor;
          this.styleID++;
        }
      }
      get dropShadowDistance() {
        return this._dropShadowDistance;
      }
      set dropShadowDistance(dropShadowDistance) {
        if (this._dropShadowDistance !== dropShadowDistance) {
          this._dropShadowDistance = dropShadowDistance;
          this.styleID++;
        }
      }
      get fill() {
        return this._fill;
      }
      set fill(fill) {
        const outputColor = getColor(fill);
        if (this._fill !== outputColor) {
          this._fill = outputColor;
          this.styleID++;
        }
      }
      get fillGradientType() {
        return this._fillGradientType;
      }
      set fillGradientType(fillGradientType) {
        if (this._fillGradientType !== fillGradientType) {
          this._fillGradientType = fillGradientType;
          this.styleID++;
        }
      }
      get fillGradientStops() {
        return this._fillGradientStops;
      }
      set fillGradientStops(fillGradientStops) {
        if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
          this._fillGradientStops = fillGradientStops;
          this.styleID++;
        }
      }
      get fontFamily() {
        return this._fontFamily;
      }
      set fontFamily(fontFamily) {
        if (this.fontFamily !== fontFamily) {
          this._fontFamily = fontFamily;
          this.styleID++;
        }
      }
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(fontSize) {
        if (this._fontSize !== fontSize) {
          this._fontSize = fontSize;
          this.styleID++;
        }
      }
      get fontStyle() {
        return this._fontStyle;
      }
      set fontStyle(fontStyle) {
        if (this._fontStyle !== fontStyle) {
          this._fontStyle = fontStyle;
          this.styleID++;
        }
      }
      get fontVariant() {
        return this._fontVariant;
      }
      set fontVariant(fontVariant) {
        if (this._fontVariant !== fontVariant) {
          this._fontVariant = fontVariant;
          this.styleID++;
        }
      }
      get fontWeight() {
        return this._fontWeight;
      }
      set fontWeight(fontWeight) {
        if (this._fontWeight !== fontWeight) {
          this._fontWeight = fontWeight;
          this.styleID++;
        }
      }
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(letterSpacing) {
        if (this._letterSpacing !== letterSpacing) {
          this._letterSpacing = letterSpacing;
          this.styleID++;
        }
      }
      get lineHeight() {
        return this._lineHeight;
      }
      set lineHeight(lineHeight) {
        if (this._lineHeight !== lineHeight) {
          this._lineHeight = lineHeight;
          this.styleID++;
        }
      }
      get leading() {
        return this._leading;
      }
      set leading(leading) {
        if (this._leading !== leading) {
          this._leading = leading;
          this.styleID++;
        }
      }
      get lineJoin() {
        return this._lineJoin;
      }
      set lineJoin(lineJoin) {
        if (this._lineJoin !== lineJoin) {
          this._lineJoin = lineJoin;
          this.styleID++;
        }
      }
      get miterLimit() {
        return this._miterLimit;
      }
      set miterLimit(miterLimit) {
        if (this._miterLimit !== miterLimit) {
          this._miterLimit = miterLimit;
          this.styleID++;
        }
      }
      get padding() {
        return this._padding;
      }
      set padding(padding) {
        if (this._padding !== padding) {
          this._padding = padding;
          this.styleID++;
        }
      }
      get stroke() {
        return this._stroke;
      }
      set stroke(stroke) {
        const outputColor = getColor(stroke);
        if (this._stroke !== outputColor) {
          this._stroke = outputColor;
          this.styleID++;
        }
      }
      get strokeThickness() {
        return this._strokeThickness;
      }
      set strokeThickness(strokeThickness) {
        if (this._strokeThickness !== strokeThickness) {
          this._strokeThickness = strokeThickness;
          this.styleID++;
        }
      }
      get textBaseline() {
        return this._textBaseline;
      }
      set textBaseline(textBaseline) {
        if (this._textBaseline !== textBaseline) {
          this._textBaseline = textBaseline;
          this.styleID++;
        }
      }
      get trim() {
        return this._trim;
      }
      set trim(trim) {
        if (this._trim !== trim) {
          this._trim = trim;
          this.styleID++;
        }
      }
      get whiteSpace() {
        return this._whiteSpace;
      }
      set whiteSpace(whiteSpace) {
        if (this._whiteSpace !== whiteSpace) {
          this._whiteSpace = whiteSpace;
          this.styleID++;
        }
      }
      get wordWrap() {
        return this._wordWrap;
      }
      set wordWrap(wordWrap) {
        if (this._wordWrap !== wordWrap) {
          this._wordWrap = wordWrap;
          this.styleID++;
        }
      }
      get wordWrapWidth() {
        return this._wordWrapWidth;
      }
      set wordWrapWidth(wordWrapWidth) {
        if (this._wordWrapWidth !== wordWrapWidth) {
          this._wordWrapWidth = wordWrapWidth;
          this.styleID++;
        }
      }
      toFontString() {
        const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;
        let fontFamilies = this.fontFamily;
        if (!Array.isArray(this.fontFamily)) {
          fontFamilies = this.fontFamily.split(",");
        }
        for (let i = fontFamilies.length - 1; i >= 0; i--) {
          let fontFamily = fontFamilies[i].trim();
          if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
            fontFamily = `"${fontFamily}"`;
          }
          fontFamilies[i] = fontFamily;
        }
        return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
      }
    };
    TextStyle = _TextStyle;
    TextStyle.defaultStyle = {
      align: "left",
      breakWords: false,
      dropShadow: false,
      dropShadowAlpha: 1,
      dropShadowAngle: Math.PI / 6,
      dropShadowBlur: 0,
      dropShadowColor: "black",
      dropShadowDistance: 5,
      fill: "black",
      fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
      fillGradientStops: [],
      fontFamily: "Arial",
      fontSize: 26,
      fontStyle: "normal",
      fontVariant: "normal",
      fontWeight: "normal",
      leading: 0,
      letterSpacing: 0,
      lineHeight: 0,
      lineJoin: "miter",
      miterLimit: 10,
      padding: 0,
      stroke: "black",
      strokeThickness: 0,
      textBaseline: "alphabetic",
      trim: false,
      whiteSpace: "pre",
      wordWrap: false,
      wordWrapWidth: 100
    };
  }
});

// node_modules/@pixi/text/lib/Text.mjs
var defaultDestroyOptions, _Text, Text;
var init_Text = __esm({
  "node_modules/@pixi/text/lib/Text.mjs"() {
    init_lib();
    init_lib3();
    init_const();
    init_TextMetrics();
    init_TextStyle();
    defaultDestroyOptions = {
      texture: true,
      children: false,
      baseTexture: true
    };
    _Text = class extends Sprite {
      constructor(text, style, canvas) {
        let ownCanvas = false;
        if (!canvas) {
          canvas = settings.ADAPTER.createCanvas();
          ownCanvas = true;
        }
        canvas.width = 3;
        canvas.height = 3;
        const texture = Texture.from(canvas);
        texture.orig = new Rectangle();
        texture.trim = new Rectangle();
        super(texture);
        this._ownCanvas = ownCanvas;
        this.canvas = canvas;
        this.context = canvas.getContext("2d", {
          willReadFrequently: true
        });
        this._resolution = _Text.defaultResolution ?? settings.RESOLUTION;
        this._autoResolution = _Text.defaultAutoResolution;
        this._text = null;
        this._style = null;
        this._styleListener = null;
        this._font = "";
        this.text = text;
        this.style = style;
        this.localStyleID = -1;
      }
      static get experimentalLetterSpacing() {
        return TextMetrics.experimentalLetterSpacing;
      }
      static set experimentalLetterSpacing(value) {
        lib_exports.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");
        TextMetrics.experimentalLetterSpacing = value;
      }
      updateText(respectDirty) {
        const style = this._style;
        if (this.localStyleID !== style.styleID) {
          this.dirty = true;
          this.localStyleID = style.styleID;
        }
        if (!this.dirty && respectDirty) {
          return;
        }
        this._font = this._style.toFontString();
        const context = this.context;
        const measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
        const width = measured.width;
        const height = measured.height;
        const lines = measured.lines;
        const lineHeight = measured.lineHeight;
        const lineWidths = measured.lineWidths;
        const maxLineWidth = measured.maxLineWidth;
        const fontProperties = measured.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
        this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
        context.scale(this._resolution, this._resolution);
        context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        context.font = this._font;
        context.lineWidth = style.strokeThickness;
        context.textBaseline = style.textBaseline;
        context.lineJoin = style.lineJoin;
        context.miterLimit = style.miterLimit;
        let linePositionX;
        let linePositionY;
        const passesCount = style.dropShadow ? 2 : 1;
        for (let i = 0; i < passesCount; ++i) {
          const isShadowPass = style.dropShadow && i === 0;
          const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
          const dsOffsetShadow = dsOffsetText * this._resolution;
          if (isShadowPass) {
            context.fillStyle = "black";
            context.strokeStyle = "black";
            const dropShadowColor = style.dropShadowColor;
            const dropShadowBlur = style.dropShadowBlur * this._resolution;
            const dropShadowDistance = style.dropShadowDistance * this._resolution;
            context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
            context.shadowBlur = dropShadowBlur;
            context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
            context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
          } else {
            context.fillStyle = this._generateFillStyle(style, lines, measured);
            context.strokeStyle = style.stroke;
            context.shadowColor = "black";
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
          }
          let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
          if (lineHeight - fontProperties.fontSize < 0) {
            linePositionYShift = 0;
          }
          for (let i2 = 0; i2 < lines.length; i2++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i2];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i2]) / 2;
            }
            if (style.stroke && style.strokeThickness) {
              this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
            }
            if (style.fill) {
              this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
            }
          }
        }
        this.updateTexture();
      }
      drawLetterSpacing(text, x, y, isStroke = false) {
        const style = this._style;
        const letterSpacing = style.letterSpacing;
        let useExperimentalLetterSpacing = false;
        if (TextMetrics.experimentalLetterSpacingSupported) {
          if (TextMetrics.experimentalLetterSpacing) {
            this.context.letterSpacing = `${letterSpacing}px`;
            this.context.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            this.context.letterSpacing = "0px";
            this.context.textLetterSpacing = "0px";
          }
        }
        if (letterSpacing === 0 || useExperimentalLetterSpacing) {
          if (isStroke) {
            this.context.strokeText(text, x, y);
          } else {
            this.context.fillText(text, x, y);
          }
          return;
        }
        let currentPosition = x;
        const stringArray = TextMetrics.graphemeSegmenter(text);
        let previousWidth = this.context.measureText(text).width;
        let currentWidth = 0;
        for (let i = 0; i < stringArray.length; ++i) {
          const currentChar = stringArray[i];
          if (isStroke) {
            this.context.strokeText(currentChar, currentPosition, y);
          } else {
            this.context.fillText(currentChar, currentPosition, y);
          }
          let textStr = "";
          for (let j = i + 1; j < stringArray.length; ++j) {
            textStr += stringArray[j];
          }
          currentWidth = this.context.measureText(textStr).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      }
      updateTexture() {
        const canvas = this.canvas;
        if (this._style.trim) {
          const trimmed = lib_exports.trimCanvas(canvas);
          if (trimmed.data) {
            canvas.width = trimmed.width;
            canvas.height = trimmed.height;
            this.context.putImageData(trimmed.data, 0, 0);
          }
        }
        const texture = this._texture;
        const style = this._style;
        const padding = style.trim ? 0 : style.padding;
        const baseTexture = texture.baseTexture;
        texture.trim.width = texture._frame.width = canvas.width / this._resolution;
        texture.trim.height = texture._frame.height = canvas.height / this._resolution;
        texture.trim.x = -padding;
        texture.trim.y = -padding;
        texture.orig.width = texture._frame.width - padding * 2;
        texture.orig.height = texture._frame.height - padding * 2;
        this._onTextureUpdate();
        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
        texture.updateUvs();
        this.dirty = false;
      }
      _render(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
          this._resolution = renderer.resolution;
          this.dirty = true;
        }
        this.updateText(true);
        super._render(renderer);
      }
      updateTransform() {
        this.updateText(true);
        super.updateTransform();
      }
      getBounds(skipUpdate, rect) {
        this.updateText(true);
        if (this._textureID === -1) {
          skipUpdate = false;
        }
        return super.getBounds(skipUpdate, rect);
      }
      getLocalBounds(rect) {
        this.updateText(true);
        return super.getLocalBounds.call(this, rect);
      }
      _calculateBounds() {
        this.calculateVertices();
        this._bounds.addQuad(this.vertexData);
      }
      _generateFillStyle(style, lines, metrics) {
        const fillStyle = style.fill;
        if (!Array.isArray(fillStyle)) {
          return fillStyle;
        } else if (fillStyle.length === 1) {
          return fillStyle[0];
        }
        let gradient;
        const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
        const padding = style.padding || 0;
        const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
        const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
        const fill = fillStyle.slice();
        const fillGradientStops = style.fillGradientStops.slice();
        if (!fillGradientStops.length) {
          const lengthPlus1 = fill.length + 1;
          for (let i = 1; i < lengthPlus1; ++i) {
            fillGradientStops.push(i / lengthPlus1);
          }
        }
        fill.unshift(fillStyle[0]);
        fillGradientStops.unshift(0);
        fill.push(fillStyle[fillStyle.length - 1]);
        fillGradientStops.push(1);
        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
          gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
          const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
          for (let i = 0; i < lines.length; i++) {
            const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
            const thisLineTop = metrics.lineHeight * i;
            let thisLineGradientStart = thisLineTop;
            if (i > 0 && lastLineBottom > thisLineTop) {
              thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
            }
            const thisLineBottom = thisLineTop + textHeight;
            const nextLineTop = metrics.lineHeight * (i + 1);
            let thisLineGradientEnd = thisLineBottom;
            if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
              thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
            }
            const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
            for (let j = 0; j < fill.length; j++) {
              let lineStop = 0;
              if (typeof fillGradientStops[j] === "number") {
                lineStop = fillGradientStops[j];
              } else {
                lineStop = j / fill.length;
              }
              let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
              globalStop = Number(globalStop.toFixed(5));
              gradient.addColorStop(globalStop, fill[j]);
            }
          }
        } else {
          gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
          const totalIterations = fill.length + 1;
          let currentIteration = 1;
          for (let i = 0; i < fill.length; i++) {
            let stop;
            if (typeof fillGradientStops[i] === "number") {
              stop = fillGradientStops[i];
            } else {
              stop = currentIteration / totalIterations;
            }
            gradient.addColorStop(stop, fill[i]);
            currentIteration++;
          }
        }
        return gradient;
      }
      destroy(options) {
        if (typeof options === "boolean") {
          options = { children: options };
        }
        options = Object.assign({}, defaultDestroyOptions, options);
        super.destroy(options);
        if (this._ownCanvas) {
          this.canvas.height = this.canvas.width = 0;
        }
        this.context = null;
        this.canvas = null;
        this._style = null;
      }
      get width() {
        this.updateText(true);
        return Math.abs(this.scale.x) * this._texture.orig.width;
      }
      set width(value) {
        this.updateText(true);
        const s = lib_exports.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
      }
      get height() {
        this.updateText(true);
        return Math.abs(this.scale.y) * this._texture.orig.height;
      }
      set height(value) {
        this.updateText(true);
        const s = lib_exports.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
      }
      get style() {
        return this._style;
      }
      set style(style) {
        style = style || {};
        if (style instanceof TextStyle) {
          this._style = style;
        } else {
          this._style = new TextStyle(style);
        }
        this.localStyleID = -1;
        this.dirty = true;
      }
      get text() {
        return this._text;
      }
      set text(text) {
        text = String(text === null || text === void 0 ? "" : text);
        if (this._text === text) {
          return;
        }
        this._text = text;
        this.dirty = true;
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(value) {
        this._autoResolution = false;
        if (this._resolution === value) {
          return;
        }
        this._resolution = value;
        this.dirty = true;
      }
    };
    Text = _Text;
    Text.defaultAutoResolution = true;
  }
});

// node_modules/@pixi/text/lib/index.mjs
var init_lib4 = __esm({
  "node_modules/@pixi/text/lib/index.mjs"() {
    init_const();
    init_Text();
    init_TextMetrics();
    init_TextStyle();
  }
});

// node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs
var BitmapFontData;
var init_BitmapFontData = __esm({
  "node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs"() {
    BitmapFontData = class {
      constructor() {
        this.info = [];
        this.common = [];
        this.page = [];
        this.char = [];
        this.kerning = [];
        this.distanceField = [];
      }
    };
  }
});

// node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs
var TextFormat;
var init_TextFormat = __esm({
  "node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs"() {
    init_BitmapFontData();
    TextFormat = class {
      static test(data) {
        return typeof data === "string" && data.startsWith("info face=");
      }
      static parse(txt) {
        const items = txt.match(/^[a-z]+\s+.+$/gm);
        const rawData = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: [],
          distanceField: []
        };
        for (const i in items) {
          const name = items[i].match(/^[a-z]+/gm)[0];
          const attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
          const itemData = {};
          for (const i2 in attributeList) {
            const split = attributeList[i2].split("=");
            const key = split[0];
            const strValue = split[1].replace(/"/gm, "");
            const floatValue = parseFloat(strValue);
            const value = isNaN(floatValue) ? strValue : floatValue;
            itemData[key] = value;
          }
          rawData[name].push(itemData);
        }
        const font = new BitmapFontData();
        rawData.info.forEach((info) => font.info.push({
          face: info.face,
          size: parseInt(info.size, 10)
        }));
        rawData.common.forEach((common) => font.common.push({
          lineHeight: parseInt(common.lineHeight, 10)
        }));
        rawData.page.forEach((page) => font.page.push({
          id: parseInt(page.id, 10),
          file: page.file
        }));
        rawData.char.forEach((char) => font.char.push({
          id: parseInt(char.id, 10),
          page: parseInt(char.page, 10),
          x: parseInt(char.x, 10),
          y: parseInt(char.y, 10),
          width: parseInt(char.width, 10),
          height: parseInt(char.height, 10),
          xoffset: parseInt(char.xoffset, 10),
          yoffset: parseInt(char.yoffset, 10),
          xadvance: parseInt(char.xadvance, 10)
        }));
        rawData.kerning.forEach((kerning) => font.kerning.push({
          first: parseInt(kerning.first, 10),
          second: parseInt(kerning.second, 10),
          amount: parseInt(kerning.amount, 10)
        }));
        rawData.distanceField.forEach((df) => font.distanceField.push({
          distanceRange: parseInt(df.distanceRange, 10),
          fieldType: df.fieldType
        }));
        return font;
      }
    };
  }
});

// node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs
var XMLFormat;
var init_XMLFormat = __esm({
  "node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs"() {
    init_BitmapFontData();
    XMLFormat = class {
      static test(data) {
        const xml = data;
        return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
      }
      static parse(xml) {
        const data = new BitmapFontData();
        const info = xml.getElementsByTagName("info");
        const common = xml.getElementsByTagName("common");
        const page = xml.getElementsByTagName("page");
        const char = xml.getElementsByTagName("char");
        const kerning = xml.getElementsByTagName("kerning");
        const distanceField = xml.getElementsByTagName("distanceField");
        for (let i = 0; i < info.length; i++) {
          data.info.push({
            face: info[i].getAttribute("face"),
            size: parseInt(info[i].getAttribute("size"), 10)
          });
        }
        for (let i = 0; i < common.length; i++) {
          data.common.push({
            lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
          });
        }
        for (let i = 0; i < page.length; i++) {
          data.page.push({
            id: parseInt(page[i].getAttribute("id"), 10) || 0,
            file: page[i].getAttribute("file")
          });
        }
        for (let i = 0; i < char.length; i++) {
          const letter = char[i];
          data.char.push({
            id: parseInt(letter.getAttribute("id"), 10),
            page: parseInt(letter.getAttribute("page"), 10) || 0,
            x: parseInt(letter.getAttribute("x"), 10),
            y: parseInt(letter.getAttribute("y"), 10),
            width: parseInt(letter.getAttribute("width"), 10),
            height: parseInt(letter.getAttribute("height"), 10),
            xoffset: parseInt(letter.getAttribute("xoffset"), 10),
            yoffset: parseInt(letter.getAttribute("yoffset"), 10),
            xadvance: parseInt(letter.getAttribute("xadvance"), 10)
          });
        }
        for (let i = 0; i < kerning.length; i++) {
          data.kerning.push({
            first: parseInt(kerning[i].getAttribute("first"), 10),
            second: parseInt(kerning[i].getAttribute("second"), 10),
            amount: parseInt(kerning[i].getAttribute("amount"), 10)
          });
        }
        for (let i = 0; i < distanceField.length; i++) {
          data.distanceField.push({
            fieldType: distanceField[i].getAttribute("fieldType"),
            distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
          });
        }
        return data;
      }
    };
  }
});

// node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs
var XMLStringFormat;
var init_XMLStringFormat = __esm({
  "node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs"() {
    init_lib();
    init_XMLFormat();
    XMLStringFormat = class {
      static test(data) {
        if (typeof data === "string" && data.includes("<font>")) {
          return XMLFormat.test(settings.ADAPTER.parseXML(data));
        }
        return false;
      }
      static parse(xmlTxt) {
        return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));
      }
    };
  }
});

// node_modules/@pixi/text-bitmap/lib/formats/index.mjs
function autoDetectFormat(data) {
  for (let i = 0; i < formats.length; i++) {
    if (formats[i].test(data)) {
      return formats[i];
    }
  }
  return null;
}
var formats;
var init_formats = __esm({
  "node_modules/@pixi/text-bitmap/lib/formats/index.mjs"() {
    init_TextFormat();
    init_TextFormat();
    init_XMLFormat();
    init_XMLFormat();
    init_XMLStringFormat();
    init_XMLStringFormat();
    formats = [
      TextFormat,
      XMLFormat,
      XMLStringFormat
    ];
  }
});

// node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs
function generateFillStyle(canvas, context, style, resolution, lines, metrics) {
  const fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  let gradient;
  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  const padding = style.padding || 0;
  const width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  const height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  const fill = fillStyle.slice();
  const fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    const lengthPlus1 = fill.length + 1;
    for (let i = 1; i < lengthPlus1; ++i) {
      fillGradientStops.push(i / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);
    let lastIterationStop = 0;
    const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    const gradStopLineHeight = textHeight / height;
    for (let i = 0; i < lines.length; i++) {
      const thisLineTop = metrics.lineHeight * i;
      for (let j = 0; j < fill.length; j++) {
        let lineStop = 0;
        if (typeof fillGradientStops[j] === "number") {
          lineStop = fillGradientStops[j];
        } else {
          lineStop = j / fill.length;
        }
        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        let clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);
    const totalIterations = fill.length + 1;
    let currentIteration = 1;
    for (let i = 0; i < fill.length; i++) {
      let stop;
      if (typeof fillGradientStops[i] === "number") {
        stop = fillGradientStops[i];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i]);
      currentIteration++;
    }
  }
  return gradient;
}
var init_generateFillStyle = __esm({
  "node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs"() {
    init_lib4();
  }
});

// node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs
function drawGlyph(canvas, context, metrics, x, y, resolution, style) {
  const char = metrics.text;
  const fontProperties = metrics.fontProperties;
  context.translate(x, y);
  context.scale(resolution, resolution);
  const tx = style.strokeThickness / 2;
  const ty = -(style.strokeThickness / 2);
  context.font = style.toFontString();
  context.lineWidth = style.strokeThickness;
  context.textBaseline = style.textBaseline;
  context.lineJoin = style.lineJoin;
  context.miterLimit = style.miterLimit;
  context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);
  context.strokeStyle = style.stroke;
  if (style.dropShadow) {
    const dropShadowColor = style.dropShadowColor;
    const dropShadowBlur = style.dropShadowBlur * resolution;
    const dropShadowDistance = style.dropShadowDistance * resolution;
    context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
    context.shadowBlur = dropShadowBlur;
    context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context.shadowColor = "black";
    context.shadowBlur = 0;
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "rgba(0, 0, 0, 0)";
}
var init_drawGlyph = __esm({
  "node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs"() {
    init_lib();
    init_generateFillStyle();
  }
});

// node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs
function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}
var init_extractCharCode = __esm({
  "node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs"() {
  }
});

// node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs
function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}
var init_splitTextToCharacters = __esm({
  "node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs"() {
  }
});

// node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs
function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i = 0, j = chars.length; i < j; i++) {
    const item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {
        result.push(String.fromCharCode(i2));
      }
    } else {
      result.push(...splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
var init_resolveCharacters = __esm({
  "node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs"() {
    init_splitTextToCharacters();
  }
});

// node_modules/@pixi/text-bitmap/lib/utils/index.mjs
var init_utils = __esm({
  "node_modules/@pixi/text-bitmap/lib/utils/index.mjs"() {
    init_drawGlyph();
    init_extractCharCode();
    init_generateFillStyle();
    init_resolveCharacters();
    init_splitTextToCharacters();
  }
});

// node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs
var _BitmapFont, BitmapFont;
var init_BitmapFont = __esm({
  "node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs"() {
    init_lib();
    init_lib4();
    init_BitmapFontData();
    init_formats();
    init_utils();
    init_resolveCharacters();
    init_drawGlyph();
    init_extractCharCode();
    _BitmapFont = class {
      constructor(data, textures, ownsTextures) {
        var _a;
        const [info] = data.info;
        const [common] = data.common;
        const [page] = data.page;
        const [distanceField] = data.distanceField;
        const res = lib_exports.getResolutionOfUrl(page.file);
        const pageTextures = {};
        this._ownsTextures = ownsTextures;
        this.font = info.face;
        this.size = info.size;
        this.lineHeight = common.lineHeight / res;
        this.chars = {};
        this.pageTextures = pageTextures;
        for (let i = 0; i < data.page.length; i++) {
          const { id, file } = data.page[i];
          pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];
          if ((distanceField == null ? void 0 : distanceField.fieldType) && distanceField.fieldType !== "none") {
            pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
            pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;
          }
        }
        for (let i = 0; i < data.char.length; i++) {
          const { id, page: page2 } = data.char[i];
          let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];
          x /= res;
          y /= res;
          width /= res;
          height /= res;
          xoffset /= res;
          yoffset /= res;
          xadvance /= res;
          const rect = new Rectangle(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);
          this.chars[id] = {
            xOffset: xoffset,
            yOffset: yoffset,
            xAdvance: xadvance,
            kerning: {},
            texture: new Texture(pageTextures[page2].baseTexture, rect),
            page: page2
          };
        }
        for (let i = 0; i < data.kerning.length; i++) {
          let { first, second, amount } = data.kerning[i];
          first /= res;
          second /= res;
          amount /= res;
          if (this.chars[second]) {
            this.chars[second].kerning[first] = amount;
          }
        }
        this.distanceFieldRange = distanceField == null ? void 0 : distanceField.distanceRange;
        this.distanceFieldType = ((_a = distanceField == null ? void 0 : distanceField.fieldType) == null ? void 0 : _a.toLowerCase()) ?? "none";
      }
      destroy() {
        for (const id in this.chars) {
          this.chars[id].texture.destroy();
          this.chars[id].texture = null;
        }
        for (const id in this.pageTextures) {
          if (this._ownsTextures) {
            this.pageTextures[id].destroy(true);
          }
          this.pageTextures[id] = null;
        }
        this.chars = null;
        this.pageTextures = null;
      }
      static install(data, textures, ownsTextures) {
        let fontData;
        if (data instanceof BitmapFontData) {
          fontData = data;
        } else {
          const format = autoDetectFormat(data);
          if (!format) {
            throw new Error("Unrecognized data format for font.");
          }
          fontData = format.parse(data);
        }
        if (textures instanceof Texture) {
          textures = [textures];
        }
        const font = new _BitmapFont(fontData, textures, ownsTextures);
        _BitmapFont.available[font.font] = font;
        return font;
      }
      static uninstall(name) {
        const font = _BitmapFont.available[name];
        if (!font) {
          throw new Error(`No font found named '${name}'`);
        }
        font.destroy();
        delete _BitmapFont.available[name];
      }
      static from(name, textStyle, options) {
        if (!name) {
          throw new Error("[BitmapFont] Property `name` is required.");
        }
        const {
          chars,
          padding,
          resolution,
          textureWidth,
          textureHeight,
          ...baseOptions
        } = Object.assign({}, _BitmapFont.defaultOptions, options);
        const charsList = resolveCharacters(chars);
        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
        const lineWidth = textureWidth;
        const fontData = new BitmapFontData();
        fontData.info[0] = {
          face: style.fontFamily,
          size: style.fontSize
        };
        fontData.common[0] = {
          lineHeight: style.fontSize
        };
        let positionX = 0;
        let positionY = 0;
        let canvas;
        let context;
        let baseTexture;
        let maxCharHeight = 0;
        const baseTextures = [];
        const textures = [];
        for (let i = 0; i < charsList.length; i++) {
          if (!canvas) {
            canvas = settings.ADAPTER.createCanvas();
            canvas.width = textureWidth;
            canvas.height = textureHeight;
            context = canvas.getContext("2d");
            baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions });
            baseTextures.push(baseTexture);
            textures.push(new Texture(baseTexture));
            fontData.page.push({
              id: textures.length - 1,
              file: ""
            });
          }
          const character = charsList[i];
          const metrics = TextMetrics.measureText(character, style, false, canvas);
          const width = metrics.width;
          const height = Math.ceil(metrics.height);
          const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
          if (positionY >= textureHeight - height * resolution) {
            if (positionY === 0) {
              throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
            }
            --i;
            canvas = null;
            context = null;
            baseTexture = null;
            positionY = 0;
            positionX = 0;
            maxCharHeight = 0;
            continue;
          }
          maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
          if (textureGlyphWidth * resolution + positionX >= lineWidth) {
            if (positionX === 0) {
              throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
            }
            --i;
            positionY += maxCharHeight * resolution;
            positionY = Math.ceil(positionY);
            positionX = 0;
            maxCharHeight = 0;
            continue;
          }
          drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);
          const id = extractCharCode(metrics.text);
          fontData.char.push({
            id,
            page: textures.length - 1,
            x: positionX / resolution,
            y: positionY / resolution,
            width: textureGlyphWidth,
            height,
            xoffset: 0,
            yoffset: 0,
            xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
          });
          positionX += (textureGlyphWidth + 2 * padding) * resolution;
          positionX = Math.ceil(positionX);
        }
        for (let i = 0, len = charsList.length; i < len; i++) {
          const first = charsList[i];
          for (let j = 0; j < len; j++) {
            const second = charsList[j];
            const c1 = context.measureText(first).width;
            const c2 = context.measureText(second).width;
            const total = context.measureText(first + second).width;
            const amount = total - (c1 + c2);
            if (amount) {
              fontData.kerning.push({
                first: extractCharCode(first),
                second: extractCharCode(second),
                amount
              });
            }
          }
        }
        const font = new _BitmapFont(fontData, textures, true);
        if (_BitmapFont.available[name] !== void 0) {
          _BitmapFont.uninstall(name);
        }
        _BitmapFont.available[name] = font;
        return font;
      }
    };
    BitmapFont = _BitmapFont;
    BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];
    BitmapFont.NUMERIC = [["0", "9"]];
    BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
    BitmapFont.ASCII = [[" ", "~"]];
    BitmapFont.defaultOptions = {
      resolution: 1,
      textureWidth: 512,
      textureHeight: 512,
      padding: 4,
      chars: _BitmapFont.ALPHANUMERIC
    };
    BitmapFont.available = {};
  }
});

// node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs
var MeshBatchUvs;
var init_MeshBatchUvs = __esm({
  "node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs"() {
    MeshBatchUvs = class {
      constructor(uvBuffer, uvMatrix) {
        this.uvBuffer = uvBuffer;
        this.uvMatrix = uvMatrix;
        this.data = null;
        this._bufferUpdateId = -1;
        this._textureUpdateId = -1;
        this._updateID = 0;
      }
      update(forceUpdate) {
        if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
          return;
        }
        this._bufferUpdateId = this.uvBuffer._updateID;
        this._textureUpdateId = this.uvMatrix._updateID;
        const data = this.uvBuffer.data;
        if (!this.data || this.data.length !== data.length) {
          this.data = new Float32Array(data.length);
        }
        this.uvMatrix.multiplyUvs(data, this.data);
        this._updateID++;
      }
    };
  }
});

// node_modules/@pixi/mesh/lib/Mesh.mjs
var tempPoint2, tempPolygon, _Mesh, Mesh;
var init_Mesh = __esm({
  "node_modules/@pixi/mesh/lib/Mesh.mjs"() {
    init_lib();
    init_lib2();
    init_MeshBatchUvs();
    tempPoint2 = new Point();
    tempPolygon = new Polygon();
    _Mesh = class extends Container {
      constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {
        super();
        this.geometry = geometry;
        this.shader = shader;
        this.state = state || State.for2d();
        this.drawMode = drawMode;
        this.start = 0;
        this.size = 0;
        this.uvs = null;
        this.indices = null;
        this.vertexData = new Float32Array(1);
        this.vertexDirty = -1;
        this._transformID = -1;
        this._roundPixels = settings.ROUND_PIXELS;
        this.batchUvs = null;
      }
      get geometry() {
        return this._geometry;
      }
      set geometry(value) {
        if (this._geometry === value) {
          return;
        }
        if (this._geometry) {
          this._geometry.refCount--;
          if (this._geometry.refCount === 0) {
            this._geometry.dispose();
          }
        }
        this._geometry = value;
        if (this._geometry) {
          this._geometry.refCount++;
        }
        this.vertexDirty = -1;
      }
      get uvBuffer() {
        return this.geometry.buffers[1];
      }
      get verticesBuffer() {
        return this.geometry.buffers[0];
      }
      set material(value) {
        this.shader = value;
      }
      get material() {
        return this.shader;
      }
      set blendMode(value) {
        this.state.blendMode = value;
      }
      get blendMode() {
        return this.state.blendMode;
      }
      set roundPixels(value) {
        if (this._roundPixels !== value) {
          this._transformID = -1;
        }
        this._roundPixels = value;
      }
      get roundPixels() {
        return this._roundPixels;
      }
      get tint() {
        return "tint" in this.shader ? this.shader.tint : null;
      }
      set tint(value) {
        this.shader.tint = value;
      }
      get tintValue() {
        return this.shader.tintValue;
      }
      get texture() {
        return "texture" in this.shader ? this.shader.texture : null;
      }
      set texture(value) {
        this.shader.texture = value;
      }
      _render(renderer) {
        const vertices = this.geometry.buffers[0].data;
        const shader = this.shader;
        if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {
          this._renderToBatch(renderer);
        } else {
          this._renderDefault(renderer);
        }
      }
      _renderDefault(renderer) {
        const shader = this.shader;
        shader.alpha = this.worldAlpha;
        if (shader.update) {
          shader.update();
        }
        renderer.batch.flush();
        shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
        renderer.shader.bind(shader);
        renderer.state.set(this.state);
        renderer.geometry.bind(this.geometry, shader);
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
      }
      _renderToBatch(renderer) {
        const geometry = this.geometry;
        const shader = this.shader;
        if (shader.uvMatrix) {
          shader.uvMatrix.update();
          this.calculateUvs();
        }
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = shader._tintRGB;
        this._texture = shader.texture;
        const pluginName = this.material.pluginName;
        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
        renderer.plugins[pluginName].render(this);
      }
      calculateVertices() {
        const geometry = this.geometry;
        const verticesBuffer = geometry.buffers[0];
        const vertices = verticesBuffer.data;
        const vertexDirtyId = verticesBuffer._updateID;
        if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
          return;
        }
        this._transformID = this.transform._worldID;
        if (this.vertexData.length !== vertices.length) {
          this.vertexData = new Float32Array(vertices.length);
        }
        const wt = this.transform.worldTransform;
        const a = wt.a;
        const b = wt.b;
        const c = wt.c;
        const d = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const vertexData = this.vertexData;
        for (let i = 0; i < vertexData.length / 2; i++) {
          const x = vertices[i * 2];
          const y = vertices[i * 2 + 1];
          vertexData[i * 2] = a * x + c * y + tx;
          vertexData[i * 2 + 1] = b * x + d * y + ty;
        }
        if (this._roundPixels) {
          const resolution = settings.RESOLUTION;
          for (let i = 0; i < vertexData.length; ++i) {
            vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
          }
        }
        this.vertexDirty = vertexDirtyId;
      }
      calculateUvs() {
        const geomUvs = this.geometry.buffers[1];
        const shader = this.shader;
        if (!shader.uvMatrix.isSimple) {
          if (!this.batchUvs) {
            this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
          }
          this.batchUvs.update();
          this.uvs = this.batchUvs.data;
        } else {
          this.uvs = geomUvs.data;
        }
      }
      _calculateBounds() {
        this.calculateVertices();
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
      }
      containsPoint(point) {
        if (!this.getBounds().contains(point.x, point.y)) {
          return false;
        }
        this.worldTransform.applyInverse(point, tempPoint2);
        const vertices = this.geometry.getBuffer("aVertexPosition").data;
        const points = tempPolygon.points;
        const indices2 = this.geometry.getIndex().data;
        const len = indices2.length;
        const step = this.drawMode === 4 ? 3 : 1;
        for (let i = 0; i + 2 < len; i += step) {
          const ind0 = indices2[i] * 2;
          const ind1 = indices2[i + 1] * 2;
          const ind2 = indices2[i + 2] * 2;
          points[0] = vertices[ind0];
          points[1] = vertices[ind0 + 1];
          points[2] = vertices[ind1];
          points[3] = vertices[ind1 + 1];
          points[4] = vertices[ind2];
          points[5] = vertices[ind2 + 1];
          if (tempPolygon.contains(tempPoint2.x, tempPoint2.y)) {
            return true;
          }
        }
        return false;
      }
      destroy(options) {
        super.destroy(options);
        if (this._cachedTexture) {
          this._cachedTexture.destroy();
          this._cachedTexture = null;
        }
        this.geometry = null;
        this.shader = null;
        this.state = null;
        this.uvs = null;
        this.indices = null;
        this.vertexData = null;
      }
    };
    Mesh = _Mesh;
    Mesh.BATCHABLE_SIZE = 100;
  }
});

// node_modules/@pixi/mesh/lib/MeshGeometry.mjs
var MeshGeometry;
var init_MeshGeometry = __esm({
  "node_modules/@pixi/mesh/lib/MeshGeometry.mjs"() {
    init_lib();
    MeshGeometry = class extends Geometry {
      constructor(vertices, uvs, index) {
        super();
        const verticesBuffer = new Buffer(vertices);
        const uvsBuffer = new Buffer(uvs, true);
        const indexBuffer = new Buffer(index, true, true);
        this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
        this._updateId = -1;
      }
      get vertexDirtyId() {
        return this.buffers[0]._updateID;
      }
    };
  }
});

// node_modules/@pixi/mesh/lib/shader/mesh.mjs
var fragment;
var init_mesh = __esm({
  "node_modules/@pixi/mesh/lib/shader/mesh.mjs"() {
    fragment = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
  }
});

// node_modules/@pixi/mesh/lib/shader/mesh2.mjs
var vertex;
var init_mesh2 = __esm({
  "node_modules/@pixi/mesh/lib/shader/mesh2.mjs"() {
    vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
  }
});

// node_modules/@pixi/mesh/lib/MeshMaterial.mjs
var MeshMaterial;
var init_MeshMaterial = __esm({
  "node_modules/@pixi/mesh/lib/MeshMaterial.mjs"() {
    init_lib();
    init_mesh();
    init_mesh2();
    MeshMaterial = class extends Shader {
      constructor(uSampler, options) {
        const uniforms = {
          uSampler,
          alpha: 1,
          uTextureMatrix: Matrix.IDENTITY,
          uColor: new Float32Array([1, 1, 1, 1])
        };
        options = Object.assign({
          tint: 16777215,
          alpha: 1,
          pluginName: "batch"
        }, options);
        if (options.uniforms) {
          Object.assign(uniforms, options.uniforms);
        }
        super(options.program || Program.from(vertex, fragment), uniforms);
        this._colorDirty = false;
        this.uvMatrix = new TextureMatrix(uSampler);
        this.batchable = options.program === void 0;
        this.pluginName = options.pluginName;
        this._tintColor = new Color(options.tint);
        this._tintRGB = this._tintColor.toLittleEndianNumber();
        this._colorDirty = true;
        this.alpha = options.alpha;
      }
      get texture() {
        return this.uniforms.uSampler;
      }
      set texture(value) {
        if (this.uniforms.uSampler !== value) {
          if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
            this._colorDirty = true;
          }
          this.uniforms.uSampler = value;
          this.uvMatrix.texture = value;
        }
      }
      set alpha(value) {
        if (value === this._alpha)
          return;
        this._alpha = value;
        this._colorDirty = true;
      }
      get alpha() {
        return this._alpha;
      }
      set tint(value) {
        if (value === this.tint)
          return;
        this._tintColor.setValue(value);
        this._tintRGB = this._tintColor.toLittleEndianNumber();
        this._colorDirty = true;
      }
      get tint() {
        return this._tintColor.value;
      }
      get tintValue() {
        return this._tintColor.toNumber();
      }
      update() {
        if (this._colorDirty) {
          this._colorDirty = false;
          const baseTexture = this.texture.baseTexture;
          const applyToChannels = baseTexture.alphaMode;
          Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
        }
        if (this.uvMatrix.update()) {
          this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
        }
      }
    };
  }
});

// node_modules/@pixi/mesh/lib/index.mjs
var init_lib5 = __esm({
  "node_modules/@pixi/mesh/lib/index.mjs"() {
    init_Mesh();
    init_MeshBatchUvs();
    init_MeshGeometry();
    init_MeshMaterial();
  }
});

// node_modules/@pixi/text-bitmap/lib/shader/msdf.mjs
var msdfFrag;
var init_msdf = __esm({
  "node_modules/@pixi/text-bitmap/lib/shader/msdf.mjs"() {
    msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n";
  }
});

// node_modules/@pixi/text-bitmap/lib/shader/msdf2.mjs
var msdfVert;
var init_msdf2 = __esm({
  "node_modules/@pixi/text-bitmap/lib/shader/msdf2.mjs"() {
    msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
  }
});

// node_modules/@pixi/text-bitmap/lib/BitmapText.mjs
var pageMeshDataDefaultPageMeshData, pageMeshDataMSDFPageMeshData, charRenderDataPool, _BitmapText, BitmapText;
var init_BitmapText = __esm({
  "node_modules/@pixi/text-bitmap/lib/BitmapText.mjs"() {
    init_lib();
    init_lib2();
    init_lib5();
    init_BitmapFont();
    init_msdf();
    init_msdf2();
    init_utils();
    init_splitTextToCharacters();
    init_extractCharCode();
    pageMeshDataDefaultPageMeshData = [];
    pageMeshDataMSDFPageMeshData = [];
    charRenderDataPool = [];
    _BitmapText = class extends Container {
      constructor(text, style = {}) {
        super();
        const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);
        if (!BitmapFont.available[fontName]) {
          throw new Error(`Missing BitmapFont "${fontName}"`);
        }
        this._activePagesMeshData = [];
        this._textWidth = 0;
        this._textHeight = 0;
        this._align = align;
        this._tintColor = new Color(tint);
        this._font = void 0;
        this._fontName = fontName;
        this._fontSize = fontSize;
        this.text = text;
        this._maxWidth = maxWidth;
        this._maxLineHeight = 0;
        this._letterSpacing = letterSpacing;
        this._anchor = new ObservablePoint(() => {
          this.dirty = true;
        }, this, 0, 0);
        this._roundPixels = settings.ROUND_PIXELS;
        this.dirty = true;
        this._resolution = settings.RESOLUTION;
        this._autoResolution = true;
        this._textureCache = {};
      }
      updateText() {
        var _a;
        const data = BitmapFont.available[this._fontName];
        const fontSize = this.fontSize;
        const scale = fontSize / data.size;
        const pos = new Point();
        const chars = [];
        const lineWidths = [];
        const lineSpaces = [];
        const text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
        const charsInput = splitTextToCharacters(text);
        const maxWidth = this._maxWidth * data.size / fontSize;
        const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
        let prevCharCode = null;
        let lastLineWidth = 0;
        let maxLineWidth = 0;
        let line = 0;
        let lastBreakPos = -1;
        let lastBreakWidth = 0;
        let spacesRemoved = 0;
        let maxLineHeight = 0;
        let spaceCount = 0;
        for (let i = 0; i < charsInput.length; i++) {
          const char = charsInput[i];
          const charCode = extractCharCode(char);
          if (/(?:\s)/.test(char)) {
            lastBreakPos = i;
            lastBreakWidth = lastLineWidth;
            spaceCount++;
          }
          if (char === "\r" || char === "\n") {
            lineWidths.push(lastLineWidth);
            lineSpaces.push(-1);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            ++line;
            ++spacesRemoved;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            spaceCount = 0;
            continue;
          }
          const charData = data.chars[charCode];
          if (!charData) {
            continue;
          }
          if (prevCharCode && charData.kerning[prevCharCode]) {
            pos.x += charData.kerning[prevCharCode];
          }
          const charRenderData = charRenderDataPool.pop() || {
            texture: Texture.EMPTY,
            line: 0,
            charCode: 0,
            prevSpaces: 0,
            position: new Point()
          };
          charRenderData.texture = charData.texture;
          charRenderData.line = line;
          charRenderData.charCode = charCode;
          charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);
          charRenderData.position.y = Math.round(pos.y + charData.yOffset);
          charRenderData.prevSpaces = spaceCount;
          chars.push(charRenderData);
          lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
          pos.x += charData.xAdvance + this._letterSpacing;
          maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
          prevCharCode = charCode;
          if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
            ++spacesRemoved;
            lib_exports.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
            i = lastBreakPos;
            lastBreakPos = -1;
            lineWidths.push(lastBreakWidth);
            lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
            maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
            line++;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            spaceCount = 0;
          }
        }
        const lastChar = charsInput[charsInput.length - 1];
        if (lastChar !== "\r" && lastChar !== "\n") {
          if (/(?:\s)/.test(lastChar)) {
            lastLineWidth = lastBreakWidth;
          }
          lineWidths.push(lastLineWidth);
          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
          lineSpaces.push(-1);
        }
        const lineAlignOffsets = [];
        for (let i = 0; i <= line; i++) {
          let alignOffset = 0;
          if (this._align === "right") {
            alignOffset = maxLineWidth - lineWidths[i];
          } else if (this._align === "center") {
            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
          } else if (this._align === "justify") {
            alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
          }
          lineAlignOffsets.push(alignOffset);
        }
        const lenChars = chars.length;
        const pagesMeshData = {};
        const newPagesMeshData = [];
        const activePagesMeshData = this._activePagesMeshData;
        pageMeshDataPool.push(...activePagesMeshData);
        for (let i = 0; i < lenChars; i++) {
          const texture = chars[i].texture;
          const baseTextureUid = texture.baseTexture.uid;
          if (!pagesMeshData[baseTextureUid]) {
            let pageMeshData = pageMeshDataPool.pop();
            if (!pageMeshData) {
              const geometry = new MeshGeometry();
              let material;
              let meshBlendMode;
              if (data.distanceFieldType === "none") {
                material = new MeshMaterial(Texture.EMPTY);
                meshBlendMode = BLEND_MODES.NORMAL;
              } else {
                material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
                meshBlendMode = BLEND_MODES.NORMAL_NPM;
              }
              const mesh = new Mesh(geometry, material);
              mesh.blendMode = meshBlendMode;
              pageMeshData = {
                index: 0,
                indexCount: 0,
                vertexCount: 0,
                uvsCount: 0,
                total: 0,
                mesh,
                vertices: null,
                uvs: null,
                indices: null
              };
            }
            pageMeshData.index = 0;
            pageMeshData.indexCount = 0;
            pageMeshData.vertexCount = 0;
            pageMeshData.uvsCount = 0;
            pageMeshData.total = 0;
            const { _textureCache } = this;
            _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
            pageMeshData.mesh.texture = _textureCache[baseTextureUid];
            pageMeshData.mesh.tint = this._tintColor.value;
            newPagesMeshData.push(pageMeshData);
            pagesMeshData[baseTextureUid] = pageMeshData;
          }
          pagesMeshData[baseTextureUid].total++;
        }
        for (let i = 0; i < activePagesMeshData.length; i++) {
          if (!newPagesMeshData.includes(activePagesMeshData[i])) {
            this.removeChild(activePagesMeshData[i].mesh);
          }
        }
        for (let i = 0; i < newPagesMeshData.length; i++) {
          if (newPagesMeshData[i].mesh.parent !== this) {
            this.addChild(newPagesMeshData[i].mesh);
          }
        }
        this._activePagesMeshData = newPagesMeshData;
        for (const i in pagesMeshData) {
          const pageMeshData = pagesMeshData[i];
          const total = pageMeshData.total;
          if (!(((_a = pageMeshData.indices) == null ? void 0 : _a.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
            pageMeshData.vertices = new Float32Array(4 * 2 * total);
            pageMeshData.uvs = new Float32Array(4 * 2 * total);
            pageMeshData.indices = new Uint16Array(6 * total);
          } else {
            const total2 = pageMeshData.total;
            const vertices = pageMeshData.vertices;
            for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {
              vertices[i2] = 0;
            }
          }
          pageMeshData.mesh.size = 6 * total;
        }
        for (let i = 0; i < lenChars; i++) {
          const char = chars[i];
          let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
          if (this._roundPixels) {
            offset = Math.round(offset);
          }
          const xPos = offset * scale;
          const yPos = char.position.y * scale;
          const texture = char.texture;
          const pageMesh = pagesMeshData[texture.baseTexture.uid];
          const textureFrame = texture.frame;
          const textureUvs = texture._uvs;
          const index = pageMesh.index++;
          pageMesh.indices[index * 6 + 0] = 0 + index * 4;
          pageMesh.indices[index * 6 + 1] = 1 + index * 4;
          pageMesh.indices[index * 6 + 2] = 2 + index * 4;
          pageMesh.indices[index * 6 + 3] = 0 + index * 4;
          pageMesh.indices[index * 6 + 4] = 2 + index * 4;
          pageMesh.indices[index * 6 + 5] = 3 + index * 4;
          pageMesh.vertices[index * 8 + 0] = xPos;
          pageMesh.vertices[index * 8 + 1] = yPos;
          pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
          pageMesh.vertices[index * 8 + 3] = yPos;
          pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
          pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
          pageMesh.vertices[index * 8 + 6] = xPos;
          pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
          pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
          pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
          pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
          pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
          pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
          pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
          pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
          pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
        }
        this._textWidth = maxLineWidth * scale;
        this._textHeight = (pos.y + data.lineHeight) * scale;
        for (const i in pagesMeshData) {
          const pageMeshData = pagesMeshData[i];
          if (this.anchor.x !== 0 || this.anchor.y !== 0) {
            let vertexCount = 0;
            const anchorOffsetX = this._textWidth * this.anchor.x;
            const anchorOffsetY = this._textHeight * this.anchor.y;
            for (let i2 = 0; i2 < pageMeshData.total; i2++) {
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            }
          }
          this._maxLineHeight = maxLineHeight * scale;
          const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
          const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
          const indexBuffer = pageMeshData.mesh.geometry.getIndex();
          vertexBuffer.data = pageMeshData.vertices;
          textureBuffer.data = pageMeshData.uvs;
          indexBuffer.data = pageMeshData.indices;
          vertexBuffer.update();
          textureBuffer.update();
          indexBuffer.update();
        }
        for (let i = 0; i < chars.length; i++) {
          charRenderDataPool.push(chars[i]);
        }
        this._font = data;
        this.dirty = false;
      }
      updateTransform() {
        this.validate();
        this.containerUpdateTransform();
      }
      _render(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
          this._resolution = renderer.resolution;
          this.dirty = true;
        }
        const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];
        if (distanceFieldType !== "none") {
          const { a, b, c, d } = this.worldTransform;
          const dx = Math.sqrt(a * a + b * b);
          const dy = Math.sqrt(c * c + d * d);
          const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
          const fontScale = this.fontSize / size;
          const resolution = renderer._view.resolution;
          for (const mesh of this._activePagesMeshData) {
            mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
          }
        }
        super._render(renderer);
      }
      getLocalBounds() {
        this.validate();
        return super.getLocalBounds();
      }
      validate() {
        const font = BitmapFont.available[this._fontName];
        if (!font) {
          throw new Error(`Missing BitmapFont "${this._fontName}"`);
        }
        if (this._font !== font) {
          this.dirty = true;
        }
        if (this.dirty) {
          this.updateText();
        }
      }
      get tint() {
        return this._tintColor.value;
      }
      set tint(value) {
        if (this.tint === value)
          return;
        this._tintColor.setValue(value);
        for (let i = 0; i < this._activePagesMeshData.length; i++) {
          this._activePagesMeshData[i].mesh.tint = value;
        }
      }
      get align() {
        return this._align;
      }
      set align(value) {
        if (this._align !== value) {
          this._align = value;
          this.dirty = true;
        }
      }
      get fontName() {
        return this._fontName;
      }
      set fontName(value) {
        if (!BitmapFont.available[value]) {
          throw new Error(`Missing BitmapFont "${value}"`);
        }
        if (this._fontName !== value) {
          this._fontName = value;
          this.dirty = true;
        }
      }
      get fontSize() {
        return this._fontSize ?? BitmapFont.available[this._fontName].size;
      }
      set fontSize(value) {
        if (this._fontSize !== value) {
          this._fontSize = value;
          this.dirty = true;
        }
      }
      get anchor() {
        return this._anchor;
      }
      set anchor(value) {
        if (typeof value === "number") {
          this._anchor.set(value);
        } else {
          this._anchor.copyFrom(value);
        }
      }
      get text() {
        return this._text;
      }
      set text(text) {
        text = String(text === null || text === void 0 ? "" : text);
        if (this._text === text) {
          return;
        }
        this._text = text;
        this.dirty = true;
      }
      get maxWidth() {
        return this._maxWidth;
      }
      set maxWidth(value) {
        if (this._maxWidth === value) {
          return;
        }
        this._maxWidth = value;
        this.dirty = true;
      }
      get maxLineHeight() {
        this.validate();
        return this._maxLineHeight;
      }
      get textWidth() {
        this.validate();
        return this._textWidth;
      }
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(value) {
        if (this._letterSpacing !== value) {
          this._letterSpacing = value;
          this.dirty = true;
        }
      }
      get roundPixels() {
        return this._roundPixels;
      }
      set roundPixels(value) {
        if (value !== this._roundPixels) {
          this._roundPixels = value;
          this.dirty = true;
        }
      }
      get textHeight() {
        this.validate();
        return this._textHeight;
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(value) {
        this._autoResolution = false;
        if (this._resolution === value) {
          return;
        }
        this._resolution = value;
        this.dirty = true;
      }
      destroy(options) {
        const { _textureCache } = this;
        const data = BitmapFont.available[this._fontName];
        const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
        pageMeshDataPool.push(...this._activePagesMeshData);
        for (const pageMeshData of this._activePagesMeshData) {
          this.removeChild(pageMeshData.mesh);
        }
        this._activePagesMeshData = [];
        pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
          page.mesh.texture = Texture.EMPTY;
        });
        for (const id in _textureCache) {
          const texture = _textureCache[id];
          texture.destroy();
          delete _textureCache[id];
        }
        this._font = null;
        this._tintColor = null;
        this._textureCache = null;
        super.destroy(options);
      }
    };
    BitmapText = _BitmapText;
    BitmapText.styleDefaults = {
      align: "left",
      tint: 16777215,
      maxWidth: 0,
      letterSpacing: 0
    };
  }
});

// node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs
function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url.startsWith(`data:${mimes}`);
}
var init_checkDataUrl = __esm({
  "node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs"() {
  }
});

// node_modules/@pixi/assets/lib/utils/checkExtension.mjs
function checkExtension(url, extension) {
  const tempURL = url.split("?")[0];
  const ext = lib_exports.path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}
var init_checkExtension = __esm({
  "node_modules/@pixi/assets/lib/utils/checkExtension.mjs"() {
    init_lib();
  }
});

// node_modules/@pixi/assets/lib/utils/convertToList.mjs
var convertToList;
var init_convertToList = __esm({
  "node_modules/@pixi/assets/lib/utils/convertToList.mjs"() {
    convertToList = (input, transform) => {
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!transform) {
        return input;
      }
      return input.map((item) => {
        if (typeof item === "string") {
          return transform(item);
        }
        return item;
      });
    };
  }
});

// node_modules/@pixi/assets/lib/utils/copySearchParams.mjs
var copySearchParams;
var init_copySearchParams = __esm({
  "node_modules/@pixi/assets/lib/utils/copySearchParams.mjs"() {
    copySearchParams = (targetUrl, sourceUrl) => {
      const searchParams = sourceUrl.split("?")[1];
      if (searchParams) {
        targetUrl += `?${searchParams}`;
      }
      return targetUrl;
    };
  }
});

// node_modules/@pixi/assets/lib/utils/createStringVariations.mjs
function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i = 0; i < id.length; i++) {
    const value = id[i];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}
var init_createStringVariations = __esm({
  "node_modules/@pixi/assets/lib/utils/createStringVariations.mjs"() {
  }
});

// node_modules/@pixi/assets/lib/utils/isSingleItem.mjs
var isSingleItem;
var init_isSingleItem = __esm({
  "node_modules/@pixi/assets/lib/utils/isSingleItem.mjs"() {
    isSingleItem = (item) => !Array.isArray(item);
  }
});

// node_modules/@pixi/assets/lib/utils/index.mjs
var init_utils2 = __esm({
  "node_modules/@pixi/assets/lib/utils/index.mjs"() {
    init_checkDataUrl();
    init_checkExtension();
    init_convertToList();
    init_copySearchParams();
    init_createStringVariations();
    init_isSingleItem();
  }
});

// node_modules/@pixi/assets/lib/cache/Cache.mjs
var CacheClass, Cache;
var init_Cache = __esm({
  "node_modules/@pixi/assets/lib/cache/Cache.mjs"() {
    init_lib();
    init_utils2();
    init_convertToList();
    CacheClass = class {
      constructor() {
        this._parsers = [];
        this._cache = /* @__PURE__ */ new Map();
        this._cacheMap = /* @__PURE__ */ new Map();
      }
      reset() {
        this._cacheMap.clear();
        this._cache.clear();
      }
      has(key) {
        return this._cache.has(key);
      }
      get(key) {
        const result = this._cache.get(key);
        if (!result) {
          console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
        }
        return result;
      }
      set(key, value) {
        const keys = convertToList(key);
        let cacheableAssets;
        for (let i = 0; i < this.parsers.length; i++) {
          const parser = this.parsers[i];
          if (parser.test(value)) {
            cacheableAssets = parser.getCacheableAssets(keys, value);
            break;
          }
        }
        if (!cacheableAssets) {
          cacheableAssets = {};
          keys.forEach((key2) => {
            cacheableAssets[key2] = value;
          });
        }
        const cacheKeys = Object.keys(cacheableAssets);
        const cachedAssets = {
          cacheKeys,
          keys
        };
        keys.forEach((key2) => {
          this._cacheMap.set(key2, cachedAssets);
        });
        cacheKeys.forEach((key2) => {
          if (this._cache.has(key2) && this._cache.get(key2) !== value) {
            console.warn("[Cache] already has key:", key2);
          }
          this._cache.set(key2, cacheableAssets[key2]);
        });
        if (value instanceof Texture) {
          const texture = value;
          keys.forEach((key2) => {
            if (texture.baseTexture !== Texture.EMPTY.baseTexture) {
              BaseTexture.addToCache(texture.baseTexture, key2);
            }
            Texture.addToCache(texture, key2);
          });
        }
      }
      remove(key) {
        this._cacheMap.get(key);
        if (!this._cacheMap.has(key)) {
          console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
          return;
        }
        const cacheMap = this._cacheMap.get(key);
        const cacheKeys = cacheMap.cacheKeys;
        cacheKeys.forEach((key2) => {
          this._cache.delete(key2);
        });
        cacheMap.keys.forEach((key2) => {
          this._cacheMap.delete(key2);
        });
      }
      get parsers() {
        return this._parsers;
      }
    };
    Cache = new CacheClass();
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs
var LoaderParserPriority;
var init_LoaderParser = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs"() {
    LoaderParserPriority = ((LoaderParserPriority2) => {
      LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
      LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
      LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
      return LoaderParserPriority2;
    })(LoaderParserPriority || {});
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs
var validJSONExtension, validJSONMIME, loadJson;
var init_loadJson = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs"() {
    init_lib();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validJSONExtension = ".json";
    validJSONMIME = "application/json";
    loadJson = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadJson",
      test(url) {
        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);
      },
      async load(url) {
        const response = await settings.ADAPTER.fetch(url);
        const json = await response.json();
        return json;
      }
    };
    extensions.add(loadJson);
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs
var validTXTExtension, validTXTMIME, loadTxt;
var init_loadTxt = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs"() {
    init_lib();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validTXTExtension = ".txt";
    validTXTMIME = "text/plain";
    loadTxt = {
      name: "loadTxt",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      test(url) {
        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);
      },
      async load(url) {
        const response = await settings.ADAPTER.fetch(url);
        const txt = await response.text();
        return txt;
      }
    };
    extensions.add(loadTxt);
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs
function getFontFamilyName(url) {
  const ext = lib_exports.path.extname(url);
  const name = lib_exports.path.basename(url, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
var validWeights, validFontExtensions, validFontMIMEs, CSS_IDENT_TOKEN_REGEX, loadWebFont;
var init_loadWebFont = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs"() {
    init_lib();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validWeights = [
      "normal",
      "bold",
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900"
    ];
    validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
    validFontMIMEs = [
      "font/ttf",
      "font/otf",
      "font/woff",
      "font/woff2"
    ];
    CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
    loadWebFont = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadWebFont",
      test(url) {
        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);
      },
      async load(url, options) {
        var _a, _b, _c;
        const fonts = settings.ADAPTER.getFontFaceSet();
        if (fonts) {
          const fontFaces = [];
          const name = ((_a = options.data) == null ? void 0 : _a.family) ?? getFontFamilyName(url);
          const weights = ((_c = (_b = options.data) == null ? void 0 : _b.weights) == null ? void 0 : _c.filter((weight) => validWeights.includes(weight))) ?? ["normal"];
          const data = options.data ?? {};
          for (let i = 0; i < weights.length; i++) {
            const weight = weights[i];
            const font = new FontFace(name, `url(${encodeURI(url)})`, {
              ...data,
              weight
            });
            await font.load();
            fonts.add(font);
            fontFaces.push(font);
          }
          return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
        }
        console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
        return null;
      },
      unload(font) {
        (Array.isArray(font) ? font : [font]).forEach((t) => settings.ADAPTER.getFontFaceSet().delete(t));
      }
    };
    extensions.add(loadWebFont);
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs
function createTexture(base, loader, url) {
  const texture = new Texture(base);
  texture.baseTexture.on("dispose", () => {
    delete loader.promiseCache[url];
  });
  return texture;
}
var init_createTexture = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs"() {
    init_lib();
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs
var UUID, MAX_WORKERS, WHITE_PNG, checkImageBitmapCode, workerCode, workerURL, WorkerManagerClass, WorkerManager;
var init_WorkerManager = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs"() {
    UUID = 0;
    WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    checkImageBitmapCode = {
      id: "checkImageBitmap",
      code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
    };
    workerCode = {
      id: "loadImageBitmap",
      code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
    };
    WorkerManagerClass = class {
      constructor() {
        this._initialized = false;
        this._createdWorkers = 0;
        this.workerPool = [];
        this.queue = [];
        this.resolveHash = {};
      }
      isImageBitmapSupported() {
        if (this._isImageBitmapSupported !== void 0)
          return this._isImageBitmapSupported;
        this._isImageBitmapSupported = new Promise((resolve) => {
          const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));
          const worker = new Worker(workerURL2);
          worker.addEventListener("message", (event) => {
            worker.terminate();
            URL.revokeObjectURL(workerURL2);
            resolve(event.data);
          });
        });
        return this._isImageBitmapSupported;
      }
      loadImageBitmap(src) {
        return this._run("loadImageBitmap", [src]);
      }
      async _initWorkers() {
        if (this._initialized)
          return;
        this._initialized = true;
      }
      getWorker() {
        if (MAX_WORKERS === void 0) {
          MAX_WORKERS = navigator.hardwareConcurrency || 4;
        }
        let worker = this.workerPool.pop();
        if (!worker && this._createdWorkers < MAX_WORKERS) {
          if (!workerURL) {
            workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
          }
          this._createdWorkers++;
          worker = new Worker(workerURL);
          worker.addEventListener("message", (event) => {
            this.complete(event.data);
            this.returnWorker(event.target);
            this.next();
          });
        }
        return worker;
      }
      returnWorker(worker) {
        this.workerPool.push(worker);
      }
      complete(data) {
        if (data.error !== void 0) {
          this.resolveHash[data.uuid].reject(data.error);
        } else {
          this.resolveHash[data.uuid].resolve(data.data);
        }
        this.resolveHash[data.uuid] = null;
      }
      async _run(id, args) {
        await this._initWorkers();
        const promise = new Promise((resolve, reject) => {
          this.queue.push({ id, arguments: args, resolve, reject });
        });
        this.next();
        return promise;
      }
      next() {
        if (!this.queue.length)
          return;
        const worker = this.getWorker();
        if (!worker) {
          return;
        }
        const toDo = this.queue.pop();
        const id = toDo.id;
        this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
        worker.postMessage({
          data: toDo.arguments,
          uuid: UUID++,
          id
        });
      }
    };
    WorkerManager = new WorkerManagerClass();
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs
async function loadImageBitmap(url) {
  const response = await settings.ADAPTER.fetch(url);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
var validImageExtensions, validImageMIMEs, loadTextures;
var init_loadTextures = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs"() {
    init_lib();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    init_WorkerManager();
    init_createTexture();
    validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
    validImageMIMEs = [
      "image/jpeg",
      "image/png",
      "image/webp",
      "image/avif"
    ];
    loadTextures = {
      name: "loadTextures",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.High
      },
      config: {
        preferWorkers: true,
        preferCreateImageBitmap: true,
        crossOrigin: "anonymous"
      },
      test(url) {
        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);
      },
      async load(url, asset, loader) {
        let src = null;
        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
          if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
            src = await WorkerManager.loadImageBitmap(url);
          } else {
            src = await loadImageBitmap(url);
          }
        } else {
          src = await new Promise((resolve) => {
            src = new Image();
            src.crossOrigin = this.config.crossOrigin;
            src.src = url;
            if (src.complete) {
              resolve(src);
            } else {
              src.onload = () => {
                resolve(src);
              };
            }
          });
        }
        const base = new BaseTexture(src, {
          resolution: lib_exports.getResolutionOfUrl(url),
          ...asset.data
        });
        base.resource.src = url;
        return createTexture(base, loader, url);
      },
      unload(texture) {
        texture.destroy(true);
      }
    };
    extensions.add(loadTextures);
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs
var validSVGExtension, validSVGMIME, loadSVG;
var init_loadSVG = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs"() {
    init_lib();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    init_loadTextures();
    init_createTexture();
    validSVGExtension = ".svg";
    validSVGMIME = "image/svg+xml";
    loadSVG = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.High
      },
      name: "loadSVG",
      test(url) {
        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);
      },
      async testParse(data) {
        return SVGResource.test(data);
      },
      async parse(asset, data, loader) {
        var _a;
        const src = new SVGResource(asset, (_a = data == null ? void 0 : data.data) == null ? void 0 : _a.resourceOptions);
        await src.load();
        const base = new BaseTexture(src, {
          resolution: lib_exports.getResolutionOfUrl(asset),
          ...data == null ? void 0 : data.data
        });
        base.resource.src = asset;
        const texture = createTexture(base, loader, asset);
        return texture;
      },
      async load(url, _options) {
        const response = await settings.ADAPTER.fetch(url);
        return response.text();
      },
      unload: loadTextures.unload
    };
    extensions.add(loadSVG);
  }
});

// node_modules/@pixi/assets/lib/BackgroundLoader.mjs
var BackgroundLoader;
var init_BackgroundLoader = __esm({
  "node_modules/@pixi/assets/lib/BackgroundLoader.mjs"() {
    BackgroundLoader = class {
      constructor(loader, verbose = false) {
        this._loader = loader;
        this._assetList = [];
        this._isLoading = false;
        this._maxConcurrent = 1;
        this.verbose = verbose;
      }
      add(assetUrls) {
        assetUrls.forEach((a) => {
          this._assetList.push(a);
        });
        if (this.verbose)
          console.log("[BackgroundLoader] assets: ", this._assetList);
        if (this._isActive && !this._isLoading) {
          this._next();
        }
      }
      async _next() {
        if (this._assetList.length && this._isActive) {
          this._isLoading = true;
          const toLoad = [];
          const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
          for (let i = 0; i < toLoadAmount; i++) {
            toLoad.push(this._assetList.pop());
          }
          await this._loader.load(toLoad);
          this._isLoading = false;
          this._next();
        }
      }
      get active() {
        return this._isActive;
      }
      set active(value) {
        if (this._isActive === value)
          return;
        this._isActive = value;
        if (value && !this._isLoading) {
          this._next();
        }
      }
    };
  }
});

// node_modules/@pixi/assets/lib/loader/Loader.mjs
var Loader;
var init_Loader = __esm({
  "node_modules/@pixi/assets/lib/loader/Loader.mjs"() {
    init_lib();
    init_utils2();
    init_isSingleItem();
    init_convertToList();
    Loader = class {
      constructor() {
        this._parsers = [];
        this._parsersValidated = false;
        this.parsers = new Proxy(this._parsers, {
          set: (target, key, value) => {
            this._parsersValidated = false;
            target[key] = value;
            return true;
          }
        });
        this.promiseCache = {};
      }
      reset() {
        this._parsersValidated = false;
        this.promiseCache = {};
      }
      _getLoadPromiseAndParser(url, data) {
        const result = {
          promise: null,
          parser: null
        };
        result.promise = (async () => {
          var _a, _b;
          let asset = null;
          let parser = null;
          if (data.loadParser) {
            parser = this._parserHash[data.loadParser];
            if (!parser) {
              console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
            }
          }
          if (!parser) {
            for (let i = 0; i < this.parsers.length; i++) {
              const parserX = this.parsers[i];
              if (parserX.load && ((_a = parserX.test) == null ? void 0 : _a.call(parserX, url, data, this))) {
                parser = parserX;
                break;
              }
            }
            if (!parser) {
              console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
              return null;
            }
          }
          asset = await parser.load(url, data, this);
          result.parser = parser;
          for (let i = 0; i < this.parsers.length; i++) {
            const parser2 = this.parsers[i];
            if (parser2.parse) {
              if (parser2.parse && await ((_b = parser2.testParse) == null ? void 0 : _b.call(parser2, asset, data, this))) {
                asset = await parser2.parse(asset, data, this) || asset;
                result.parser = parser2;
              }
            }
          }
          return asset;
        })();
        return result;
      }
      async load(assetsToLoadIn, onProgress) {
        if (!this._parsersValidated) {
          this._validateParsers();
        }
        let count = 0;
        const assets = {};
        const singleAsset = isSingleItem(assetsToLoadIn);
        const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
          src: item
        }));
        const total = assetsToLoad.length;
        const promises = assetsToLoad.map(async (asset) => {
          const url = lib_exports.path.toAbsolute(asset.src);
          if (!assets[asset.src]) {
            try {
              if (!this.promiseCache[url]) {
                this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
              }
              assets[asset.src] = await this.promiseCache[url].promise;
              if (onProgress)
                onProgress(++count / total);
            } catch (e) {
              delete this.promiseCache[url];
              delete assets[asset.src];
              throw new Error(`[Loader.load] Failed to load ${url}.
${e}`);
            }
          }
        });
        await Promise.all(promises);
        return singleAsset ? assets[assetsToLoad[0].src] : assets;
      }
      async unload(assetsToUnloadIn) {
        const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
          src: item
        }));
        const promises = assetsToUnload.map(async (asset) => {
          var _a, _b;
          const url = lib_exports.path.toAbsolute(asset.src);
          const loadPromise = this.promiseCache[url];
          if (loadPromise) {
            const loadedAsset = await loadPromise.promise;
            (_b = (_a = loadPromise.parser) == null ? void 0 : _a.unload) == null ? void 0 : _b.call(_a, loadedAsset, asset, this);
            delete this.promiseCache[url];
          }
        });
        await Promise.all(promises);
      }
      _validateParsers() {
        this._parsersValidated = true;
        this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
          if (hash[parser.name]) {
            console.warn(`[Assets] loadParser name conflict "${parser.name}"`);
          }
          return { ...hash, [parser.name]: parser };
        }, {});
      }
    };
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs
var init_utils3 = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs"() {
    init_createTexture();
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs
var init_textures = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs"() {
    init_loadSVG();
    init_loadTextures();
    init_utils3();
  }
});

// node_modules/@pixi/assets/lib/loader/parsers/index.mjs
var init_parsers = __esm({
  "node_modules/@pixi/assets/lib/loader/parsers/index.mjs"() {
    init_LoaderParser();
    init_loadJson();
    init_loadTxt();
    init_loadWebFont();
    init_textures();
  }
});

// node_modules/@pixi/assets/lib/resolver/Resolver.mjs
var Resolver;
var init_Resolver = __esm({
  "node_modules/@pixi/assets/lib/resolver/Resolver.mjs"() {
    init_lib();
    init_convertToList();
    init_createStringVariations();
    init_isSingleItem();
    Resolver = class {
      constructor() {
        this._defaultBundleIdentifierOptions = {
          connector: "-",
          createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
          extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
        };
        this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
        this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
        this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
        this._assetMap = {};
        this._preferredOrder = [];
        this._parsers = [];
        this._resolverHash = {};
        this._bundles = {};
      }
      setBundleIdentifier(bundleIdentifier) {
        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
        if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
          throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
      }
      prefer(...preferOrders) {
        preferOrders.forEach((prefer) => {
          this._preferredOrder.push(prefer);
          if (!prefer.priority) {
            prefer.priority = Object.keys(prefer.params);
          }
        });
        this._resolverHash = {};
      }
      set basePath(basePath) {
        this._basePath = basePath;
      }
      get basePath() {
        return this._basePath;
      }
      set rootPath(rootPath) {
        this._rootPath = rootPath;
      }
      get rootPath() {
        return this._rootPath;
      }
      get parsers() {
        return this._parsers;
      }
      reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
        this._assetMap = {};
        this._preferredOrder = [];
        this._resolverHash = {};
        this._rootPath = null;
        this._basePath = null;
        this._manifest = null;
        this._bundles = {};
        this._defaultSearchParams = null;
      }
      setDefaultSearchParams(searchParams) {
        if (typeof searchParams === "string") {
          this._defaultSearchParams = searchParams;
        } else {
          const queryValues = searchParams;
          this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
        }
      }
      addManifest(manifest) {
        if (this._manifest) {
          console.warn("[Resolver] Manifest already exists, this will be overwritten");
        }
        this._manifest = manifest;
        manifest.bundles.forEach((bundle) => {
          this.addBundle(bundle.name, bundle.assets);
        });
      }
      addBundle(bundleId, assets) {
        const assetNames = [];
        if (Array.isArray(assets)) {
          assets.forEach((asset) => {
            if (typeof asset.name === "string") {
              const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);
              assetNames.push(bundleAssetId);
              this.add([asset.name, bundleAssetId], asset.srcs, asset.data);
            } else {
              const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));
              bundleIds.forEach((bundleId2) => {
                assetNames.push(bundleId2);
              });
              this.add([...asset.name, ...bundleIds], asset.srcs);
            }
          });
        } else {
          Object.keys(assets).forEach((key) => {
            assetNames.push(this._createBundleAssetId(bundleId, key));
            this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);
          });
        }
        this._bundles[bundleId] = assetNames;
      }
      add(keysIn, assetsIn, data) {
        const keys = convertToList(keysIn);
        keys.forEach((key) => {
          if (this.hasKey(key)) {
            console.warn(`[Resolver] already has key: ${key} overwriting`);
          }
        });
        if (!Array.isArray(assetsIn)) {
          if (typeof assetsIn === "string") {
            assetsIn = createStringVariations(assetsIn);
          } else {
            assetsIn = [assetsIn];
          }
        }
        const assetMap = assetsIn.map((asset) => {
          let formattedAsset = asset;
          if (typeof asset === "string") {
            let parsed = false;
            for (let i = 0; i < this._parsers.length; i++) {
              const parser = this._parsers[i];
              if (parser.test(asset)) {
                formattedAsset = parser.parse(asset);
                parsed = true;
                break;
              }
            }
            if (!parsed) {
              formattedAsset = {
                src: asset
              };
            }
          }
          if (!formattedAsset.format) {
            formattedAsset.format = formattedAsset.src.split(".").pop();
          }
          if (!formattedAsset.alias) {
            formattedAsset.alias = keys;
          }
          if (this._basePath || this._rootPath) {
            formattedAsset.src = lib_exports.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
          }
          formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
          formattedAsset.data = formattedAsset.data ?? data;
          return formattedAsset;
        });
        keys.forEach((key) => {
          this._assetMap[key] = assetMap;
        });
      }
      resolveBundle(bundleIds) {
        const singleAsset = isSingleItem(bundleIds);
        bundleIds = convertToList(bundleIds);
        const out = {};
        bundleIds.forEach((bundleId) => {
          const assetNames = this._bundles[bundleId];
          if (assetNames) {
            const results = this.resolve(assetNames);
            const assets = {};
            for (const key in results) {
              const asset = results[key];
              assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
            }
            out[bundleId] = assets;
          }
        });
        return singleAsset ? out[bundleIds[0]] : out;
      }
      resolveUrl(key) {
        const result = this.resolve(key);
        if (typeof key !== "string") {
          const out = {};
          for (const i in result) {
            out[i] = result[i].src;
          }
          return out;
        }
        return result.src;
      }
      resolve(keys) {
        const singleAsset = isSingleItem(keys);
        keys = convertToList(keys);
        const result = {};
        keys.forEach((key) => {
          if (!this._resolverHash[key]) {
            if (this._assetMap[key]) {
              let assets = this._assetMap[key];
              const preferredOrder = this._getPreferredOrder(assets);
              const bestAsset = assets[0];
              preferredOrder == null ? void 0 : preferredOrder.priority.forEach((priorityKey) => {
                preferredOrder.params[priorityKey].forEach((value) => {
                  const filteredAssets = assets.filter((asset) => {
                    if (asset[priorityKey]) {
                      return asset[priorityKey] === value;
                    }
                    return false;
                  });
                  if (filteredAssets.length) {
                    assets = filteredAssets;
                  }
                });
              });
              this._resolverHash[key] = assets[0] ?? bestAsset;
            } else {
              let src = key;
              if (this._basePath || this._rootPath) {
                src = lib_exports.path.toAbsolute(src, this._basePath, this._rootPath);
              }
              src = this._appendDefaultSearchParams(src);
              this._resolverHash[key] = {
                src
              };
            }
          }
          result[key] = this._resolverHash[key];
        });
        return singleAsset ? result[keys[0]] : result;
      }
      hasKey(key) {
        return !!this._assetMap[key];
      }
      hasBundle(key) {
        return !!this._bundles[key];
      }
      _getPreferredOrder(assets) {
        for (let i = 0; i < assets.length; i++) {
          const asset = assets[0];
          const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
          if (preferred) {
            return preferred;
          }
        }
        return this._preferredOrder[0];
      }
      _appendDefaultSearchParams(url) {
        if (!this._defaultSearchParams)
          return url;
        const paramConnector = /\?/.test(url) ? "&" : "?";
        return `${url}${paramConnector}${this._defaultSearchParams}`;
      }
    };
  }
});

// node_modules/@pixi/assets/lib/Assets.mjs
var AssetsClass, Assets;
var init_Assets = __esm({
  "node_modules/@pixi/assets/lib/Assets.mjs"() {
    init_lib();
    init_BackgroundLoader();
    init_Cache();
    init_Loader();
    init_parsers();
    init_Resolver();
    init_convertToList();
    init_isSingleItem();
    init_loadTextures();
    AssetsClass = class {
      constructor() {
        this._detections = [];
        this._initialized = false;
        this.resolver = new Resolver();
        this.loader = new Loader();
        this.cache = Cache;
        this._backgroundLoader = new BackgroundLoader(this.loader);
        this._backgroundLoader.active = true;
        this.reset();
      }
      async init(options = {}) {
        var _a, _b, _c;
        if (this._initialized) {
          console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
          return;
        }
        this._initialized = true;
        if (options.defaultSearchParams) {
          this.resolver.setDefaultSearchParams(options.defaultSearchParams);
        }
        if (options.basePath) {
          this.resolver.basePath = options.basePath;
        }
        if (options.bundleIdentifier) {
          this.resolver.setBundleIdentifier(options.bundleIdentifier);
        }
        if (options.manifest) {
          let manifest = options.manifest;
          if (typeof manifest === "string") {
            manifest = await this.load(manifest);
          }
          this.resolver.addManifest(manifest);
        }
        const resolutionPref = ((_a = options.texturePreference) == null ? void 0 : _a.resolution) ?? 1;
        const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
        let formats2 = [];
        if ((_b = options.texturePreference) == null ? void 0 : _b.format) {
          const formatPref = (_c = options.texturePreference) == null ? void 0 : _c.format;
          formats2 = typeof formatPref === "string" ? [formatPref] : formatPref;
          for (const detection of this._detections) {
            if (!await detection.test()) {
              formats2 = await detection.remove(formats2);
            }
          }
        } else {
          for (const detection of this._detections) {
            if (await detection.test()) {
              formats2 = await detection.add(formats2);
            }
          }
        }
        this.resolver.prefer({
          params: {
            format: formats2,
            resolution
          }
        });
        if (options.preferences) {
          this.setPreferences(options.preferences);
        }
      }
      add(keysIn, assetsIn, data) {
        this.resolver.add(keysIn, assetsIn, data);
      }
      async load(urls, onProgress) {
        if (!this._initialized) {
          await this.init();
        }
        const singleAsset = isSingleItem(urls);
        const urlArray = convertToList(urls).map((url) => {
          if (typeof url !== "string") {
            this.resolver.add(url.src, url);
            return url.src;
          }
          if (!this.resolver.hasKey(url)) {
            this.resolver.add(url, url);
          }
          return url;
        });
        const resolveResults = this.resolver.resolve(urlArray);
        const out = await this._mapLoadToResolve(resolveResults, onProgress);
        return singleAsset ? out[urlArray[0]] : out;
      }
      addBundle(bundleId, assets) {
        this.resolver.addBundle(bundleId, assets);
      }
      async loadBundle(bundleIds, onProgress) {
        if (!this._initialized) {
          await this.init();
        }
        let singleAsset = false;
        if (typeof bundleIds === "string") {
          singleAsset = true;
          bundleIds = [bundleIds];
        }
        const resolveResults = this.resolver.resolveBundle(bundleIds);
        const out = {};
        const keys = Object.keys(resolveResults);
        let count = 0;
        let total = 0;
        const _onProgress = () => {
          onProgress == null ? void 0 : onProgress(++count / total);
        };
        const promises = keys.map((bundleId) => {
          const resolveResult = resolveResults[bundleId];
          total += Object.keys(resolveResult).length;
          return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
            out[bundleId] = resolveResult2;
          });
        });
        await Promise.all(promises);
        return singleAsset ? out[bundleIds[0]] : out;
      }
      async backgroundLoad(urls) {
        if (!this._initialized) {
          await this.init();
        }
        if (typeof urls === "string") {
          urls = [urls];
        }
        const resolveResults = this.resolver.resolve(urls);
        this._backgroundLoader.add(Object.values(resolveResults));
      }
      async backgroundLoadBundle(bundleIds) {
        if (!this._initialized) {
          await this.init();
        }
        if (typeof bundleIds === "string") {
          bundleIds = [bundleIds];
        }
        const resolveResults = this.resolver.resolveBundle(bundleIds);
        Object.values(resolveResults).forEach((resolveResult) => {
          this._backgroundLoader.add(Object.values(resolveResult));
        });
      }
      reset() {
        this.resolver.reset();
        this.loader.reset();
        this.cache.reset();
        this._initialized = false;
      }
      get(keys) {
        if (typeof keys === "string") {
          return Cache.get(keys);
        }
        const assets = {};
        for (let i = 0; i < keys.length; i++) {
          assets[i] = Cache.get(keys[i]);
        }
        return assets;
      }
      async _mapLoadToResolve(resolveResults, onProgress) {
        const resolveArray = Object.values(resolveResults);
        const resolveKeys = Object.keys(resolveResults);
        this._backgroundLoader.active = false;
        const loadedAssets = await this.loader.load(resolveArray, onProgress);
        this._backgroundLoader.active = true;
        const out = {};
        resolveArray.forEach((resolveResult, i) => {
          const asset = loadedAssets[resolveResult.src];
          const keys = [resolveResult.src];
          if (resolveResult.alias) {
            keys.push(...resolveResult.alias);
          }
          out[resolveKeys[i]] = asset;
          Cache.set(keys, asset);
        });
        return out;
      }
      async unload(urls) {
        if (!this._initialized) {
          await this.init();
        }
        const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
        const resolveResults = this.resolver.resolve(urlArray);
        await this._unloadFromResolved(resolveResults);
      }
      async unloadBundle(bundleIds) {
        if (!this._initialized) {
          await this.init();
        }
        bundleIds = convertToList(bundleIds);
        const resolveResults = this.resolver.resolveBundle(bundleIds);
        const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
        await Promise.all(promises);
      }
      async _unloadFromResolved(resolveResult) {
        const resolveArray = Object.values(resolveResult);
        resolveArray.forEach((resolveResult2) => {
          Cache.remove(resolveResult2.src);
        });
        await this.loader.unload(resolveArray);
      }
      get detections() {
        return this._detections;
      }
      get preferWorkers() {
        return loadTextures.config.preferWorkers;
      }
      set preferWorkers(value) {
        lib_exports.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");
        this.setPreferences({ preferWorkers: value });
      }
      setPreferences(preferences) {
        this.loader.parsers.forEach((parser) => {
          if (!parser.config)
            return;
          Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
            parser.config[key] = preferences[key];
          });
        });
      }
    };
    Assets = new AssetsClass();
    extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
  }
});

// node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs
var cacheTextureArray;
var init_cacheTextureArray = __esm({
  "node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs"() {
    init_lib();
    cacheTextureArray = {
      extension: ExtensionType.CacheParser,
      test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),
      getCacheableAssets: (keys, asset) => {
        const out = {};
        keys.forEach((key) => {
          asset.forEach((item, i) => {
            out[key + (i === 0 ? "" : i + 1)] = item;
          });
        });
        return out;
      }
    };
    extensions.add(cacheTextureArray);
  }
});

// node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs
var detectAvif;
var init_detectAvif = __esm({
  "node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs"() {
    init_lib();
    detectAvif = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 1
      },
      test: async () => {
        if (!globalThis.createImageBitmap)
          return false;
        const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
        const blob = await settings.ADAPTER.fetch(avifData).then((r) => r.blob());
        return createImageBitmap(blob).then(() => true, () => false);
      },
      add: async (formats2) => [...formats2, "avif"],
      remove: async (formats2) => formats2.filter((f) => f !== "avif")
    };
    extensions.add(detectAvif);
  }
});

// node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs
var detectWebp;
var init_detectWebp = __esm({
  "node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs"() {
    init_lib();
    detectWebp = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => {
        if (!globalThis.createImageBitmap)
          return false;
        const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
        const blob = await settings.ADAPTER.fetch(webpData).then((r) => r.blob());
        return createImageBitmap(blob).then(() => true, () => false);
      },
      add: async (formats2) => [...formats2, "webp"],
      remove: async (formats2) => formats2.filter((f) => f !== "webp")
    };
    extensions.add(detectWebp);
  }
});

// node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs
var imageFormats, detectDefaults;
var init_detectDefaults = __esm({
  "node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs"() {
    init_lib();
    imageFormats = ["png", "jpg", "jpeg"];
    detectDefaults = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: -1
      },
      test: () => Promise.resolve(true),
      add: async (formats2) => [...formats2, ...imageFormats],
      remove: async (formats2) => formats2.filter((f) => !imageFormats.includes(f))
    };
    extensions.add(detectDefaults);
  }
});

// node_modules/@pixi/assets/lib/loader/types.mjs
var init_types = __esm({
  "node_modules/@pixi/assets/lib/loader/types.mjs"() {
  }
});

// node_modules/@pixi/assets/lib/loader/index.mjs
var init_loader = __esm({
  "node_modules/@pixi/assets/lib/loader/index.mjs"() {
    init_parsers();
    init_types();
  }
});

// node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs
var resolveTextureUrl;
var init_resolveTextureUrl = __esm({
  "node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs"() {
    init_lib();
    init_loader();
    init_loadTextures();
    resolveTextureUrl = {
      extension: ExtensionType.ResolveParser,
      test: loadTextures.test,
      parse: (value) => {
        var _a;
        return {
          resolution: parseFloat(((_a = settings.RETINA_PREFIX.exec(value)) == null ? void 0 : _a[1]) ?? "1"),
          format: value.split(".").pop(),
          src: value
        };
      }
    };
    extensions.add(resolveTextureUrl);
  }
});

// node_modules/@pixi/assets/lib/AssetExtension.mjs
var assetKeyMap;
var init_AssetExtension = __esm({
  "node_modules/@pixi/assets/lib/AssetExtension.mjs"() {
    init_lib();
    assetKeyMap = {
      loader: ExtensionType.LoadParser,
      resolver: ExtensionType.ResolveParser,
      cache: ExtensionType.CacheParser,
      detection: ExtensionType.DetectionParser
    };
    extensions.handle(ExtensionType.Asset, (extension) => {
      const ref = extension.ref;
      Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));
    }, (extension) => {
      const ref = extension.ref;
      Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
    });
  }
});

// node_modules/@pixi/assets/lib/cache/CacheParser.mjs
var init_CacheParser = __esm({
  "node_modules/@pixi/assets/lib/cache/CacheParser.mjs"() {
  }
});

// node_modules/@pixi/assets/lib/cache/parsers/index.mjs
var init_parsers2 = __esm({
  "node_modules/@pixi/assets/lib/cache/parsers/index.mjs"() {
    init_cacheTextureArray();
  }
});

// node_modules/@pixi/assets/lib/cache/index.mjs
var init_cache = __esm({
  "node_modules/@pixi/assets/lib/cache/index.mjs"() {
    init_Cache();
    init_CacheParser();
    init_parsers2();
  }
});

// node_modules/@pixi/assets/lib/detections/parsers/index.mjs
var init_parsers3 = __esm({
  "node_modules/@pixi/assets/lib/detections/parsers/index.mjs"() {
    init_detectAvif();
    init_detectWebp();
    init_detectDefaults();
  }
});

// node_modules/@pixi/assets/lib/detections/index.mjs
var init_detections = __esm({
  "node_modules/@pixi/assets/lib/detections/index.mjs"() {
    init_parsers3();
  }
});

// node_modules/@pixi/assets/lib/resolver/parsers/index.mjs
var init_parsers4 = __esm({
  "node_modules/@pixi/assets/lib/resolver/parsers/index.mjs"() {
    init_resolveTextureUrl();
  }
});

// node_modules/@pixi/assets/lib/resolver/types.mjs
var init_types2 = __esm({
  "node_modules/@pixi/assets/lib/resolver/types.mjs"() {
  }
});

// node_modules/@pixi/assets/lib/resolver/index.mjs
var init_resolver = __esm({
  "node_modules/@pixi/assets/lib/resolver/index.mjs"() {
    init_parsers4();
    init_types2();
  }
});

// node_modules/@pixi/assets/lib/index.mjs
var init_lib6 = __esm({
  "node_modules/@pixi/assets/lib/index.mjs"() {
    init_AssetExtension();
    init_Assets();
    init_cache();
    init_detections();
    init_loader();
    init_resolver();
    init_utils2();
    init_Cache();
    init_cacheTextureArray();
    init_detectAvif();
    init_detectWebp();
    init_detectDefaults();
    init_LoaderParser();
    init_loadJson();
    init_loadTxt();
    init_loadWebFont();
    init_loadSVG();
    init_loadTextures();
    init_createTexture();
    init_resolveTextureUrl();
    init_checkDataUrl();
    init_checkExtension();
    init_convertToList();
    init_copySearchParams();
    init_createStringVariations();
    init_isSingleItem();
  }
});

// node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs
var validExtensions, loadBitmapFont;
var init_loadBitmapFont = __esm({
  "node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs"() {
    init_lib6();
    init_lib();
    init_BitmapFont();
    init_formats();
    init_TextFormat();
    init_XMLStringFormat();
    validExtensions = [".xml", ".fnt"];
    loadBitmapFont = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal
      },
      name: "loadBitmapFont",
      test(url) {
        return validExtensions.includes(lib_exports.path.extname(url).toLowerCase());
      },
      async testParse(data) {
        return TextFormat.test(data) || XMLStringFormat.test(data);
      },
      async parse(asset, data, loader) {
        const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
        const { src } = data;
        const { page: pages } = fontData;
        const textureUrls = [];
        for (let i = 0; i < pages.length; ++i) {
          const pageFile = pages[i].file;
          let imagePath = lib_exports.path.join(lib_exports.path.dirname(src), pageFile);
          imagePath = copySearchParams(imagePath, src);
          textureUrls.push(imagePath);
        }
        const loadedTextures = await loader.load(textureUrls);
        const textures = textureUrls.map((url) => loadedTextures[url]);
        return BitmapFont.install(fontData, textures, true);
      },
      async load(url, _options) {
        const response = await settings.ADAPTER.fetch(url);
        return response.text();
      },
      unload(bitmapFont) {
        bitmapFont.destroy();
      }
    };
    extensions.add(loadBitmapFont);
  }
});

// node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.mjs
var init_BitmapTextStyle = __esm({
  "node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.mjs"() {
  }
});

// node_modules/@pixi/text-bitmap/lib/index.mjs
var init_lib7 = __esm({
  "node_modules/@pixi/text-bitmap/lib/index.mjs"() {
    init_BitmapFont();
    init_BitmapFontData();
    init_BitmapText();
    init_BitmapTextStyle();
    init_formats();
    init_loadBitmapFont();
    init_TextFormat();
    init_XMLFormat();
    init_XMLStringFormat();
  }
});

// node_modules/@pixi/graphics/lib/const.mjs
var LINE_JOIN, LINE_CAP, curves, GRAPHICS_CURVES;
var init_const2 = __esm({
  "node_modules/@pixi/graphics/lib/const.mjs"() {
    LINE_JOIN = ((LINE_JOIN2) => {
      LINE_JOIN2["MITER"] = "miter";
      LINE_JOIN2["BEVEL"] = "bevel";
      LINE_JOIN2["ROUND"] = "round";
      return LINE_JOIN2;
    })(LINE_JOIN || {});
    LINE_CAP = ((LINE_CAP2) => {
      LINE_CAP2["BUTT"] = "butt";
      LINE_CAP2["ROUND"] = "round";
      LINE_CAP2["SQUARE"] = "square";
      return LINE_CAP2;
    })(LINE_CAP || {});
    curves = {
      adaptive: true,
      maxLength: 10,
      minSegments: 8,
      maxSegments: 2048,
      epsilon: 1e-4,
      _segmentsCount(length, defaultSegments = 20) {
        if (!this.adaptive || !length || isNaN(length)) {
          return defaultSegments;
        }
        let result = Math.ceil(length / this.maxLength);
        if (result < this.minSegments) {
          result = this.minSegments;
        } else if (result > this.maxSegments) {
          result = this.maxSegments;
        }
        return result;
      }
    };
    GRAPHICS_CURVES = curves;
  }
});

// node_modules/@pixi/graphics/lib/GraphicsData.mjs
var GraphicsData;
var init_GraphicsData = __esm({
  "node_modules/@pixi/graphics/lib/GraphicsData.mjs"() {
    GraphicsData = class _GraphicsData {
      constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
        this.points = [];
        this.holes = [];
        this.shape = shape;
        this.lineStyle = lineStyle;
        this.fillStyle = fillStyle;
        this.matrix = matrix;
        this.type = shape.type;
      }
      clone() {
        return new _GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
      }
      destroy() {
        this.shape = null;
        this.holes.length = 0;
        this.holes = null;
        this.points.length = 0;
        this.points = null;
        this.lineStyle = null;
        this.fillStyle = null;
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/utils/buildCircle.mjs
var buildCircle;
var init_buildCircle = __esm({
  "node_modules/@pixi/graphics/lib/utils/buildCircle.mjs"() {
    init_lib();
    buildCircle = {
      build(graphicsData) {
        const points = graphicsData.points;
        let x;
        let y;
        let dx;
        let dy;
        let rx;
        let ry;
        if (graphicsData.type === SHAPES.CIRC) {
          const circle = graphicsData.shape;
          x = circle.x;
          y = circle.y;
          rx = ry = circle.radius;
          dx = dy = 0;
        } else if (graphicsData.type === SHAPES.ELIP) {
          const ellipse = graphicsData.shape;
          x = ellipse.x;
          y = ellipse.y;
          rx = ellipse.width;
          ry = ellipse.height;
          dx = dy = 0;
        } else {
          const roundedRect = graphicsData.shape;
          const halfWidth = roundedRect.width / 2;
          const halfHeight = roundedRect.height / 2;
          x = roundedRect.x + halfWidth;
          y = roundedRect.y + halfHeight;
          rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
          dx = halfWidth - rx;
          dy = halfHeight - ry;
        }
        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
          points.length = 0;
          return;
        }
        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
        const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
        points.length = m;
        if (m === 0) {
          return;
        }
        if (n === 0) {
          points.length = 8;
          points[0] = points[6] = x + dx;
          points[1] = points[3] = y + dy;
          points[2] = points[4] = x - dx;
          points[5] = points[7] = y - dy;
          return;
        }
        let j1 = 0;
        let j2 = n * 4 + (dx ? 2 : 0) + 2;
        let j3 = j2;
        let j4 = m;
        {
          const x0 = dx + rx;
          const y0 = dy;
          const x1 = x + x0;
          const x2 = x - x0;
          const y1 = y + y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j2] = y1;
          points[--j2] = x2;
          if (dy) {
            const y2 = y - y0;
            points[j3++] = x2;
            points[j3++] = y2;
            points[--j4] = y2;
            points[--j4] = x1;
          }
        }
        for (let i = 1; i < n; i++) {
          const a = Math.PI / 2 * (i / n);
          const x0 = dx + Math.cos(a) * rx;
          const y0 = dy + Math.sin(a) * ry;
          const x1 = x + x0;
          const x2 = x - x0;
          const y1 = y + y0;
          const y2 = y - y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j2] = y1;
          points[--j2] = x2;
          points[j3++] = x2;
          points[j3++] = y2;
          points[--j4] = y2;
          points[--j4] = x1;
        }
        {
          const x0 = dx;
          const y0 = dy + ry;
          const x1 = x + x0;
          const x2 = x - x0;
          const y1 = y + y0;
          const y2 = y - y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j4] = y2;
          points[--j4] = x1;
          if (dx) {
            points[j1++] = x2;
            points[j1++] = y1;
            points[--j4] = y2;
            points[--j4] = x2;
          }
        }
      },
      triangulate(graphicsData, graphicsGeometry) {
        const points = graphicsData.points;
        const verts = graphicsGeometry.points;
        const indices2 = graphicsGeometry.indices;
        if (points.length === 0) {
          return;
        }
        let vertPos = verts.length / 2;
        const center = vertPos;
        let x;
        let y;
        if (graphicsData.type !== SHAPES.RREC) {
          const circle = graphicsData.shape;
          x = circle.x;
          y = circle.y;
        } else {
          const roundedRect = graphicsData.shape;
          x = roundedRect.x + roundedRect.width / 2;
          y = roundedRect.y + roundedRect.height / 2;
        }
        const matrix = graphicsData.matrix;
        verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);
        vertPos++;
        verts.push(points[0], points[1]);
        for (let i = 2; i < points.length; i += 2) {
          verts.push(points[i], points[i + 1]);
          indices2.push(vertPos++, center, vertPos);
        }
        indices2.push(center + 1, center, vertPos);
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/utils/buildPoly.mjs
function fixOrientation(points, hole = false) {
  const m = points.length;
  if (m < 6) {
    return;
  }
  let area = 0;
  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
    const x2 = points[i];
    const y2 = points[i + 1];
    area += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area > 0 || hole && area <= 0) {
    const n = m / 2;
    for (let i = n + n % 2; i < m; i += 2) {
      const i1 = m - i - 2;
      const i2 = m - i - 1;
      const i3 = i;
      const i4 = i + 1;
      [points[i1], points[i3]] = [points[i3], points[i1]];
      [points[i2], points[i4]] = [points[i4], points[i2]];
    }
  }
}
var buildPoly;
var init_buildPoly = __esm({
  "node_modules/@pixi/graphics/lib/utils/buildPoly.mjs"() {
    init_lib();
    buildPoly = {
      build(graphicsData) {
        graphicsData.points = graphicsData.shape.points.slice();
      },
      triangulate(graphicsData, graphicsGeometry) {
        let points = graphicsData.points;
        const holes = graphicsData.holes;
        const verts = graphicsGeometry.points;
        const indices2 = graphicsGeometry.indices;
        if (points.length >= 6) {
          fixOrientation(points, false);
          const holeArray = [];
          for (let i = 0; i < holes.length; i++) {
            const hole = holes[i];
            fixOrientation(hole.points, true);
            holeArray.push(points.length / 2);
            points = points.concat(hole.points);
          }
          const triangles = lib_exports.earcut(points, holeArray, 2);
          if (!triangles) {
            return;
          }
          const vertPos = verts.length / 2;
          for (let i = 0; i < triangles.length; i += 3) {
            indices2.push(triangles[i] + vertPos);
            indices2.push(triangles[i + 1] + vertPos);
            indices2.push(triangles[i + 2] + vertPos);
          }
          for (let i = 0; i < points.length; i++) {
            verts.push(points[i]);
          }
        }
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs
var buildRectangle;
var init_buildRectangle = __esm({
  "node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs"() {
    buildRectangle = {
      build(graphicsData) {
        const rectData = graphicsData.shape;
        const x = rectData.x;
        const y = rectData.y;
        const width = rectData.width;
        const height = rectData.height;
        const points = graphicsData.points;
        points.length = 0;
        if (!(width >= 0 && height >= 0)) {
          return;
        }
        points.push(x, y, x + width, y, x + width, y + height, x, y + height);
      },
      triangulate(graphicsData, graphicsGeometry) {
        const points = graphicsData.points;
        const verts = graphicsGeometry.points;
        if (points.length === 0) {
          return;
        }
        const vertPos = verts.length / 2;
        verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs
var buildRoundedRectangle;
var init_buildRoundedRectangle = __esm({
  "node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs"() {
    init_buildCircle();
    buildRoundedRectangle = {
      build(graphicsData) {
        buildCircle.build(graphicsData);
      },
      triangulate(graphicsData, graphicsGeometry) {
        buildCircle.triangulate(graphicsData, graphicsGeometry);
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs
var ArcUtils;
var init_ArcUtils = __esm({
  "node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs"() {
    init_lib();
    init_const2();
    ArcUtils = class {
      static curveTo(x1, y1, x2, y2, radius, points) {
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        const a1 = fromY - y1;
        const b1 = fromX - x1;
        const a2 = y2 - y1;
        const b2 = x2 - x1;
        const mm = Math.abs(a1 * b2 - b1 * a2);
        if (mm < 1e-8 || radius === 0) {
          if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
            points.push(x1, y1);
          }
          return null;
        }
        const dd = a1 * a1 + b1 * b1;
        const cc = a2 * a2 + b2 * b2;
        const tt = a1 * a2 + b1 * b2;
        const k1 = radius * Math.sqrt(dd) / mm;
        const k2 = radius * Math.sqrt(cc) / mm;
        const j1 = k1 * tt / dd;
        const j2 = k2 * tt / cc;
        const cx = k1 * b2 + k2 * b1;
        const cy = k1 * a2 + k2 * a1;
        const px = b1 * (k2 + j1);
        const py = a1 * (k2 + j1);
        const qx = b2 * (k1 + j2);
        const qy = a2 * (k1 + j2);
        const startAngle = Math.atan2(py - cy, px - cx);
        const endAngle = Math.atan2(qy - cy, qx - cx);
        return {
          cx: cx + x1,
          cy: cy + y1,
          radius,
          startAngle,
          endAngle,
          anticlockwise: b1 * a2 > b2 * a1
        };
      }
      static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
        const sweep = endAngle - startAngle;
        const n = curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
        const theta = sweep / (n * 2);
        const theta2 = theta * 2;
        const cTheta = Math.cos(theta);
        const sTheta = Math.sin(theta);
        const segMinus = n - 1;
        const remainder = segMinus % 1 / segMinus;
        for (let i = 0; i <= segMinus; ++i) {
          const real = i + remainder * i;
          const angle = theta + startAngle + theta2 * real;
          const c = Math.cos(angle);
          const s = -Math.sin(angle);
          points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
        }
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/utils/BatchPart.mjs
var BatchPart;
var init_BatchPart = __esm({
  "node_modules/@pixi/graphics/lib/utils/BatchPart.mjs"() {
    BatchPart = class {
      constructor() {
        this.reset();
      }
      begin(style, startIndex, attribStart) {
        this.reset();
        this.style = style;
        this.start = startIndex;
        this.attribStart = attribStart;
      }
      end(endIndex, endAttrib) {
        this.attribSize = endAttrib - this.attribStart;
        this.size = endIndex - this.start;
      }
      reset() {
        this.style = null;
        this.size = 0;
        this.start = 0;
        this.attribStart = 0;
        this.attribSize = 0;
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs
var BezierUtils;
var init_BezierUtils = __esm({
  "node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs"() {
    init_const2();
    BezierUtils = class _BezierUtils {
      static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        const n = 10;
        let result = 0;
        let t = 0;
        let t2 = 0;
        let t3 = 0;
        let nt = 0;
        let nt2 = 0;
        let nt3 = 0;
        let x = 0;
        let y = 0;
        let dx = 0;
        let dy = 0;
        let prevX = fromX;
        let prevY = fromY;
        for (let i = 1; i <= n; ++i) {
          t = i / n;
          t2 = t * t;
          t3 = t2 * t;
          nt = 1 - t;
          nt2 = nt * nt;
          nt3 = nt2 * nt;
          x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
          y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
          dx = prevX - x;
          dy = prevY - y;
          prevX = x;
          prevY = y;
          result += Math.sqrt(dx * dx + dy * dy);
        }
        return result;
      }
      static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        points.length -= 2;
        const n = curves._segmentsCount(_BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
        let dt = 0;
        let dt2 = 0;
        let dt3 = 0;
        let t2 = 0;
        let t3 = 0;
        points.push(fromX, fromY);
        for (let i = 1, j = 0; i <= n; ++i) {
          j = i / n;
          dt = 1 - j;
          dt2 = dt * dt;
          dt3 = dt2 * dt;
          t2 = j * j;
          t3 = t2 * j;
          points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/utils/buildLine.mjs
function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x - nx * innerWeight;
  const iy = y - ny * innerWeight;
  const ox = x + nx * outerWeight;
  const oy = y + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy, eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy, sx, sy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy, cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy, ex, ey);
  } else {
    verts.push(sx, sy, cx, cy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius, cx, cy);
    }
    verts.push(ex, ey, cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  const shape = graphicsData.shape;
  let points = graphicsData.points || shape.points.slice();
  const eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = graphicsData.lineStyle;
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = graphicsGeometry.points;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpx = -(y0 - y1);
  let perpy = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  const ratio = style.alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (let i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (dot >= 0) {
        if (style.join === LINE_JOIN.ROUND) {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pdist <= smallerInsideDiagonalSq;
    let join = style.join;
    if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {
      join = LINE_JOIN.BEVEL;
    }
    if (insideMiterOk) {
      switch (join) {
        case LINE_JOIN.MITER: {
          verts.push(imx, imy, omx, omy);
          break;
        }
        case LINE_JOIN.BEVEL: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          break;
        }
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      switch (join) {
        case LINE_JOIN.MITER: {
          if (clockwise) {
            verts.push(omx, omy, omx, omy);
          } else {
            verts.push(imx, imy, imx, imy);
          }
          indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
          break;
        }
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  const indices2 = graphicsGeometry.indices;
  const eps2 = curves.epsilon * curves.epsilon;
  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices2.push(i, i + 1, i + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  let i = 0;
  const shape = graphicsData.shape;
  const points = graphicsData.points || shape.points;
  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0)
    return;
  const verts = graphicsGeometry.points;
  const indices2 = graphicsGeometry.indices;
  const length = points.length / 2;
  const startIndex = verts.length / 2;
  let currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i = 1; i < length; i++) {
    verts.push(points[i * 2], points[i * 2 + 1]);
    indices2.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices2.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}
var init_buildLine = __esm({
  "node_modules/@pixi/graphics/lib/utils/buildLine.mjs"() {
    init_lib();
    init_const2();
  }
});

// node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs
var QuadraticUtils;
var init_QuadraticUtils = __esm({
  "node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs"() {
    init_const2();
    QuadraticUtils = class _QuadraticUtils {
      static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
        const ax = fromX - 2 * cpX + toX;
        const ay = fromY - 2 * cpY + toY;
        const bx = 2 * cpX - 2 * fromX;
        const by = 2 * cpY - 2 * fromY;
        const a = 4 * (ax * ax + ay * ay);
        const b = 4 * (ax * bx + ay * by);
        const c = bx * bx + by * by;
        const s = 2 * Math.sqrt(a + b + c);
        const a2 = Math.sqrt(a);
        const a32 = 2 * a * a2;
        const c2 = 2 * Math.sqrt(c);
        const ba = b / a2;
        return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);
      }
      static curveTo(cpX, cpY, toX, toY, points) {
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        const n = curves._segmentsCount(_QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
        let xa = 0;
        let ya = 0;
        for (let i = 1; i <= n; ++i) {
          const j = i / n;
          xa = fromX + (cpX - fromX) * j;
          ya = fromY + (cpY - fromY) * j;
          points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
        }
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/utils/index.mjs
var FILL_COMMANDS, BATCH_POOL, DRAW_CALL_POOL;
var init_utils4 = __esm({
  "node_modules/@pixi/graphics/lib/utils/index.mjs"() {
    init_lib();
    init_buildCircle();
    init_buildCircle();
    init_buildPoly();
    init_buildPoly();
    init_buildRectangle();
    init_buildRectangle();
    init_buildRoundedRectangle();
    init_buildRoundedRectangle();
    init_ArcUtils();
    init_BatchPart();
    init_BezierUtils();
    init_buildLine();
    init_QuadraticUtils();
    FILL_COMMANDS = {
      [SHAPES.POLY]: buildPoly,
      [SHAPES.CIRC]: buildCircle,
      [SHAPES.ELIP]: buildCircle,
      [SHAPES.RECT]: buildRectangle,
      [SHAPES.RREC]: buildRoundedRectangle
    };
    BATCH_POOL = [];
    DRAW_CALL_POOL = [];
  }
});

// node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs
var tmpPoint, _GraphicsGeometry, GraphicsGeometry;
var init_GraphicsGeometry = __esm({
  "node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs"() {
    init_lib();
    init_lib2();
    init_GraphicsData();
    init_utils4();
    init_BatchPart();
    init_buildPoly();
    init_buildLine();
    tmpPoint = new Point();
    _GraphicsGeometry = class extends BatchGeometry {
      constructor() {
        super();
        this.closePointEps = 1e-4;
        this.boundsPadding = 0;
        this.uvsFloat32 = null;
        this.indicesUint16 = null;
        this.batchable = false;
        this.points = [];
        this.colors = [];
        this.uvs = [];
        this.indices = [];
        this.textureIds = [];
        this.graphicsData = [];
        this.drawCalls = [];
        this.batchDirty = -1;
        this.batches = [];
        this.dirty = 0;
        this.cacheDirty = -1;
        this.clearDirty = 0;
        this.shapeIndex = 0;
        this._bounds = new Bounds();
        this.boundsDirty = -1;
      }
      get bounds() {
        this.updateBatches();
        if (this.boundsDirty !== this.dirty) {
          this.boundsDirty = this.dirty;
          this.calculateBounds();
        }
        return this._bounds;
      }
      invalidate() {
        this.boundsDirty = -1;
        this.dirty++;
        this.batchDirty++;
        this.shapeIndex = 0;
        this.points.length = 0;
        this.colors.length = 0;
        this.uvs.length = 0;
        this.indices.length = 0;
        this.textureIds.length = 0;
        for (let i = 0; i < this.drawCalls.length; i++) {
          this.drawCalls[i].texArray.clear();
          DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        for (let i = 0; i < this.batches.length; i++) {
          const batchPart = this.batches[i];
          batchPart.reset();
          BATCH_POOL.push(batchPart);
        }
        this.batches.length = 0;
      }
      clear() {
        if (this.graphicsData.length > 0) {
          this.invalidate();
          this.clearDirty++;
          this.graphicsData.length = 0;
        }
        return this;
      }
      drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
        this.graphicsData.push(data);
        this.dirty++;
        return this;
      }
      drawHole(shape, matrix = null) {
        if (!this.graphicsData.length) {
          return null;
        }
        const data = new GraphicsData(shape, null, null, matrix);
        const lastShape = this.graphicsData[this.graphicsData.length - 1];
        data.lineStyle = lastShape.lineStyle;
        lastShape.holes.push(data);
        this.dirty++;
        return this;
      }
      destroy() {
        super.destroy();
        for (let i = 0; i < this.graphicsData.length; ++i) {
          this.graphicsData[i].destroy();
        }
        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this.batches = null;
        this._bounds = null;
      }
      containsPoint(point) {
        const graphicsData = this.graphicsData;
        for (let i = 0; i < graphicsData.length; ++i) {
          const data = graphicsData[i];
          if (!data.fillStyle.visible) {
            continue;
          }
          if (data.shape) {
            if (data.matrix) {
              data.matrix.applyInverse(point, tmpPoint);
            } else {
              tmpPoint.copyFrom(point);
            }
            if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
              let hitHole = false;
              if (data.holes) {
                for (let i2 = 0; i2 < data.holes.length; i2++) {
                  const hole = data.holes[i2];
                  if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                    hitHole = true;
                    break;
                  }
                }
              }
              if (!hitHole) {
                return true;
              }
            }
          }
        }
        return false;
      }
      updateBatches() {
        if (!this.graphicsData.length) {
          this.batchable = true;
          return;
        }
        if (!this.validateBatching()) {
          return;
        }
        this.cacheDirty = this.dirty;
        const uvs = this.uvs;
        const graphicsData = this.graphicsData;
        let batchPart = null;
        let currentStyle = null;
        if (this.batches.length > 0) {
          batchPart = this.batches[this.batches.length - 1];
          currentStyle = batchPart.style;
        }
        for (let i = this.shapeIndex; i < graphicsData.length; i++) {
          this.shapeIndex++;
          const data = graphicsData[i];
          const fillStyle = data.fillStyle;
          const lineStyle = data.lineStyle;
          const command = FILL_COMMANDS[data.type];
          command.build(data);
          if (data.matrix) {
            this.transformPoints(data.points, data.matrix);
          }
          if (fillStyle.visible || lineStyle.visible) {
            this.processHoles(data.holes);
          }
          for (let j = 0; j < 2; j++) {
            const style = j === 0 ? fillStyle : lineStyle;
            if (!style.visible)
              continue;
            const nextTexture = style.texture.baseTexture;
            const index2 = this.indices.length;
            const attribIndex = this.points.length / 2;
            nextTexture.wrapMode = WRAP_MODES.REPEAT;
            if (j === 0) {
              this.processFill(data);
            } else {
              this.processLine(data);
            }
            const size = this.points.length / 2 - attribIndex;
            if (size === 0)
              continue;
            if (batchPart && !this._compareStyles(currentStyle, style)) {
              batchPart.end(index2, attribIndex);
              batchPart = null;
            }
            if (!batchPart) {
              batchPart = BATCH_POOL.pop() || new BatchPart();
              batchPart.begin(style, index2, attribIndex);
              this.batches.push(batchPart);
              currentStyle = style;
            }
            this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
          }
        }
        const index = this.indices.length;
        const attrib = this.points.length / 2;
        if (batchPart) {
          batchPart.end(index, attrib);
        }
        if (this.batches.length === 0) {
          this.batchable = true;
          return;
        }
        const need32 = attrib > 65535;
        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
          this.indicesUint16.set(this.indices);
        } else {
          this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
        }
        this.batchable = this.isBatchable();
        if (this.batchable) {
          this.packBatches();
        } else {
          this.buildDrawCalls();
        }
      }
      _compareStyles(styleA, styleB) {
        if (!styleA || !styleB) {
          return false;
        }
        if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
          return false;
        }
        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
          return false;
        }
        if (!!styleA.native !== !!styleB.native) {
          return false;
        }
        return true;
      }
      validateBatching() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
          return false;
        }
        for (let i = 0, l = this.graphicsData.length; i < l; i++) {
          const data = this.graphicsData[i];
          const fill = data.fillStyle;
          const line = data.lineStyle;
          if (fill && !fill.texture.baseTexture.valid)
            return false;
          if (line && !line.texture.baseTexture.valid)
            return false;
        }
        return true;
      }
      packBatches() {
        this.batchDirty++;
        this.uvsFloat32 = new Float32Array(this.uvs);
        const batches = this.batches;
        for (let i = 0, l = batches.length; i < l; i++) {
          const batch = batches[i];
          for (let j = 0; j < batch.size; j++) {
            const index = batch.start + j;
            this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
          }
        }
      }
      isBatchable() {
        if (this.points.length > 65535 * 2) {
          return false;
        }
        const batches = this.batches;
        for (let i = 0; i < batches.length; i++) {
          if (batches[i].style.native) {
            return false;
          }
        }
        return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;
      }
      buildDrawCalls() {
        let TICK = ++BaseTexture._globalBatch;
        for (let i = 0; i < this.drawCalls.length; i++) {
          this.drawCalls[i].texArray.clear();
          DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        const colors = this.colors;
        const textureIds = this.textureIds;
        let currentGroup = DRAW_CALL_POOL.pop();
        if (!currentGroup) {
          currentGroup = new BatchDrawCall();
          currentGroup.texArray = new BatchTextureArray();
        }
        currentGroup.texArray.count = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = DRAW_MODES.TRIANGLES;
        let textureCount = 0;
        let currentTexture = null;
        let textureId = 0;
        let native = false;
        let drawMode = DRAW_MODES.TRIANGLES;
        let index = 0;
        this.drawCalls.push(currentGroup);
        for (let i = 0; i < this.batches.length; i++) {
          const data = this.batches[i];
          const maxTextures = 8;
          const style = data.style;
          const nextTexture = style.texture.baseTexture;
          if (native !== !!style.native) {
            native = !!style.native;
            drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
            currentTexture = null;
            textureCount = maxTextures;
            TICK++;
          }
          if (currentTexture !== nextTexture) {
            currentTexture = nextTexture;
            if (nextTexture._batchEnabled !== TICK) {
              if (textureCount === maxTextures) {
                TICK++;
                textureCount = 0;
                if (currentGroup.size > 0) {
                  currentGroup = DRAW_CALL_POOL.pop();
                  if (!currentGroup) {
                    currentGroup = new BatchDrawCall();
                    currentGroup.texArray = new BatchTextureArray();
                  }
                  this.drawCalls.push(currentGroup);
                }
                currentGroup.start = index;
                currentGroup.size = 0;
                currentGroup.texArray.count = 0;
                currentGroup.type = drawMode;
              }
              nextTexture.touched = 1;
              nextTexture._batchEnabled = TICK;
              nextTexture._batchLocation = textureCount;
              nextTexture.wrapMode = WRAP_MODES.REPEAT;
              currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
              textureCount++;
            }
          }
          currentGroup.size += data.size;
          index += data.size;
          textureId = nextTexture._batchLocation;
          this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
          this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
        }
        BaseTexture._globalBatch = TICK;
        this.packAttributes();
      }
      packAttributes() {
        const verts = this.points;
        const uvs = this.uvs;
        const colors = this.colors;
        const textureIds = this.textureIds;
        const glPoints = new ArrayBuffer(verts.length * 3 * 4);
        const f32 = new Float32Array(glPoints);
        const u32 = new Uint32Array(glPoints);
        let p = 0;
        for (let i = 0; i < verts.length / 2; i++) {
          f32[p++] = verts[i * 2];
          f32[p++] = verts[i * 2 + 1];
          f32[p++] = uvs[i * 2];
          f32[p++] = uvs[i * 2 + 1];
          u32[p++] = colors[i];
          f32[p++] = textureIds[i];
        }
        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
      }
      processFill(data) {
        if (data.holes.length) {
          buildPoly.triangulate(data, this);
        } else {
          const command = FILL_COMMANDS[data.type];
          command.triangulate(data, this);
        }
      }
      processLine(data) {
        buildLine(data, this);
        for (let i = 0; i < data.holes.length; i++) {
          buildLine(data.holes[i], this);
        }
      }
      processHoles(holes) {
        for (let i = 0; i < holes.length; i++) {
          const hole = holes[i];
          const command = FILL_COMMANDS[hole.type];
          command.build(hole);
          if (hole.matrix) {
            this.transformPoints(hole.points, hole.matrix);
          }
        }
      }
      calculateBounds() {
        const bounds = this._bounds;
        bounds.clear();
        bounds.addVertexData(this.points, 0, this.points.length);
        bounds.pad(this.boundsPadding, this.boundsPadding);
      }
      transformPoints(points, matrix) {
        for (let i = 0; i < points.length / 2; i++) {
          const x = points[i * 2];
          const y = points[i * 2 + 1];
          points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;
          points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
        }
      }
      addColors(colors, color, alpha, size, offset = 0) {
        const bgr = Color.shared.setValue(color).toLittleEndianNumber();
        const result = Color.shared.setValue(bgr).toPremultiplied(alpha);
        colors.length = Math.max(colors.length, offset + size);
        for (let i = 0; i < size; i++) {
          colors[offset + i] = result;
        }
      }
      addTextureIds(textureIds, id, size, offset = 0) {
        textureIds.length = Math.max(textureIds.length, offset + size);
        for (let i = 0; i < size; i++) {
          textureIds[offset + i] = id;
        }
      }
      addUvs(verts, uvs, texture, start, size, matrix = null) {
        let index = 0;
        const uvsStart = uvs.length;
        const frame = texture.frame;
        while (index < size) {
          let x = verts[(start + index) * 2];
          let y = verts[(start + index) * 2 + 1];
          if (matrix) {
            const nx = matrix.a * x + matrix.c * y + matrix.tx;
            y = matrix.b * x + matrix.d * y + matrix.ty;
            x = nx;
          }
          index++;
          uvs.push(x / frame.width, y / frame.height);
        }
        const baseTexture = texture.baseTexture;
        if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
          this.adjustUvs(uvs, texture, uvsStart, size);
        }
      }
      adjustUvs(uvs, texture, start, size) {
        const baseTexture = texture.baseTexture;
        const eps = 1e-6;
        const finish = start + size * 2;
        const frame = texture.frame;
        const scaleX = frame.width / baseTexture.width;
        const scaleY = frame.height / baseTexture.height;
        let offsetX = frame.x / frame.width;
        let offsetY = frame.y / frame.height;
        let minX = Math.floor(uvs[start] + eps);
        let minY = Math.floor(uvs[start + 1] + eps);
        for (let i = start + 2; i < finish; i += 2) {
          minX = Math.min(minX, Math.floor(uvs[i] + eps));
          minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
        }
        offsetX -= minX;
        offsetY -= minY;
        for (let i = start; i < finish; i += 2) {
          uvs[i] = (uvs[i] + offsetX) * scaleX;
          uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
        }
      }
    };
    GraphicsGeometry = _GraphicsGeometry;
    GraphicsGeometry.BATCHABLE_SIZE = 100;
  }
});

// node_modules/@pixi/graphics/lib/styles/FillStyle.mjs
var FillStyle;
var init_FillStyle = __esm({
  "node_modules/@pixi/graphics/lib/styles/FillStyle.mjs"() {
    init_lib();
    FillStyle = class _FillStyle {
      constructor() {
        this.color = 16777215;
        this.alpha = 1;
        this.texture = Texture.WHITE;
        this.matrix = null;
        this.visible = false;
        this.reset();
      }
      clone() {
        const obj = new _FillStyle();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        return obj;
      }
      reset() {
        this.color = 16777215;
        this.alpha = 1;
        this.texture = Texture.WHITE;
        this.matrix = null;
        this.visible = false;
      }
      destroy() {
        this.texture = null;
        this.matrix = null;
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/styles/LineStyle.mjs
var LineStyle;
var init_LineStyle = __esm({
  "node_modules/@pixi/graphics/lib/styles/LineStyle.mjs"() {
    init_const2();
    init_FillStyle();
    LineStyle = class _LineStyle extends FillStyle {
      constructor() {
        super(...arguments);
        this.width = 0;
        this.alignment = 0.5;
        this.native = false;
        this.cap = LINE_CAP.BUTT;
        this.join = LINE_JOIN.MITER;
        this.miterLimit = 10;
      }
      clone() {
        const obj = new _LineStyle();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        obj.width = this.width;
        obj.alignment = this.alignment;
        obj.native = this.native;
        obj.cap = this.cap;
        obj.join = this.join;
        obj.miterLimit = this.miterLimit;
        return obj;
      }
      reset() {
        super.reset();
        this.color = 0;
        this.alignment = 0.5;
        this.width = 0;
        this.native = false;
      }
    };
  }
});

// node_modules/@pixi/graphics/lib/Graphics.mjs
var DEFAULT_SHADERS, _Graphics, Graphics;
var init_Graphics = __esm({
  "node_modules/@pixi/graphics/lib/Graphics.mjs"() {
    init_lib();
    init_lib2();
    init_const2();
    init_GraphicsGeometry();
    init_FillStyle();
    init_LineStyle();
    init_utils4();
    init_QuadraticUtils();
    init_BezierUtils();
    init_ArcUtils();
    DEFAULT_SHADERS = {};
    _Graphics = class extends Container {
      constructor(geometry = null) {
        super();
        this.shader = null;
        this.pluginName = "batch";
        this.currentPath = null;
        this.batches = [];
        this.batchTint = -1;
        this.batchDirty = -1;
        this.vertexData = null;
        this._fillStyle = new FillStyle();
        this._lineStyle = new LineStyle();
        this._matrix = null;
        this._holeMode = false;
        this.state = State.for2d();
        this._geometry = geometry || new GraphicsGeometry();
        this._geometry.refCount++;
        this._transformID = -1;
        this._tintColor = new Color(16777215);
        this.blendMode = BLEND_MODES.NORMAL;
      }
      get geometry() {
        return this._geometry;
      }
      clone() {
        this.finishPoly();
        return new _Graphics(this._geometry);
      }
      set blendMode(value) {
        this.state.blendMode = value;
      }
      get blendMode() {
        return this.state.blendMode;
      }
      get tint() {
        return this._tintColor.value;
      }
      set tint(value) {
        this._tintColor.setValue(value);
      }
      get fill() {
        return this._fillStyle;
      }
      get line() {
        return this._lineStyle;
      }
      lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = false) {
        if (typeof options === "number") {
          options = { width: options, color, alpha, alignment, native };
        }
        return this.lineTextureStyle(options);
      }
      lineTextureStyle(options) {
        const defaultLineStyleOptions = {
          width: 0,
          texture: Texture.WHITE,
          color: (options == null ? void 0 : options.texture) ? 16777215 : 0,
          matrix: null,
          alignment: 0.5,
          native: false,
          cap: LINE_CAP.BUTT,
          join: LINE_JOIN.MITER,
          miterLimit: 10
        };
        options = Object.assign(defaultLineStyleOptions, options);
        this.normalizeColor(options);
        if (this.currentPath) {
          this.startPoly();
        }
        const visible = options.width > 0 && options.alpha > 0;
        if (!visible) {
          this._lineStyle.reset();
        } else {
          if (options.matrix) {
            options.matrix = options.matrix.clone();
            options.matrix.invert();
          }
          Object.assign(this._lineStyle, { visible }, options);
        }
        return this;
      }
      startPoly() {
        if (this.currentPath) {
          const points = this.currentPath.points;
          const len = this.currentPath.points.length;
          if (len > 2) {
            this.drawShape(this.currentPath);
            this.currentPath = new Polygon();
            this.currentPath.closeStroke = false;
            this.currentPath.points.push(points[len - 2], points[len - 1]);
          }
        } else {
          this.currentPath = new Polygon();
          this.currentPath.closeStroke = false;
        }
      }
      finishPoly() {
        if (this.currentPath) {
          if (this.currentPath.points.length > 2) {
            this.drawShape(this.currentPath);
            this.currentPath = null;
          } else {
            this.currentPath.points.length = 0;
          }
        }
      }
      moveTo(x, y) {
        this.startPoly();
        this.currentPath.points[0] = x;
        this.currentPath.points[1] = y;
        return this;
      }
      lineTo(x, y) {
        if (!this.currentPath) {
          this.moveTo(0, 0);
        }
        const points = this.currentPath.points;
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        if (fromX !== x || fromY !== y) {
          points.push(x, y);
        }
        return this;
      }
      _initCurve(x = 0, y = 0) {
        if (this.currentPath) {
          if (this.currentPath.points.length === 0) {
            this.currentPath.points = [x, y];
          }
        } else {
          this.moveTo(x, y);
        }
      }
      quadraticCurveTo(cpX, cpY, toX, toY) {
        this._initCurve();
        const points = this.currentPath.points;
        if (points.length === 0) {
          this.moveTo(0, 0);
        }
        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
        return this;
      }
      bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._initCurve();
        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
        return this;
      }
      arcTo(x1, y1, x2, y2, radius) {
        this._initCurve(x1, y1);
        const points = this.currentPath.points;
        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
        if (result) {
          const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
          this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
        }
        return this;
      }
      arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
        if (startAngle === endAngle) {
          return this;
        }
        if (!anticlockwise && endAngle <= startAngle) {
          endAngle += PI_2;
        } else if (anticlockwise && startAngle <= endAngle) {
          startAngle += PI_2;
        }
        const sweep = endAngle - startAngle;
        if (sweep === 0) {
          return this;
        }
        const startX = cx + Math.cos(startAngle) * radius;
        const startY = cy + Math.sin(startAngle) * radius;
        const eps = this._geometry.closePointEps;
        let points = this.currentPath ? this.currentPath.points : null;
        if (points) {
          const xDiff = Math.abs(points[points.length - 2] - startX);
          const yDiff = Math.abs(points[points.length - 1] - startY);
          if (xDiff < eps && yDiff < eps) {
          } else {
            points.push(startX, startY);
          }
        } else {
          this.moveTo(startX, startY);
          points = this.currentPath.points;
        }
        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
        return this;
      }
      beginFill(color = 0, alpha) {
        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
      }
      normalizeColor(options) {
        const temp = Color.shared.setValue(options.color ?? 0);
        options.color = temp.toNumber();
        options.alpha ?? (options.alpha = temp.alpha);
      }
      beginTextureFill(options) {
        const defaultOptions = {
          texture: Texture.WHITE,
          color: 16777215,
          matrix: null
        };
        options = Object.assign(defaultOptions, options);
        this.normalizeColor(options);
        if (this.currentPath) {
          this.startPoly();
        }
        const visible = options.alpha > 0;
        if (!visible) {
          this._fillStyle.reset();
        } else {
          if (options.matrix) {
            options.matrix = options.matrix.clone();
            options.matrix.invert();
          }
          Object.assign(this._fillStyle, { visible }, options);
        }
        return this;
      }
      endFill() {
        this.finishPoly();
        this._fillStyle.reset();
        return this;
      }
      drawRect(x, y, width, height) {
        return this.drawShape(new Rectangle(x, y, width, height));
      }
      drawRoundedRect(x, y, width, height, radius) {
        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));
      }
      drawCircle(x, y, radius) {
        return this.drawShape(new Circle(x, y, radius));
      }
      drawEllipse(x, y, width, height) {
        return this.drawShape(new Ellipse(x, y, width, height));
      }
      drawPolygon(...path) {
        let points;
        let closeStroke = true;
        const poly = path[0];
        if (poly.points) {
          closeStroke = poly.closeStroke;
          points = poly.points;
        } else if (Array.isArray(path[0])) {
          points = path[0];
        } else {
          points = path;
        }
        const shape = new Polygon(points);
        shape.closeStroke = closeStroke;
        this.drawShape(shape);
        return this;
      }
      drawShape(shape) {
        if (!this._holeMode) {
          this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
        } else {
          this._geometry.drawHole(shape, this._matrix);
        }
        return this;
      }
      clear() {
        this._geometry.clear();
        this._lineStyle.reset();
        this._fillStyle.reset();
        this._boundsID++;
        this._matrix = null;
        this._holeMode = false;
        this.currentPath = null;
        return this;
      }
      isFastRect() {
        const data = this._geometry.graphicsData;
        return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
      }
      _render(renderer) {
        this.finishPoly();
        const geometry = this._geometry;
        geometry.updateBatches();
        if (geometry.batchable) {
          if (this.batchDirty !== geometry.batchDirty) {
            this._populateBatches();
          }
          this._renderBatched(renderer);
        } else {
          renderer.batch.flush();
          this._renderDirect(renderer);
        }
      }
      _populateBatches() {
        const geometry = this._geometry;
        const blendMode = this.blendMode;
        const len = geometry.batches.length;
        this.batchTint = -1;
        this._transformID = -1;
        this.batchDirty = geometry.batchDirty;
        this.batches.length = len;
        this.vertexData = new Float32Array(geometry.points);
        for (let i = 0; i < len; i++) {
          const gI = geometry.batches[i];
          const color = gI.style.color;
          const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
          const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
          const indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
          const batch = {
            vertexData,
            blendMode,
            indices: indices2,
            uvs,
            _batchRGB: Color.shared.setValue(color).toRgbArray(),
            _tintRGB: color,
            _texture: gI.style.texture,
            alpha: gI.style.alpha,
            worldAlpha: 1
          };
          this.batches[i] = batch;
        }
      }
      _renderBatched(renderer) {
        if (!this.batches.length) {
          return;
        }
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        this.calculateVertices();
        this.calculateTints();
        for (let i = 0, l = this.batches.length; i < l; i++) {
          const batch = this.batches[i];
          batch.worldAlpha = this.worldAlpha * batch.alpha;
          renderer.plugins[this.pluginName].render(batch);
        }
      }
      _renderDirect(renderer) {
        const shader = this._resolveDirectShader(renderer);
        const geometry = this._geometry;
        const worldAlpha = this.worldAlpha;
        const uniforms = shader.uniforms;
        const drawCalls = geometry.drawCalls;
        uniforms.translationMatrix = this.transform.worldTransform;
        Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);
        renderer.shader.bind(shader);
        renderer.geometry.bind(geometry, shader);
        renderer.state.set(this.state);
        for (let i = 0, l = drawCalls.length; i < l; i++) {
          this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
        }
      }
      _renderDrawCallDirect(renderer, drawCall) {
        const { texArray, type, size, start } = drawCall;
        const groupTextureCount = texArray.count;
        for (let j = 0; j < groupTextureCount; j++) {
          renderer.texture.bind(texArray.elements[j], j);
        }
        renderer.geometry.draw(type, size, start);
      }
      _resolveDirectShader(renderer) {
        let shader = this.shader;
        const pluginName = this.pluginName;
        if (!shader) {
          if (!DEFAULT_SHADERS[pluginName]) {
            const { maxTextures } = renderer.plugins[pluginName];
            const sampleValues = new Int32Array(maxTextures);
            for (let i = 0; i < maxTextures; i++) {
              sampleValues[i] = i;
            }
            const uniforms = {
              tint: new Float32Array([1, 1, 1, 1]),
              translationMatrix: new Matrix(),
              default: UniformGroup.from({ uSamplers: sampleValues }, true)
            };
            const program = renderer.plugins[pluginName]._shader.program;
            DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
          }
          shader = DEFAULT_SHADERS[pluginName];
        }
        return shader;
      }
      _calculateBounds() {
        this.finishPoly();
        const geometry = this._geometry;
        if (!geometry.graphicsData.length) {
          return;
        }
        const { minX, minY, maxX, maxY } = geometry.bounds;
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
      }
      containsPoint(point) {
        this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);
        return this._geometry.containsPoint(_Graphics._TEMP_POINT);
      }
      calculateTints() {
        if (this.batchTint !== this.tint) {
          this.batchTint = this._tintColor.toNumber();
          for (let i = 0; i < this.batches.length; i++) {
            const batch = this.batches[i];
            batch._tintRGB = Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
          }
        }
      }
      calculateVertices() {
        const wtID = this.transform._worldID;
        if (this._transformID === wtID) {
          return;
        }
        this._transformID = wtID;
        const wt = this.transform.worldTransform;
        const a = wt.a;
        const b = wt.b;
        const c = wt.c;
        const d = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const data = this._geometry.points;
        const vertexData = this.vertexData;
        let count = 0;
        for (let i = 0; i < data.length; i += 2) {
          const x = data[i];
          const y = data[i + 1];
          vertexData[count++] = a * x + c * y + tx;
          vertexData[count++] = d * y + b * x + ty;
        }
      }
      closePath() {
        const currentPath = this.currentPath;
        if (currentPath) {
          currentPath.closeStroke = true;
          this.finishPoly();
        }
        return this;
      }
      setMatrix(matrix) {
        this._matrix = matrix;
        return this;
      }
      beginHole() {
        this.finishPoly();
        this._holeMode = true;
        return this;
      }
      endHole() {
        this.finishPoly();
        this._holeMode = false;
        return this;
      }
      destroy(options) {
        this._geometry.refCount--;
        if (this._geometry.refCount === 0) {
          this._geometry.dispose();
        }
        this._matrix = null;
        this.currentPath = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this._fillStyle = null;
        this._geometry = null;
        this.shader = null;
        this.vertexData = null;
        this.batches.length = 0;
        this.batches = null;
        super.destroy(options);
      }
    };
    Graphics = _Graphics;
    Graphics.curves = curves;
    Graphics._TEMP_POINT = new Point();
  }
});

// node_modules/@pixi/graphics/lib/index.mjs
var graphicsUtils;
var init_lib8 = __esm({
  "node_modules/@pixi/graphics/lib/index.mjs"() {
    init_utils4();
    init_const2();
    init_Graphics();
    init_GraphicsData();
    init_GraphicsGeometry();
    init_FillStyle();
    init_LineStyle();
    init_buildPoly();
    init_buildCircle();
    init_buildRectangle();
    init_buildRoundedRectangle();
    init_buildLine();
    init_ArcUtils();
    init_BezierUtils();
    init_QuadraticUtils();
    init_BatchPart();
    graphicsUtils = {
      buildPoly,
      buildCircle,
      buildRectangle,
      buildRoundedRectangle,
      buildLine,
      ArcUtils,
      BezierUtils,
      QuadraticUtils,
      BatchPart,
      FILL_COMMANDS,
      BATCH_POOL,
      DRAW_CALL_POOL
    };
  }
});

// node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs
var PlaneGeometry;
var init_PlaneGeometry = __esm({
  "node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs"() {
    init_lib5();
    PlaneGeometry = class extends MeshGeometry {
      constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
        super();
        this.segWidth = segWidth;
        this.segHeight = segHeight;
        this.width = width;
        this.height = height;
        this.build();
      }
      build() {
        const total = this.segWidth * this.segHeight;
        const verts = [];
        const uvs = [];
        const indices2 = [];
        const segmentsX = this.segWidth - 1;
        const segmentsY = this.segHeight - 1;
        const sizeX = this.width / segmentsX;
        const sizeY = this.height / segmentsY;
        for (let i = 0; i < total; i++) {
          const x = i % this.segWidth;
          const y = i / this.segWidth | 0;
          verts.push(x * sizeX, y * sizeY);
          uvs.push(x / segmentsX, y / segmentsY);
        }
        const totalSub = segmentsX * segmentsY;
        for (let i = 0; i < totalSub; i++) {
          const xpos = i % segmentsX;
          const ypos = i / segmentsX | 0;
          const value = ypos * this.segWidth + xpos;
          const value2 = ypos * this.segWidth + xpos + 1;
          const value3 = (ypos + 1) * this.segWidth + xpos;
          const value4 = (ypos + 1) * this.segWidth + xpos + 1;
          indices2.push(value, value2, value3, value2, value4, value3);
        }
        this.buffers[0].data = new Float32Array(verts);
        this.buffers[1].data = new Float32Array(uvs);
        this.indexBuffer.data = new Uint16Array(indices2);
        this.buffers[0].update();
        this.buffers[1].update();
        this.indexBuffer.update();
      }
    };
  }
});

// node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs
var RopeGeometry;
var init_RopeGeometry = __esm({
  "node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs"() {
    init_lib5();
    RopeGeometry = class extends MeshGeometry {
      constructor(width = 200, points, textureScale = 0) {
        super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
        this.points = points;
        this._width = width;
        this.textureScale = textureScale;
        this.build();
      }
      get width() {
        return this._width;
      }
      build() {
        const points = this.points;
        if (!points)
          return;
        const vertexBuffer = this.getBuffer("aVertexPosition");
        const uvBuffer = this.getBuffer("aTextureCoord");
        const indexBuffer = this.getIndex();
        if (points.length < 1) {
          return;
        }
        if (vertexBuffer.data.length / 4 !== points.length) {
          vertexBuffer.data = new Float32Array(points.length * 4);
          uvBuffer.data = new Float32Array(points.length * 4);
          indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        const uvs = uvBuffer.data;
        const indices2 = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        let amount = 0;
        let prev = points[0];
        const textureWidth = this._width * this.textureScale;
        const total = points.length;
        for (let i = 0; i < total; i++) {
          const index = i * 4;
          if (this.textureScale > 0) {
            const dx = prev.x - points[i].x;
            const dy = prev.y - points[i].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            prev = points[i];
            amount += distance / textureWidth;
          } else {
            amount = i / (total - 1);
          }
          uvs[index] = amount;
          uvs[index + 1] = 0;
          uvs[index + 2] = amount;
          uvs[index + 3] = 1;
        }
        let indexCount = 0;
        for (let i = 0; i < total - 1; i++) {
          const index = i * 2;
          indices2[indexCount++] = index;
          indices2[indexCount++] = index + 1;
          indices2[indexCount++] = index + 2;
          indices2[indexCount++] = index + 2;
          indices2[indexCount++] = index + 1;
          indices2[indexCount++] = index + 3;
        }
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
      }
      updateVertices() {
        const points = this.points;
        if (points.length < 1) {
          return;
        }
        let lastPoint = points[0];
        let nextPoint;
        let perpX = 0;
        let perpY = 0;
        const vertices = this.buffers[0].data;
        const total = points.length;
        const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        for (let i = 0; i < total; i++) {
          const point = points[i];
          const index = i * 4;
          if (i < points.length - 1) {
            nextPoint = points[i + 1];
          } else {
            nextPoint = point;
          }
          perpY = -(nextPoint.x - lastPoint.x);
          perpX = nextPoint.y - lastPoint.y;
          let ratio = (1 - i / (total - 1)) * 10;
          if (ratio > 1) {
            ratio = 1;
          }
          const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
          if (perpLength < 1e-6) {
            perpX = 0;
            perpY = 0;
          } else {
            perpX /= perpLength;
            perpY /= perpLength;
            perpX *= halfWidth;
            perpY *= halfWidth;
          }
          vertices[index] = point.x + perpX;
          vertices[index + 1] = point.y + perpY;
          vertices[index + 2] = point.x - perpX;
          vertices[index + 3] = point.y - perpY;
          lastPoint = point;
        }
        this.buffers[0].update();
      }
      update() {
        if (this.textureScale > 0) {
          this.build();
        } else {
          this.updateVertices();
        }
      }
    };
  }
});

// node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs
var SimplePlane;
var init_SimplePlane = __esm({
  "node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs"() {
    init_lib();
    init_lib5();
    init_PlaneGeometry();
    SimplePlane = class extends Mesh {
      constructor(texture, verticesX, verticesY) {
        const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
        const meshMaterial = new MeshMaterial(Texture.WHITE);
        super(planeGeometry, meshMaterial);
        this.texture = texture;
        this.autoResize = true;
      }
      textureUpdated() {
        this._textureID = this.shader.texture._updateID;
        const geometry = this.geometry;
        const { width, height } = this.shader.texture;
        if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
          geometry.width = this.shader.texture.width;
          geometry.height = this.shader.texture.height;
          geometry.build();
        }
      }
      set texture(value) {
        if (this.shader.texture === value) {
          return;
        }
        this.shader.texture = value;
        this._textureID = -1;
        if (value.baseTexture.valid) {
          this.textureUpdated();
        } else {
          value.once("update", this.textureUpdated, this);
        }
      }
      get texture() {
        return this.shader.texture;
      }
      _render(renderer) {
        if (this._textureID !== this.shader.texture._updateID) {
          this.textureUpdated();
        }
        super._render(renderer);
      }
      destroy(options) {
        this.shader.texture.off("update", this.textureUpdated, this);
        super.destroy(options);
      }
    };
  }
});

// node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs
var DEFAULT_BORDER_SIZE, NineSlicePlane;
var init_NineSlicePlane = __esm({
  "node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs"() {
    init_lib();
    init_SimplePlane();
    DEFAULT_BORDER_SIZE = 10;
    NineSlicePlane = class extends SimplePlane {
      constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
        var _a, _b, _c, _d;
        super(Texture.WHITE, 4, 4);
        this._origWidth = texture.orig.width;
        this._origHeight = texture.orig.height;
        this._width = this._origWidth;
        this._height = this._origHeight;
        this._leftWidth = leftWidth ?? ((_a = texture.defaultBorders) == null ? void 0 : _a.left) ?? DEFAULT_BORDER_SIZE;
        this._rightWidth = rightWidth ?? ((_b = texture.defaultBorders) == null ? void 0 : _b.right) ?? DEFAULT_BORDER_SIZE;
        this._topHeight = topHeight ?? ((_c = texture.defaultBorders) == null ? void 0 : _c.top) ?? DEFAULT_BORDER_SIZE;
        this._bottomHeight = bottomHeight ?? ((_d = texture.defaultBorders) == null ? void 0 : _d.bottom) ?? DEFAULT_BORDER_SIZE;
        this.texture = texture;
      }
      textureUpdated() {
        this._textureID = this.shader.texture._updateID;
        this._refresh();
      }
      get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data;
      }
      set vertices(value) {
        this.geometry.getBuffer("aVertexPosition").data = value;
      }
      updateHorizontalVertices() {
        const vertices = this.vertices;
        const scale = this._getMinScale();
        vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
        vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
      }
      updateVerticalVertices() {
        const vertices = this.vertices;
        const scale = this._getMinScale();
        vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
        vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
      }
      _getMinScale() {
        const w = this._leftWidth + this._rightWidth;
        const scaleW = this._width > w ? 1 : this._width / w;
        const h = this._topHeight + this._bottomHeight;
        const scaleH = this._height > h ? 1 : this._height / h;
        const scale = Math.min(scaleW, scaleH);
        return scale;
      }
      get width() {
        return this._width;
      }
      set width(value) {
        this._width = value;
        this._refresh();
      }
      get height() {
        return this._height;
      }
      set height(value) {
        this._height = value;
        this._refresh();
      }
      get leftWidth() {
        return this._leftWidth;
      }
      set leftWidth(value) {
        this._leftWidth = value;
        this._refresh();
      }
      get rightWidth() {
        return this._rightWidth;
      }
      set rightWidth(value) {
        this._rightWidth = value;
        this._refresh();
      }
      get topHeight() {
        return this._topHeight;
      }
      set topHeight(value) {
        this._topHeight = value;
        this._refresh();
      }
      get bottomHeight() {
        return this._bottomHeight;
      }
      set bottomHeight(value) {
        this._bottomHeight = value;
        this._refresh();
      }
      _refresh() {
        const texture = this.texture;
        const uvs = this.geometry.buffers[1].data;
        this._origWidth = texture.orig.width;
        this._origHeight = texture.orig.height;
        const _uvw = 1 / this._origWidth;
        const _uvh = 1 / this._origHeight;
        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
        this.updateHorizontalVertices();
        this.updateVerticalVertices();
        this.geometry.buffers[0].update();
        this.geometry.buffers[1].update();
      }
    };
  }
});

// node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs
var SimpleMesh;
var init_SimpleMesh = __esm({
  "node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs"() {
    init_lib();
    init_lib5();
    SimpleMesh = class extends Mesh {
      constructor(texture = Texture.EMPTY, vertices, uvs, indices2, drawMode) {
        const geometry = new MeshGeometry(vertices, uvs, indices2);
        geometry.getBuffer("aVertexPosition").static = false;
        const meshMaterial = new MeshMaterial(texture);
        super(geometry, meshMaterial, null, drawMode);
        this.autoUpdate = true;
      }
      get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data;
      }
      set vertices(value) {
        this.geometry.getBuffer("aVertexPosition").data = value;
      }
      _render(renderer) {
        if (this.autoUpdate) {
          this.geometry.getBuffer("aVertexPosition").update();
        }
        super._render(renderer);
      }
    };
  }
});

// node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs
var SimpleRope;
var init_SimpleRope = __esm({
  "node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs"() {
    init_lib();
    init_lib5();
    init_RopeGeometry();
    SimpleRope = class extends Mesh {
      constructor(texture, points, textureScale = 0) {
        const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
        const meshMaterial = new MeshMaterial(texture);
        if (textureScale > 0) {
          texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;
        }
        super(ropeGeometry, meshMaterial);
        this.autoUpdate = true;
      }
      _render(renderer) {
        const geometry = this.geometry;
        if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
          geometry._width = this.shader.texture.height;
          geometry.update();
        }
        super._render(renderer);
      }
    };
  }
});

// node_modules/@pixi/mesh-extras/lib/index.mjs
var init_lib9 = __esm({
  "node_modules/@pixi/mesh-extras/lib/index.mjs"() {
    init_PlaneGeometry();
    init_RopeGeometry();
    init_NineSlicePlane();
    init_SimpleMesh();
    init_SimplePlane();
    init_SimpleRope();
  }
});

// node_modules/@pixi/particle-container/lib/ParticleContainer.mjs
var ParticleContainer;
var init_ParticleContainer = __esm({
  "node_modules/@pixi/particle-container/lib/ParticleContainer.mjs"() {
    init_lib();
    init_lib2();
    ParticleContainer = class extends Container {
      constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false) {
        super();
        const maxBatchSize = 16384;
        if (batchSize > maxBatchSize) {
          batchSize = maxBatchSize;
        }
        this._properties = [false, true, false, false, false];
        this._maxSize = maxSize;
        this._batchSize = batchSize;
        this._buffers = null;
        this._bufferUpdateIDs = [];
        this._updateID = 0;
        this.interactiveChildren = false;
        this.blendMode = BLEND_MODES.NORMAL;
        this.autoResize = autoResize;
        this.roundPixels = true;
        this.baseTexture = null;
        this.setProperties(properties);
        this._tintColor = new Color(0);
        this.tintRgb = new Float32Array(3);
        this.tint = 16777215;
      }
      setProperties(properties) {
        if (properties) {
          this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
          this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
          this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
          this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
          this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
        }
      }
      updateTransform() {
        this.displayObjectUpdateTransform();
      }
      get tint() {
        return this._tintColor.value;
      }
      set tint(value) {
        this._tintColor.setValue(value);
        this._tintColor.toRgbArray(this.tintRgb);
      }
      render(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
          return;
        }
        if (!this.baseTexture) {
          this.baseTexture = this.children[0]._texture.baseTexture;
          if (!this.baseTexture.valid) {
            this.baseTexture.once("update", () => this.onChildrenChange(0));
          }
        }
        renderer.batch.setObjectRenderer(renderer.plugins.particle);
        renderer.plugins.particle.render(this);
      }
      onChildrenChange(smallestChildIndex) {
        const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
        while (this._bufferUpdateIDs.length < bufferIndex) {
          this._bufferUpdateIDs.push(0);
        }
        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
      }
      dispose() {
        if (this._buffers) {
          for (let i = 0; i < this._buffers.length; ++i) {
            this._buffers[i].destroy();
          }
          this._buffers = null;
        }
      }
      destroy(options) {
        super.destroy(options);
        this.dispose();
        this._properties = null;
        this._buffers = null;
        this._bufferUpdateIDs = null;
      }
    };
  }
});

// node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs
var ParticleBuffer;
var init_ParticleBuffer = __esm({
  "node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs"() {
    init_lib();
    ParticleBuffer = class {
      constructor(properties, dynamicPropertyFlags, size) {
        this.geometry = new Geometry();
        this.indexBuffer = null;
        this.size = size;
        this.dynamicProperties = [];
        this.staticProperties = [];
        for (let i = 0; i < properties.length; ++i) {
          let property = properties[i];
          property = {
            attributeName: property.attributeName,
            size: property.size,
            uploadFunction: property.uploadFunction,
            type: property.type || TYPES.FLOAT,
            offset: property.offset
          };
          if (dynamicPropertyFlags[i]) {
            this.dynamicProperties.push(property);
          } else {
            this.staticProperties.push(property);
          }
        }
        this.staticStride = 0;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.dynamicStride = 0;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this._updateID = 0;
        this.initBuffers();
      }
      initBuffers() {
        const geometry = this.geometry;
        let dynamicOffset = 0;
        this.indexBuffer = new Buffer(lib_exports.createIndicesForQuads(this.size), true, true);
        geometry.addIndex(this.indexBuffer);
        this.dynamicStride = 0;
        for (let i = 0; i < this.dynamicProperties.length; ++i) {
          const property = this.dynamicProperties[i];
          property.offset = dynamicOffset;
          dynamicOffset += property.size;
          this.dynamicStride += property.size;
        }
        const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(dynBuffer);
        this.dynamicDataUint32 = new Uint32Array(dynBuffer);
        this.dynamicBuffer = new Buffer(this.dynamicData, false, false);
        let staticOffset = 0;
        this.staticStride = 0;
        for (let i = 0; i < this.staticProperties.length; ++i) {
          const property = this.staticProperties[i];
          property.offset = staticOffset;
          staticOffset += property.size;
          this.staticStride += property.size;
        }
        const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(statBuffer);
        this.staticDataUint32 = new Uint32Array(statBuffer);
        this.staticBuffer = new Buffer(this.staticData, true, false);
        for (let i = 0; i < this.dynamicProperties.length; ++i) {
          const property = this.dynamicProperties[i];
          geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
        }
        for (let i = 0; i < this.staticProperties.length; ++i) {
          const property = this.staticProperties[i];
          geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
        }
      }
      uploadDynamic(children, startIndex, amount) {
        for (let i = 0; i < this.dynamicProperties.length; i++) {
          const property = this.dynamicProperties[i];
          property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
        }
        this.dynamicBuffer._updateID++;
      }
      uploadStatic(children, startIndex, amount) {
        for (let i = 0; i < this.staticProperties.length; i++) {
          const property = this.staticProperties[i];
          property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
        }
        this.staticBuffer._updateID++;
      }
      destroy() {
        this.indexBuffer = null;
        this.dynamicProperties = null;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this.staticProperties = null;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.geometry.destroy();
      }
    };
  }
});

// node_modules/@pixi/particle-container/lib/particles.mjs
var fragment2;
var init_particles = __esm({
  "node_modules/@pixi/particle-container/lib/particles.mjs"() {
    fragment2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
  }
});

// node_modules/@pixi/particle-container/lib/particles2.mjs
var vertex2;
var init_particles2 = __esm({
  "node_modules/@pixi/particle-container/lib/particles2.mjs"() {
    vertex2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
  }
});

// node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs
var ParticleRenderer;
var init_ParticleRenderer = __esm({
  "node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs"() {
    init_lib();
    init_ParticleBuffer();
    init_particles();
    init_particles2();
    ParticleRenderer = class extends ObjectRenderer {
      constructor(renderer) {
        super(renderer);
        this.shader = null;
        this.properties = null;
        this.tempMatrix = new Matrix();
        this.properties = [
          {
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: this.uploadVertices,
            offset: 0
          },
          {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: this.uploadPosition,
            offset: 0
          },
          {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: this.uploadRotation,
            offset: 0
          },
          {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: this.uploadUvs,
            offset: 0
          },
          {
            attributeName: "aColor",
            size: 1,
            type: TYPES.UNSIGNED_BYTE,
            uploadFunction: this.uploadTint,
            offset: 0
          }
        ];
        this.shader = Shader.from(vertex2, fragment2, {});
        this.state = State.for2d();
      }
      render(container) {
        const children = container.children;
        const maxSize = container._maxSize;
        const batchSize = container._batchSize;
        const renderer = this.renderer;
        let totalChildren = children.length;
        if (totalChildren === 0) {
          return;
        } else if (totalChildren > maxSize && !container.autoResize) {
          totalChildren = maxSize;
        }
        let buffers = container._buffers;
        if (!buffers) {
          buffers = container._buffers = this.generateBuffers(container);
        }
        const baseTexture = children[0]._texture.baseTexture;
        const premultiplied = baseTexture.alphaMode > 0;
        this.state.blendMode = lib_exports.correctBlendMode(container.blendMode, premultiplied);
        renderer.state.set(this.state);
        const gl = renderer.gl;
        const m = container.worldTransform.copyTo(this.tempMatrix);
        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
        this.shader.uniforms.translationMatrix = m.toArray(true);
        this.shader.uniforms.uColor = Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);
        this.shader.uniforms.uSampler = baseTexture;
        this.renderer.shader.bind(this.shader);
        let updateStatic = false;
        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
          let amount = totalChildren - i;
          if (amount > batchSize) {
            amount = batchSize;
          }
          if (j >= buffers.length) {
            buffers.push(this._generateOneMoreBuffer(container));
          }
          const buffer = buffers[j];
          buffer.uploadDynamic(children, i, amount);
          const bid = container._bufferUpdateIDs[j] || 0;
          updateStatic = updateStatic || buffer._updateID < bid;
          if (updateStatic) {
            buffer._updateID = container._updateID;
            buffer.uploadStatic(children, i, amount);
          }
          renderer.geometry.bind(buffer.geometry);
          gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        }
      }
      generateBuffers(container) {
        const buffers = [];
        const size = container._maxSize;
        const batchSize = container._batchSize;
        const dynamicPropertyFlags = container._properties;
        for (let i = 0; i < size; i += batchSize) {
          buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
        }
        return buffers;
      }
      _generateOneMoreBuffer(container) {
        const batchSize = container._batchSize;
        const dynamicPropertyFlags = container._properties;
        return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
      }
      uploadVertices(children, startIndex, amount, array, stride, offset) {
        let w0 = 0;
        let w1 = 0;
        let h0 = 0;
        let h1 = 0;
        for (let i = 0; i < amount; ++i) {
          const sprite = children[startIndex + i];
          const texture = sprite._texture;
          const sx = sprite.scale.x;
          const sy = sprite.scale.y;
          const trim = texture.trim;
          const orig = texture.orig;
          if (trim) {
            w1 = trim.x - sprite.anchor.x * orig.width;
            w0 = w1 + trim.width;
            h1 = trim.y - sprite.anchor.y * orig.height;
            h0 = h1 + trim.height;
          } else {
            w0 = orig.width * (1 - sprite.anchor.x);
            w1 = orig.width * -sprite.anchor.x;
            h0 = orig.height * (1 - sprite.anchor.y);
            h1 = orig.height * -sprite.anchor.y;
          }
          array[offset] = w1 * sx;
          array[offset + 1] = h1 * sy;
          array[offset + stride] = w0 * sx;
          array[offset + stride + 1] = h1 * sy;
          array[offset + stride * 2] = w0 * sx;
          array[offset + stride * 2 + 1] = h0 * sy;
          array[offset + stride * 3] = w1 * sx;
          array[offset + stride * 3 + 1] = h0 * sy;
          offset += stride * 4;
        }
      }
      uploadPosition(children, startIndex, amount, array, stride, offset) {
        for (let i = 0; i < amount; i++) {
          const spritePosition = children[startIndex + i].position;
          array[offset] = spritePosition.x;
          array[offset + 1] = spritePosition.y;
          array[offset + stride] = spritePosition.x;
          array[offset + stride + 1] = spritePosition.y;
          array[offset + stride * 2] = spritePosition.x;
          array[offset + stride * 2 + 1] = spritePosition.y;
          array[offset + stride * 3] = spritePosition.x;
          array[offset + stride * 3 + 1] = spritePosition.y;
          offset += stride * 4;
        }
      }
      uploadRotation(children, startIndex, amount, array, stride, offset) {
        for (let i = 0; i < amount; i++) {
          const spriteRotation = children[startIndex + i].rotation;
          array[offset] = spriteRotation;
          array[offset + stride] = spriteRotation;
          array[offset + stride * 2] = spriteRotation;
          array[offset + stride * 3] = spriteRotation;
          offset += stride * 4;
        }
      }
      uploadUvs(children, startIndex, amount, array, stride, offset) {
        for (let i = 0; i < amount; ++i) {
          const textureUvs = children[startIndex + i]._texture._uvs;
          if (textureUvs) {
            array[offset] = textureUvs.x0;
            array[offset + 1] = textureUvs.y0;
            array[offset + stride] = textureUvs.x1;
            array[offset + stride + 1] = textureUvs.y1;
            array[offset + stride * 2] = textureUvs.x2;
            array[offset + stride * 2 + 1] = textureUvs.y2;
            array[offset + stride * 3] = textureUvs.x3;
            array[offset + stride * 3 + 1] = textureUvs.y3;
            offset += stride * 4;
          } else {
            array[offset] = 0;
            array[offset + 1] = 0;
            array[offset + stride] = 0;
            array[offset + stride + 1] = 0;
            array[offset + stride * 2] = 0;
            array[offset + stride * 2 + 1] = 0;
            array[offset + stride * 3] = 0;
            array[offset + stride * 3 + 1] = 0;
            offset += stride * 4;
          }
        }
      }
      uploadTint(children, startIndex, amount, array, stride, offset) {
        for (let i = 0; i < amount; ++i) {
          const sprite = children[startIndex + i];
          const result = Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);
          array[offset] = result;
          array[offset + stride] = result;
          array[offset + stride * 2] = result;
          array[offset + stride * 3] = result;
          offset += stride * 4;
        }
      }
      destroy() {
        super.destroy();
        if (this.shader) {
          this.shader.destroy();
          this.shader = null;
        }
        this.tempMatrix = null;
      }
    };
    ParticleRenderer.extension = {
      name: "particle",
      type: ExtensionType.RendererPlugin
    };
    extensions.add(ParticleRenderer);
  }
});

// node_modules/@pixi/particle-container/lib/index.mjs
var init_lib10 = __esm({
  "node_modules/@pixi/particle-container/lib/index.mjs"() {
    init_ParticleContainer();
    init_ParticleRenderer();
  }
});

// node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs
var AnimatedSprite;
var init_AnimatedSprite = __esm({
  "node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs"() {
    init_lib();
    init_lib3();
    AnimatedSprite = class _AnimatedSprite extends Sprite {
      constructor(textures, autoUpdate = true) {
        super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);
        this._textures = null;
        this._durations = null;
        this._autoUpdate = autoUpdate;
        this._isConnectedToTicker = false;
        this.animationSpeed = 1;
        this.loop = true;
        this.updateAnchor = false;
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
        this._currentTime = 0;
        this._playing = false;
        this._previousFrame = null;
        this.textures = textures;
      }
      stop() {
        if (!this._playing) {
          return;
        }
        this._playing = false;
        if (this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
      }
      play() {
        if (this._playing) {
          return;
        }
        this._playing = true;
        if (this._autoUpdate && !this._isConnectedToTicker) {
          Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
          this._isConnectedToTicker = true;
        }
      }
      gotoAndStop(frameNumber) {
        this.stop();
        this.currentFrame = frameNumber;
      }
      gotoAndPlay(frameNumber) {
        this.currentFrame = frameNumber;
        this.play();
      }
      update(deltaTime) {
        if (!this._playing) {
          return;
        }
        const elapsed = this.animationSpeed * deltaTime;
        const previousFrame = this.currentFrame;
        if (this._durations !== null) {
          let lag = this._currentTime % 1 * this._durations[this.currentFrame];
          lag += elapsed / 60 * 1e3;
          while (lag < 0) {
            this._currentTime--;
            lag += this._durations[this.currentFrame];
          }
          const sign = Math.sign(this.animationSpeed * deltaTime);
          this._currentTime = Math.floor(this._currentTime);
          while (lag >= this._durations[this.currentFrame]) {
            lag -= this._durations[this.currentFrame] * sign;
            this._currentTime += sign;
          }
          this._currentTime += lag / this._durations[this.currentFrame];
        } else {
          this._currentTime += elapsed;
        }
        if (this._currentTime < 0 && !this.loop) {
          this.gotoAndStop(0);
          if (this.onComplete) {
            this.onComplete();
          }
        } else if (this._currentTime >= this._textures.length && !this.loop) {
          this.gotoAndStop(this._textures.length - 1);
          if (this.onComplete) {
            this.onComplete();
          }
        } else if (previousFrame !== this.currentFrame) {
          if (this.loop && this.onLoop) {
            if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
              this.onLoop();
            }
          }
          this.updateTexture();
        }
      }
      updateTexture() {
        const currentFrame = this.currentFrame;
        if (this._previousFrame === currentFrame) {
          return;
        }
        this._previousFrame = currentFrame;
        this._texture = this._textures[currentFrame];
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this._cachedTint = 16777215;
        this.uvs = this._texture._uvs.uvsFloat32;
        if (this.updateAnchor) {
          this._anchor.copyFrom(this._texture.defaultAnchor);
        }
        if (this.onFrameChange) {
          this.onFrameChange(this.currentFrame);
        }
      }
      destroy(options) {
        this.stop();
        super.destroy(options);
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
      }
      static fromFrames(frames) {
        const textures = [];
        for (let i = 0; i < frames.length; ++i) {
          textures.push(Texture.from(frames[i]));
        }
        return new _AnimatedSprite(textures);
      }
      static fromImages(images) {
        const textures = [];
        for (let i = 0; i < images.length; ++i) {
          textures.push(Texture.from(images[i]));
        }
        return new _AnimatedSprite(textures);
      }
      get totalFrames() {
        return this._textures.length;
      }
      get textures() {
        return this._textures;
      }
      set textures(value) {
        if (value[0] instanceof Texture) {
          this._textures = value;
          this._durations = null;
        } else {
          this._textures = [];
          this._durations = [];
          for (let i = 0; i < value.length; i++) {
            this._textures.push(value[i].texture);
            this._durations.push(value[i].time);
          }
        }
        this._previousFrame = null;
        this.gotoAndStop(0);
        this.updateTexture();
      }
      get currentFrame() {
        let currentFrame = Math.floor(this._currentTime) % this._textures.length;
        if (currentFrame < 0) {
          currentFrame += this._textures.length;
        }
        return currentFrame;
      }
      set currentFrame(value) {
        if (value < 0 || value > this.totalFrames - 1) {
          throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
        }
        const previousFrame = this.currentFrame;
        this._currentTime = value;
        if (previousFrame !== this.currentFrame) {
          this.updateTexture();
        }
      }
      get playing() {
        return this._playing;
      }
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          if (!this._autoUpdate && this._isConnectedToTicker) {
            Ticker.shared.remove(this.update, this);
            this._isConnectedToTicker = false;
          } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
            Ticker.shared.add(this.update, this);
            this._isConnectedToTicker = true;
          }
        }
      }
    };
  }
});

// node_modules/@pixi/sprite-animated/lib/index.mjs
var init_lib11 = __esm({
  "node_modules/@pixi/sprite-animated/lib/index.mjs"() {
    init_AnimatedSprite();
  }
});

// node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs
var tempPoint3, TilingSprite;
var init_TilingSprite = __esm({
  "node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs"() {
    init_lib();
    init_lib3();
    tempPoint3 = new Point();
    TilingSprite = class _TilingSprite extends Sprite {
      constructor(texture, width = 100, height = 100) {
        super(texture);
        this.tileTransform = new Transform();
        this._width = width;
        this._height = height;
        this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture);
        this.pluginName = "tilingSprite";
        this.uvRespectAnchor = false;
      }
      get clampMargin() {
        return this.uvMatrix.clampMargin;
      }
      set clampMargin(value) {
        this.uvMatrix.clampMargin = value;
        this.uvMatrix.update(true);
      }
      get tileScale() {
        return this.tileTransform.scale;
      }
      set tileScale(value) {
        this.tileTransform.scale.copyFrom(value);
      }
      get tilePosition() {
        return this.tileTransform.position;
      }
      set tilePosition(value) {
        this.tileTransform.position.copyFrom(value);
      }
      _onTextureUpdate() {
        if (this.uvMatrix) {
          this.uvMatrix.texture = this._texture;
        }
        this._cachedTint = 16777215;
      }
      _render(renderer) {
        const texture = this._texture;
        if (!texture || !texture.valid) {
          return;
        }
        this.tileTransform.updateLocalTransform();
        this.uvMatrix.update();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      }
      _calculateBounds() {
        const minX = this._width * -this._anchor._x;
        const minY = this._height * -this._anchor._y;
        const maxX = this._width * (1 - this._anchor._x);
        const maxY = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
      }
      getLocalBounds(rect) {
        if (this.children.length === 0) {
          this._bounds.minX = this._width * -this._anchor._x;
          this._bounds.minY = this._height * -this._anchor._y;
          this._bounds.maxX = this._width * (1 - this._anchor._x);
          this._bounds.maxY = this._height * (1 - this._anchor._y);
          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new Rectangle();
            }
            rect = this._localBoundsRect;
          }
          return this._bounds.getRectangle(rect);
        }
        return super.getLocalBounds.call(this, rect);
      }
      containsPoint(point) {
        this.worldTransform.applyInverse(point, tempPoint3);
        const width = this._width;
        const height = this._height;
        const x1 = -width * this.anchor._x;
        if (tempPoint3.x >= x1 && tempPoint3.x < x1 + width) {
          const y1 = -height * this.anchor._y;
          if (tempPoint3.y >= y1 && tempPoint3.y < y1 + height) {
            return true;
          }
        }
        return false;
      }
      destroy(options) {
        super.destroy(options);
        this.tileTransform = null;
        this.uvMatrix = null;
      }
      static from(source, options) {
        const texture = source instanceof Texture ? source : Texture.from(source, options);
        return new _TilingSprite(texture, options.width, options.height);
      }
      get width() {
        return this._width;
      }
      set width(value) {
        this._width = value;
      }
      get height() {
        return this._height;
      }
      set height(value) {
        this._height = value;
      }
    };
  }
});

// node_modules/@pixi/sprite-tiling/lib/sprite-tiling.mjs
var gl2FragmentSrc;
var init_sprite_tiling = __esm({
  "node_modules/@pixi/sprite-tiling/lib/sprite-tiling.mjs"() {
    gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";
  }
});

// node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.mjs
var gl2VertexSrc;
var init_sprite_tiling2 = __esm({
  "node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.mjs"() {
    gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
  }
});

// node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.mjs
var gl1FragmentSrc;
var init_sprite_tiling_fallback = __esm({
  "node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.mjs"() {
    gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";
  }
});

// node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.mjs
var gl1VertexSrc;
var init_sprite_tiling_fallback2 = __esm({
  "node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.mjs"() {
    gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
  }
});

// node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.mjs
var fragmentSimpleSrc;
var init_sprite_tiling_simple = __esm({
  "node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.mjs"() {
    fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
  }
});

// node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs
var tempMat, TilingSpriteRenderer;
var init_TilingSpriteRenderer = __esm({
  "node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs"() {
    init_lib();
    init_sprite_tiling();
    init_sprite_tiling2();
    init_sprite_tiling_fallback();
    init_sprite_tiling_fallback2();
    init_sprite_tiling_simple();
    tempMat = new Matrix();
    TilingSpriteRenderer = class extends ObjectRenderer {
      constructor(renderer) {
        super(renderer);
        renderer.runners.contextChange.add(this);
        this.quad = new QuadUv();
        this.state = State.for2d();
      }
      contextChange() {
        const renderer = this.renderer;
        const uniforms = { globals: renderer.globalUniforms };
        this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
        this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
      }
      render(ts) {
        const renderer = this.renderer;
        const quad = this.quad;
        let vertices = quad.vertices;
        vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
        vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
        vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
        const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
        const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
        vertices = quad.uvs;
        vertices[0] = vertices[6] = -anchorX;
        vertices[1] = vertices[3] = -anchorY;
        vertices[2] = vertices[4] = 1 - anchorX;
        vertices[5] = vertices[7] = 1 - anchorY;
        quad.invalidate();
        const tex = ts._texture;
        const baseTex = tex.baseTexture;
        const premultiplied = baseTex.alphaMode > 0;
        const lt = ts.tileTransform.localTransform;
        const uv = ts.uvMatrix;
        let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
        if (isSimple) {
          if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
            if (baseTex.wrapMode === WRAP_MODES.CLAMP) {
              baseTex.wrapMode = WRAP_MODES.REPEAT;
            }
          } else {
            isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;
          }
        }
        const shader = isSimple ? this.simpleShader : this.shader;
        const w = tex.width;
        const h = tex.height;
        const W = ts._width;
        const H = ts._height;
        tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
        tempMat.invert();
        if (isSimple) {
          tempMat.prepend(uv.mapCoord);
        } else {
          shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
          shader.uniforms.uClampFrame = uv.uClampFrame;
          shader.uniforms.uClampOffset = uv.uClampOffset;
        }
        shader.uniforms.uTransform = tempMat.toArray(true);
        shader.uniforms.uColor = Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);
        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
        shader.uniforms.uSampler = tex;
        renderer.shader.bind(shader);
        renderer.geometry.bind(quad);
        this.state.blendMode = lib_exports.correctBlendMode(ts.blendMode, premultiplied);
        renderer.state.set(this.state);
        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
      }
    };
    TilingSpriteRenderer.extension = {
      name: "tilingSprite",
      type: ExtensionType.RendererPlugin
    };
    extensions.add(TilingSpriteRenderer);
  }
});

// node_modules/@pixi/sprite-tiling/lib/index.mjs
var init_lib12 = __esm({
  "node_modules/@pixi/sprite-tiling/lib/index.mjs"() {
    init_TilingSprite();
    init_TilingSpriteRenderer();
  }
});

// node_modules/@pixi/app/lib/Application.mjs
var _Application, Application;
var init_Application = __esm({
  "node_modules/@pixi/app/lib/Application.mjs"() {
    init_lib();
    init_lib2();
    _Application = class {
      constructor(options) {
        this.stage = new Container();
        options = Object.assign({
          forceCanvas: false
        }, options);
        this.renderer = autoDetectRenderer(options);
        _Application._plugins.forEach((plugin) => {
          plugin.init.call(this, options);
        });
      }
      render() {
        this.renderer.render(this.stage);
      }
      get view() {
        return this.renderer.view;
      }
      get screen() {
        return this.renderer.screen;
      }
      destroy(removeView, stageOptions) {
        const plugins = _Application._plugins.slice(0);
        plugins.reverse();
        plugins.forEach((plugin) => {
          plugin.destroy.call(this);
        });
        this.stage.destroy(stageOptions);
        this.stage = null;
        this.renderer.destroy(removeView);
        this.renderer = null;
      }
    };
    Application = _Application;
    Application._plugins = [];
    extensions.handleByList(ExtensionType.Application, Application._plugins);
  }
});

// node_modules/@pixi/app/lib/ResizePlugin.mjs
var ResizePlugin;
var init_ResizePlugin = __esm({
  "node_modules/@pixi/app/lib/ResizePlugin.mjs"() {
    init_lib();
    ResizePlugin = class {
      static init(options) {
        Object.defineProperty(this, "resizeTo", {
          set(dom) {
            globalThis.removeEventListener("resize", this.queueResize);
            this._resizeTo = dom;
            if (dom) {
              globalThis.addEventListener("resize", this.queueResize);
              this.resize();
            }
          },
          get() {
            return this._resizeTo;
          }
        });
        this.queueResize = () => {
          if (!this._resizeTo) {
            return;
          }
          this.cancelResize();
          this._resizeId = requestAnimationFrame(() => this.resize());
        };
        this.cancelResize = () => {
          if (this._resizeId) {
            cancelAnimationFrame(this._resizeId);
            this._resizeId = null;
          }
        };
        this.resize = () => {
          if (!this._resizeTo) {
            return;
          }
          this.cancelResize();
          let width;
          let height;
          if (this._resizeTo === globalThis.window) {
            width = globalThis.innerWidth;
            height = globalThis.innerHeight;
          } else {
            const { clientWidth, clientHeight } = this._resizeTo;
            width = clientWidth;
            height = clientHeight;
          }
          this.renderer.resize(width, height);
          this.render();
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      }
      static destroy() {
        globalThis.removeEventListener("resize", this.queueResize);
        this.cancelResize();
        this.cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      }
    };
    ResizePlugin.extension = ExtensionType.Application;
    extensions.add(ResizePlugin);
  }
});

// node_modules/@pixi/app/lib/index.mjs
var init_lib13 = __esm({
  "node_modules/@pixi/app/lib/index.mjs"() {
    init_Application();
    init_ResizePlugin();
  }
});

export {
  TEXT_GRADIENT,
  Sprite,
  init_lib3 as init_lib,
  TextMetrics,
  TextStyle,
  Text,
  init_lib4 as init_lib2,
  BitmapFontData,
  TextFormat,
  XMLFormat,
  XMLStringFormat,
  autoDetectFormat,
  BitmapFont,
  MeshBatchUvs,
  Mesh,
  MeshGeometry,
  MeshMaterial,
  init_lib5 as init_lib3,
  BitmapText,
  checkDataUrl,
  checkExtension,
  convertToList,
  copySearchParams,
  createStringVariations,
  isSingleItem,
  Cache,
  LoaderParserPriority,
  loadJson,
  loadTxt,
  getFontFamilyName,
  loadWebFont,
  createTexture,
  loadImageBitmap,
  loadTextures,
  loadSVG,
  AssetsClass,
  Assets,
  cacheTextureArray,
  detectAvif,
  detectWebp,
  detectDefaults,
  resolveTextureUrl,
  init_lib6 as init_lib4,
  loadBitmapFont,
  init_lib7 as init_lib5,
  LINE_JOIN,
  LINE_CAP,
  curves,
  GRAPHICS_CURVES,
  GraphicsData,
  GraphicsGeometry,
  FillStyle,
  LineStyle,
  Graphics,
  graphicsUtils,
  init_lib8 as init_lib6,
  PlaneGeometry,
  RopeGeometry,
  SimplePlane,
  NineSlicePlane,
  SimpleMesh,
  SimpleRope,
  init_lib9 as init_lib7,
  ParticleContainer,
  ParticleRenderer,
  init_lib10 as init_lib8,
  AnimatedSprite,
  init_lib11 as init_lib9,
  TilingSprite,
  TilingSpriteRenderer,
  init_lib12 as init_lib10,
  Application,
  ResizePlugin,
  init_lib13 as init_lib11
};
//# sourceMappingURL=chunk-R7RQH7XH.js.map
