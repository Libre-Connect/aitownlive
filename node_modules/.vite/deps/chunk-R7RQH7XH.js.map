{
  "version": 3,
  "sources": ["../../@pixi/text/src/const.ts", "../../@pixi/sprite/src/Sprite.ts", "../../@pixi/sprite/lib/index.mjs", "../../@pixi/text/src/TextMetrics.ts", "../../@pixi/text/src/TextStyle.ts", "../../@pixi/text/src/Text.ts", "../../@pixi/text/lib/index.mjs", "../../@pixi/text-bitmap/src/BitmapFontData.ts", "../../@pixi/text-bitmap/src/formats/TextFormat.ts", "../../@pixi/text-bitmap/src/formats/XMLFormat.ts", "../../@pixi/text-bitmap/src/formats/XMLStringFormat.ts", "../../@pixi/text-bitmap/src/formats/index.ts", "../../@pixi/text-bitmap/src/utils/generateFillStyle.ts", "../../@pixi/text-bitmap/src/utils/drawGlyph.ts", "../../@pixi/text-bitmap/src/utils/extractCharCode.ts", "../../@pixi/text-bitmap/src/utils/splitTextToCharacters.ts", "../../@pixi/text-bitmap/src/utils/resolveCharacters.ts", "../../@pixi/text-bitmap/lib/utils/index.mjs", "../../@pixi/text-bitmap/src/BitmapFont.ts", "../../@pixi/mesh/src/MeshBatchUvs.ts", "../../@pixi/mesh/src/Mesh.ts", "../../@pixi/mesh/src/MeshGeometry.ts", "../../@pixi/mesh/lib/shader/mesh.mjs", "../../@pixi/mesh/lib/shader/mesh2.mjs", "../../@pixi/mesh/src/MeshMaterial.ts", "../../@pixi/mesh/lib/index.mjs", "../../@pixi/text-bitmap/lib/shader/msdf.mjs", "../../@pixi/text-bitmap/lib/shader/msdf2.mjs", "../../@pixi/text-bitmap/src/BitmapText.ts", "../../@pixi/assets/src/utils/checkDataUrl.ts", "../../@pixi/assets/src/utils/checkExtension.ts", "../../@pixi/assets/src/utils/convertToList.ts", "../../@pixi/assets/src/utils/copySearchParams.ts", "../../@pixi/assets/src/utils/createStringVariations.ts", "../../@pixi/assets/src/utils/isSingleItem.ts", "../../@pixi/assets/lib/utils/index.mjs", "../../@pixi/assets/src/cache/Cache.ts", "../../@pixi/assets/src/loader/parsers/LoaderParser.ts", "../../@pixi/assets/src/loader/parsers/loadJson.ts", "../../@pixi/assets/src/loader/parsers/loadTxt.ts", "../../@pixi/assets/src/loader/parsers/loadWebFont.ts", "../../@pixi/assets/src/loader/parsers/textures/utils/createTexture.ts", "../../@pixi/assets/src/loader/parsers/WorkerManager.ts", "../../@pixi/assets/src/loader/parsers/textures/loadTextures.ts", "../../@pixi/assets/src/loader/parsers/textures/loadSVG.ts", "../../@pixi/assets/src/BackgroundLoader.ts", "../../@pixi/assets/src/loader/Loader.ts", "../../@pixi/assets/lib/loader/parsers/textures/utils/index.mjs", "../../@pixi/assets/lib/loader/parsers/textures/index.mjs", "../../@pixi/assets/lib/loader/parsers/index.mjs", "../../@pixi/assets/src/resolver/Resolver.ts", "../../@pixi/assets/src/Assets.ts", "../../@pixi/assets/src/cache/parsers/cacheTextureArray.ts", "../../@pixi/assets/src/detections/parsers/detectAvif.ts", "../../@pixi/assets/src/detections/parsers/detectWebp.ts", "../../@pixi/assets/src/detections/parsers/detectDefaults.ts", "../../@pixi/assets/lib/loader/types.mjs", "../../@pixi/assets/lib/loader/index.mjs", "../../@pixi/assets/src/resolver/parsers/resolveTextureUrl.ts", "../../@pixi/assets/src/AssetExtension.ts", "../../@pixi/assets/lib/cache/CacheParser.mjs", "../../@pixi/assets/lib/cache/parsers/index.mjs", "../../@pixi/assets/lib/cache/index.mjs", "../../@pixi/assets/lib/detections/parsers/index.mjs", "../../@pixi/assets/lib/detections/index.mjs", "../../@pixi/assets/lib/resolver/parsers/index.mjs", "../../@pixi/assets/lib/resolver/types.mjs", "../../@pixi/assets/lib/resolver/index.mjs", "../../@pixi/assets/lib/index.mjs", "../../@pixi/text-bitmap/src/loadBitmapFont.ts", "../../@pixi/text-bitmap/lib/BitmapTextStyle.mjs", "../../@pixi/text-bitmap/lib/index.mjs", "../../@pixi/graphics/src/const.ts", "../../@pixi/graphics/src/GraphicsData.ts", "../../@pixi/graphics/src/utils/buildCircle.ts", "../../@pixi/graphics/src/utils/buildPoly.ts", "../../@pixi/graphics/src/utils/buildRectangle.ts", "../../@pixi/graphics/src/utils/buildRoundedRectangle.ts", "../../@pixi/graphics/src/utils/ArcUtils.ts", "../../@pixi/graphics/src/utils/BatchPart.ts", "../../@pixi/graphics/src/utils/BezierUtils.ts", "../../@pixi/graphics/src/utils/buildLine.ts", "../../@pixi/graphics/src/utils/QuadraticUtils.ts", "../../@pixi/graphics/src/utils/index.ts", "../../@pixi/graphics/src/GraphicsGeometry.ts", "../../@pixi/graphics/src/styles/FillStyle.ts", "../../@pixi/graphics/src/styles/LineStyle.ts", "../../@pixi/graphics/src/Graphics.ts", "../../@pixi/graphics/src/index.ts", "../../@pixi/mesh-extras/src/geometry/PlaneGeometry.ts", "../../@pixi/mesh-extras/src/geometry/RopeGeometry.ts", "../../@pixi/mesh-extras/src/SimplePlane.ts", "../../@pixi/mesh-extras/src/NineSlicePlane.ts", "../../@pixi/mesh-extras/src/SimpleMesh.ts", "../../@pixi/mesh-extras/src/SimpleRope.ts", "../../@pixi/mesh-extras/lib/index.mjs", "../../@pixi/particle-container/src/ParticleContainer.ts", "../../@pixi/particle-container/src/ParticleBuffer.ts", "../../@pixi/particle-container/lib/particles.mjs", "../../@pixi/particle-container/lib/particles2.mjs", "../../@pixi/particle-container/src/ParticleRenderer.ts", "../../@pixi/particle-container/lib/index.mjs", "../../@pixi/sprite-animated/src/AnimatedSprite.ts", "../../@pixi/sprite-animated/lib/index.mjs", "../../@pixi/sprite-tiling/src/TilingSprite.ts", "../../@pixi/sprite-tiling/lib/sprite-tiling.mjs", "../../@pixi/sprite-tiling/lib/sprite-tiling2.mjs", "../../@pixi/sprite-tiling/lib/sprite-tiling-fallback.mjs", "../../@pixi/sprite-tiling/lib/sprite-tiling-fallback2.mjs", "../../@pixi/sprite-tiling/lib/sprite-tiling-simple.mjs", "../../@pixi/sprite-tiling/src/TilingSpriteRenderer.ts", "../../@pixi/sprite-tiling/lib/index.mjs", "../../@pixi/app/src/Application.ts", "../../@pixi/app/src/ResizePlugin.ts", "../../@pixi/app/lib/index.mjs"],
  "sourcesContent": ["/**\n * Constants that define the type of gradient on text.\n * @static\n * @memberof PIXI\n * @type {object}\n */\nexport enum TEXT_GRADIENT\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * Vertical gradient\n     * @default 0\n     */\n    LINEAR_VERTICAL = 0,\n    /**\n     * Linear gradient\n     * @default 1\n     */\n    LINEAR_HORIZONTAL = 1\n}\n", "import { BLEND_MODES, Color, ObservablePoint, Point, Rectangle, settings, Texture, utils } from '@pixi/core';\nimport { Bounds, Container } from '@pixi/display';\n\nimport type { ColorSource, IBaseTextureOptions, IPointData, Renderer, TextureSource } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\nconst tempPoint = new Point();\nconst indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\n\nexport type SpriteSource = TextureSource | Texture;\n\nexport interface Sprite extends GlobalMixins.Sprite, Container {}\n\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link PIXI.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * import { Assets, Sprite } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n * ```\n * @memberof PIXI\n */\nexport class Sprite extends Container\n{\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    public blendMode: BLEND_MODES;\n    public indices: Uint16Array;\n\n    /**\n     * Plugin that is responsible for rendering this element.\n     * Allows to customize the rendering process without overriding '_render' & '_renderCanvas' methods.\n     * @default 'batch'\n     */\n    public pluginName: string;\n\n    /**\n     * The width of the sprite (this is initially set by the texture).\n     * @protected\n     */\n    _width: number;\n\n    /**\n     * The height of the sprite (this is initially set by the texture)\n     * @protected\n     */\n    _height: number;\n\n    /**\n     * The texture that the sprite is using.\n     * @private\n     */\n    _texture: Texture;\n    _textureID: number;\n\n    /**\n     * Cached tint value so we can tell when the tint is changed.\n     * Value is used for 2d CanvasRenderer.\n     * @protected\n     * @default 0xFFFFFF\n     */\n    _cachedTint: number;\n    protected _textureTrimmedID: number;\n\n    /**\n     * This is used to store the uvs data of the sprite, assigned at the same time\n     * as the vertexData in calculateVertices().\n     * @member {Float32Array}\n     */\n    protected uvs: Float32Array;\n\n    /**\n     * The anchor point defines the normalized coordinates\n     * in the texture that map to the position of this\n     * sprite.\n     *\n     * By default, this is `(0,0)` (or `texture.defaultAnchor`\n     * if you have modified that), which means the position\n     * `(x,y)` of this `Sprite` will be the top-left corner.\n     *\n     * Note: Updating `texture.defaultAnchor` after\n     * constructing a `Sprite` does _not_ update its anchor.\n     *\n     * {@link https://docs.cocos2d-x.org/cocos2d-x/en/sprites/manipulation.html}\n     * @default `this.texture.defaultAnchor`\n     */\n    protected _anchor: ObservablePoint;\n\n    /**\n     * This is used to store the vertex data of the sprite (basically a quad).\n     * @member {Float32Array}\n     */\n    protected vertexData: Float32Array;\n\n    /**\n     * This is used to calculate the bounds of the object IF it is a trimmed sprite.\n     * @member {Float32Array}\n     */\n    private vertexTrimmedData: Float32Array;\n\n    /**\n     * Internal roundPixels field\n     * @private\n     */\n    private _roundPixels: boolean;\n    private _transformID: number;\n    private _transformTrimmedID: number;\n\n    /**\n     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    private _tintColor: Color;\n\n    // Internal-only properties\n    /**\n     * The tint applied to the sprite. This is a RGB value. A value of 0xFFFFFF will remove any tint effect.\n     * @private\n     * @default 16777215\n     */\n    _tintRGB: number;\n\n    /** @param texture - The texture for this sprite. */\n    constructor(texture?: Texture)\n    {\n        super();\n\n        this._anchor = new ObservablePoint(\n            this._onAnchorUpdate,\n            this,\n            (texture ? texture.defaultAnchor.x : 0),\n            (texture ? texture.defaultAnchor.y : 0)\n        );\n\n        this._texture = null;\n\n        this._width = 0;\n        this._height = 0;\n        this._tintColor = new Color(0xFFFFFF);\n        this._tintRGB = null;\n\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n        this._cachedTint = 0xFFFFFF;\n        this.uvs = null;\n\n        // call texture setter\n        this.texture = texture || Texture.EMPTY;\n        this.vertexData = new Float32Array(8);\n        this.vertexTrimmedData = null;\n\n        this._transformID = -1;\n        this._textureID = -1;\n\n        this._transformTrimmedID = -1;\n        this._textureTrimmedID = -1;\n\n        // Batchable stuff..\n        // TODO could make this a mixin?\n        this.indices = indices;\n\n        this.pluginName = 'batch';\n\n        /**\n         * Used to fast check if a sprite is.. a sprite!\n         * @member {boolean}\n         */\n        this.isSprite = true;\n        this._roundPixels = settings.ROUND_PIXELS;\n    }\n\n    /** When the texture is updated, this event will fire to update the scale and frame. */\n    protected _onTextureUpdate(): void\n    {\n        this._textureID = -1;\n        this._textureTrimmedID = -1;\n        this._cachedTint = 0xFFFFFF;\n\n        // so if _width is 0 then width was not set..\n        if (this._width)\n        {\n            this.scale.x = utils.sign(this.scale.x) * this._width / this._texture.orig.width;\n        }\n\n        if (this._height)\n        {\n            this.scale.y = utils.sign(this.scale.y) * this._height / this._texture.orig.height;\n        }\n    }\n\n    /** Called when the anchor position updates. */\n    private _onAnchorUpdate(): void\n    {\n        this._transformID = -1;\n        this._transformTrimmedID = -1;\n    }\n\n    /** Calculates worldTransform * vertices, store it in vertexData. */\n    public calculateVertices(): void\n    {\n        const texture = this._texture;\n\n        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID)\n        {\n            return;\n        }\n\n        // update texture UV here, because base texture can be changed without calling `_onTextureUpdate`\n        if (this._textureID !== texture._updateID)\n        {\n            this.uvs = this._texture._uvs.uvsFloat32;\n        }\n\n        this._transformID = this.transform._worldID;\n        this._textureID = texture._updateID;\n\n        // set the vertex data\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n        const vertexData = this.vertexData;\n        const trim = texture.trim;\n        const orig = texture.orig;\n        const anchor = this._anchor;\n\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        if (trim)\n        {\n            // if the sprite is trimmed and is not a tilingsprite then we need to add the extra\n            // space before transforming the sprite coords.\n            w1 = trim.x - (anchor._x * orig.width);\n            w0 = w1 + trim.width;\n\n            h1 = trim.y - (anchor._y * orig.height);\n            h0 = h1 + trim.height;\n        }\n        else\n        {\n            w1 = -anchor._x * orig.width;\n            w0 = w1 + orig.width;\n\n            h1 = -anchor._y * orig.height;\n            h0 = h1 + orig.height;\n        }\n\n        // xy\n        vertexData[0] = (a * w1) + (c * h1) + tx;\n        vertexData[1] = (d * h1) + (b * w1) + ty;\n\n        // xy\n        vertexData[2] = (a * w0) + (c * h1) + tx;\n        vertexData[3] = (d * h1) + (b * w0) + ty;\n\n        // xy\n        vertexData[4] = (a * w0) + (c * h0) + tx;\n        vertexData[5] = (d * h0) + (b * w0) + ty;\n\n        // xy\n        vertexData[6] = (a * w1) + (c * h0) + tx;\n        vertexData[7] = (d * h0) + (b * w1) + ty;\n\n        if (this._roundPixels)\n        {\n            const resolution = settings.RESOLUTION;\n\n            for (let i = 0; i < vertexData.length; ++i)\n            {\n                vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n            }\n        }\n    }\n\n    /**\n     * Calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData.\n     *\n     * This is used to ensure that the true width and height of a trimmed texture is respected.\n     */\n    public calculateTrimmedVertices(): void\n    {\n        if (!this.vertexTrimmedData)\n        {\n            this.vertexTrimmedData = new Float32Array(8);\n        }\n        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)\n        {\n            return;\n        }\n\n        this._transformTrimmedID = this.transform._worldID;\n        this._textureTrimmedID = this._texture._updateID;\n\n        // lets do some special trim code!\n        const texture = this._texture;\n        const vertexData = this.vertexTrimmedData;\n        const orig = texture.orig;\n        const anchor = this._anchor;\n\n        // lets calculate the new untrimmed bounds..\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const w1 = -anchor._x * orig.width;\n        const w0 = w1 + orig.width;\n\n        const h1 = -anchor._y * orig.height;\n        const h0 = h1 + orig.height;\n\n        // xy\n        vertexData[0] = (a * w1) + (c * h1) + tx;\n        vertexData[1] = (d * h1) + (b * w1) + ty;\n\n        // xy\n        vertexData[2] = (a * w0) + (c * h1) + tx;\n        vertexData[3] = (d * h1) + (b * w0) + ty;\n\n        // xy\n        vertexData[4] = (a * w0) + (c * h0) + tx;\n        vertexData[5] = (d * h0) + (b * w0) + ty;\n\n        // xy\n        vertexData[6] = (a * w1) + (c * h0) + tx;\n        vertexData[7] = (d * h0) + (b * w1) + ty;\n    }\n\n    /**\n     *\n     * Renders the object using the WebGL renderer\n     * @param renderer - The webgl renderer to use.\n     */\n    protected _render(renderer: Renderer): void\n    {\n        this.calculateVertices();\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /** Updates the bounds of the sprite. */\n    protected _calculateBounds(): void\n    {\n        const trim = this._texture.trim;\n        const orig = this._texture.orig;\n\n        // First lets check to see if the current texture has a trim..\n        if (!trim || (trim.width === orig.width && trim.height === orig.height))\n        {\n            // no trim! lets use the usual calculations..\n            this.calculateVertices();\n            this._bounds.addQuad(this.vertexData);\n        }\n        else\n        {\n            // lets calculate a special trimmed bounds...\n            this.calculateTrimmedVertices();\n            this._bounds.addQuad(this.vertexTrimmedData);\n        }\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     * @param rect - Optional output rectangle.\n     * @returns The bounds.\n     */\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            if (!this._localBounds)\n            {\n                this._localBounds = new Bounds();\n            }\n\n            this._localBounds.minX = this._texture.orig.width * -this._anchor._x;\n            this._localBounds.minY = this._texture.orig.height * -this._anchor._y;\n            this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);\n            this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._localBounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Tests if a point is inside this sprite\n     * @param point - the point to test\n     * @returns The result of the test\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._texture.orig.width;\n        const height = this._texture.orig.height;\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite and optionally its texture and children.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        this._texture.off('update', this._onTextureUpdate, this);\n\n        this._anchor = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyBaseTexture = typeof options === 'boolean' ? options : options?.baseTexture;\n\n            this._texture.destroy(!!destroyBaseTexture);\n        }\n\n        this._texture = null;\n    }\n\n    // some helper functions..\n\n    /**\n     * Helper function that creates a new sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     * @param {string|PIXI.Texture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source\n     *     - Source to create texture from\n     * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @returns The newly created sprite\n     */\n    static from(source: SpriteSource, options?: IBaseTextureOptions): Sprite\n    {\n        const texture = (source instanceof Texture)\n            ? source\n            : Texture.from(source, options);\n\n        return new Sprite(texture);\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     *\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     *\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.\n     * @default false\n     */\n    set roundPixels(value: boolean)\n    {\n        if (this._roundPixels !== value)\n        {\n            this._transformID = -1;\n        }\n        this._roundPixels = value;\n    }\n\n    get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value: number)\n    {\n        const s = utils.sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value: number)\n    {\n        const s = utils.sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(Texture.WHITE);\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: ObservablePoint)\n    {\n        this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The tint applied to the sprite. This is a hex value.\n     *\n     * A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    set tint(value: ColorSource)\n    {\n        this._tintColor.setValue(value);\n        this._tintRGB = this._tintColor.toLittleEndianNumber();\n    }\n\n    /**\n     * Get the tint as a RGB integer.\n     * @ignore\n     */\n    get tintValue(): number\n    {\n        return this._tintColor.toNumber();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this._texture === value)\n        {\n            return;\n        }\n\n        if (this._texture)\n        {\n            this._texture.off('update', this._onTextureUpdate, this);\n        }\n\n        this._texture = value || Texture.EMPTY;\n        this._cachedTint = 0xFFFFFF;\n\n        this._textureID = -1;\n        this._textureTrimmedID = -1;\n\n        if (value)\n        {\n            // wait for the texture to load\n            if (value.baseTexture.valid)\n            {\n                this._onTextureUpdate();\n            }\n            else\n            {\n                value.once('update', this._onTextureUpdate, this);\n            }\n        }\n    }\n}\n", "export { Sprite } from './Sprite.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { settings } from '@pixi/core';\n\nimport type { ICanvas, ICanvasRenderingContext2D, ICanvasRenderingContext2DSettings } from '@pixi/core';\nimport type { TextStyle, TextStyleWhiteSpace } from './TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        new(): ISegmenter;\n    };\n}\n\n/**\n * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.\n * @typedef {object} FontMetrics\n * @property {number} ascent - The ascent distance\n * @property {number} descent - The descent distance\n * @property {number} fontSize - Font size from ascent to descent\n * @memberof PIXI.TextMetrics\n * @private\n */\n\n/**\n * A number, or a string containing a number.\n * @memberof PIXI\n * @typedef {object} IFontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */\ninterface IFontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { TextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = TextMetrics.measureText('Your text', style);\n * @memberof PIXI\n */\nexport class TextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: IFontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|ÉqÅ';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) => [...segmenter.segment(s)].map((x) => x.segment);\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see PIXI.TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = TextMetrics._experimentalLetterSpacingSupported;\n\n        if (result !== undefined)\n        {\n            const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;\n\n            result\n                = TextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see PIXI.TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@see PIXI.TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, IFontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    private static __canvas: ICanvas;\n    private static __context: ICanvasRenderingContext2D;\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {PIXI.IFontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: IFontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param wordWrap - Override for if word-wrap should be applied to the text.\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text: string,\n        style: TextStyle,\n        wordWrap?: boolean,\n        canvas: ICanvas = TextMetrics._canvas\n    ): TextMetrics\n    {\n        wordWrap = (wordWrap === undefined || wordWrap === null) ? style.wordWrap : wordWrap;\n        const font = style.toFontString();\n        const fontProperties = TextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        // (toDataURI, getImageData functions)\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = TextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n        let width = maxLineWidth + style.strokeThickness;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadowDistance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n        let height = Math.max(lineHeight, fontProperties.fontSize + (style.strokeThickness * 2))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadowDistance;\n        }\n\n        return new TextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (TextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (TextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        let width = context.measureText(text).width;\n\n        if (width > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                width -= letterSpacing;\n            }\n            else\n            {\n                width += (TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n            }\n        }\n\n        return width;\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = TextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);\n        const collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = TextMetrics.tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (TextMetrics.isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += TextMetrics.addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = TextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += TextMetrics.addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (TextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = TextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += TextMetrics.addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += TextMetrics.addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += TextMetrics.addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += TextMetrics.addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += TextMetrics.addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convienience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static addLine(line: string, newLine = true): string\n    {\n        line = TextMetrics.trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = TextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!TextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return TextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return TextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (TextMetrics.isBreakingSpace(char, nextChar) || TextMetrics.isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(char);\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see TextMetrics.graphemeSegmenter\n     */\n    static wordWrapSplit(token: string): string[]\n    {\n        return TextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): IFontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (TextMetrics._fonts[font])\n        {\n            return TextMetrics._fonts[font];\n        }\n\n        const properties: IFontMetrics = {\n            ascent: 0,\n            descent: 0,\n            fontSize: 0,\n        };\n\n        const canvas = TextMetrics._canvas;\n        const context = TextMetrics._context;\n\n        context.font = font;\n\n        const metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;\n        const width = Math.ceil(context.measureText(metricsString).width);\n        let baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);\n        const height = Math.ceil(TextMetrics.HEIGHT_MULTIPLIER * baseline);\n\n        baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;\n\n        if (width === 0 || height === 0)\n        {\n            TextMetrics._fonts[font] = properties;\n\n            return properties;\n        }\n\n        canvas.width = width;\n        canvas.height = height;\n\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n\n        context.font = font;\n\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText(metricsString, 0, baseline);\n\n        const imagedata = context.getImageData(0, 0, width, height).data;\n        const pixels = imagedata.length;\n        const line = width * 4;\n\n        let i = 0;\n        let idx = 0;\n        let stop = false;\n\n        // ascent. scan from top to bottom until we find a non red pixel\n        for (i = 0; i < baseline; ++i)\n        {\n            for (let j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx += line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.ascent = baseline - i;\n\n        idx = pixels - line;\n        stop = false;\n\n        // descent. scan from bottom to top until we find a non red pixel\n        for (i = height; i > baseline; --i)\n        {\n            for (let j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n\n            if (!stop)\n            {\n                idx -= line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.descent = i - baseline;\n        properties.fontSize = properties.ascent + properties.descent;\n\n        TextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete TextMetrics._fonts[font];\n        }\n        else\n        {\n            TextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!TextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    TextMetrics.__canvas = c;\n\n                    return c;\n                }\n\n                canvas = settings.ADAPTER.createCanvas();\n            }\n            catch (ex)\n            {\n                canvas = settings.ADAPTER.createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            TextMetrics.__canvas = canvas;\n        }\n\n        return TextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!TextMetrics.__context)\n        {\n            TextMetrics.__context = TextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return TextMetrics.__context;\n    }\n}\n", "// disabling eslint for now, going to rewrite this in v5\n/* eslint-disable */\n\nimport { TEXT_GRADIENT } from './const';\nimport { Color } from '@pixi/core';\n\nexport type TextStyleAlign = 'left'|'center'|'right'|'justify';\nexport type TextStyleFill = string|string[]|number|number[]|CanvasGradient|CanvasPattern;\nexport type TextStyleFontStyle = 'normal'|'italic'|'oblique';\nexport type TextStyleFontVariant = 'normal'|'small-caps';\nexport type TextStyleFontWeight = 'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900';\nexport type TextStyleLineJoin = 'miter'|'round'|'bevel';\nexport type TextStyleTextBaseline = 'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom';\nexport type TextStyleWhiteSpace = 'normal'|'pre'|'pre-line';\n\n/**\n * Generic interface for TextStyle options.\n * @memberof PIXI\n */\nexport interface ITextStyle {\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    align: TextStyleAlign;\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true */\n    breakWords: boolean;\n    /** Set a drop shadow for the text */\n    dropShadow: boolean;\n    /** Set alpha for the drop shadow */\n    dropShadowAlpha: number;\n    /** Set a angle of the drop shadow */\n    dropShadowAngle: number;\n    /** Set a shadow blur radius */\n    dropShadowBlur: number;\n    /** A fill style to be used on the dropshadow e.g., 'red', '#00FF00' */\n    dropShadowColor: string|number;\n    /** Set a distance of the drop shadow */\n    dropShadowDistance: number;\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     * Can be an array to create a gradient, e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    fill: TextStyleFill;\n    /**\n     * If fill is an array of colours to create a gradient, this can change the\n     * type/direction of the gradient. See {@link PIXI.TEXT_GRADIENT}\n     * @type {PIXI.TEXT_GRADIENT}\n     */\n    fillGradientType: TEXT_GRADIENT;\n    /**\n     * If fill is an array of colours to create a gradient, this array can set\n     * the stop points (numbers between 0 and 1) for the color, overriding the\n     * default behaviour of evenly spacing them.\n     */\n    fillGradientStops: number[];\n    /**\n     * The font family, can be a single font name, or a list of names where the first\n     * is the preferred font.\n     */\n    fontFamily: string | string[];\n    /**\n     * The font size (as a number it converts to px, but as a string,\n     * equivalents are '26px','20pt','160%' or '1.6em')\n     */\n    fontSize: number | string;\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    fontStyle: TextStyleFontStyle;\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    fontVariant: TextStyleFontVariant;\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    fontWeight: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight: number;\n    /**\n     * The lineJoin property sets the type of corner created, it can resolve\n     * spiked text issues. Possible values \"miter\" (creates a sharp corner),\n     * \"round\" (creates a round corner) or \"bevel\" (creates a squared corner).\n     * @type {'miter'|'round'|'bevel'}\n     */\n    lineJoin: TextStyleLineJoin;\n    /**\n     * The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n     * or increase the spikiness of rendered text.\n     */\n    miterLimit: number;\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding: number;\n    /** A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00' */\n    stroke: string|number;\n    /** A number that represents the thickness of the stroke. A value of 0 will disable stroke. */\n    strokeThickness: number;\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    textBaseline: TextStyleTextBaseline;\n    /** Trim transparent borders */\n    trim: boolean;\n    /**\n     * Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     * (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve,\n     * collapse). It needs wordWrap to be set to true.\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    whiteSpace: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth: number;\n}\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n *\n * A tool can be used to generate a text style [here](https://pixijs.io/pixi-text-style).\n *\n * @memberof PIXI\n * @example\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *   fontSize: 36,\n * });\n */\nexport class TextStyle implements ITextStyle\n{\n    /**\n     * Default style options used for all TextStyle instances.\n     * @type {PIXI.ITextStyle}\n     */\n    public static defaultStyle: ITextStyle = {\n        /**\n         * See {@link PIXI.TextStyle.align}\n         * @type {'left'|'center'|'right'|'justify'}\n         */\n        align: 'left',\n        /** See {@link PIXI.TextStyle.breakWords} */\n        breakWords: false,\n        /** See {@link PIXI.TextStyle.dropShadow} */\n        dropShadow: false,\n        /** See {@link PIXI.TextStyle.dropShadowAlpha} */\n        dropShadowAlpha: 1,\n        /**\n         * See {@link PIXI.TextStyle.dropShadowAngle}\n         * @type {number}\n         * @default Math.PI / 6\n         */\n        dropShadowAngle: Math.PI / 6,\n        /** See {@link PIXI.TextStyle.dropShadowBlur} */\n        dropShadowBlur: 0,\n        /**\n         * See {@link PIXI.TextStyle.dropShadowColor}\n         * @type {string|number}\n         */\n        dropShadowColor: 'black',\n        /** See {@link PIXI.TextStyle.dropShadowDistance} */\n        dropShadowDistance: 5,\n        /**\n         * See {@link PIXI.TextStyle.fill}\n         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */\n        fill: 'black',\n        /**\n         * See {@link PIXI.TextStyle.fillGradientType}\n         * @type {PIXI.TEXT_GRADIENT}\n         * @default PIXI.TEXT_GRADIENT.LINEAR_VERTICAL\n         */\n        fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,\n        /**\n         * See {@link PIXI.TextStyle.fillGradientStops}\n         * @type {number[]}\n         * @default []\n         */\n        fillGradientStops: [],\n        /**\n         * See {@link PIXI.TextStyle.fontFamily}\n         * @type {string|string[]}\n         */\n        fontFamily: 'Arial',\n        /**\n         * See {@link PIXI.TextStyle.fontSize}\n         * @type {number|string} \n         */\n        fontSize: 26,\n        /**\n         * See {@link PIXI.TextStyle.fontStyle}\n         * @type {'normal'|'italic'|'oblique'}\n         */\n        fontStyle: 'normal',\n        /**\n         * See {@link PIXI.TextStyle.fontVariant}\n         * @type {'normal'|'small-caps'}\n         */\n        fontVariant: 'normal',\n        /**\n         * See {@link PIXI.TextStyle.fontWeight}\n         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n         */\n        fontWeight: 'normal',\n        /** See {@link PIXI.TextStyle.leading} */\n        leading: 0,\n        /** See {@link PIXI.TextStyle.letterSpacing} */\n        letterSpacing: 0,\n        /** See {@link PIXI.TextStyle.lineHeight} */\n        lineHeight: 0,\n        /**\n         * See {@link PIXI.TextStyle.lineJoin}\n         * @type {'miter'|'round'|'bevel'}\n         */\n        lineJoin: 'miter',\n        /** See {@link PIXI.TextStyle.miterLimit} */\n        miterLimit: 10,\n        /** See {@link PIXI.TextStyle.padding} */\n        padding: 0,\n        /**\n         * See {@link PIXI.TextStyle.stroke}\n         * @type {string|number}\n         */\n        stroke: 'black',\n        /** See {@link PIXI.TextStyle.strokeThickness} */\n        strokeThickness: 0,\n        /**\n         * See {@link PIXI.TextStyle.textBaseline} \n         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n         */\n        textBaseline: 'alphabetic',\n        /** See {@link PIXI.TextStyle.trim} */\n        trim: false,\n        /**\n         * See {@link PIXI.TextStyle.whiteSpace}\n         * @type {'normal'|'pre'|'pre-line'}\n         */\n        whiteSpace: 'pre',\n        /** See {@link PIXI.TextStyle.wordWrap} */\n        wordWrap: false,\n        /** See {@link PIXI.TextStyle.wordWrapWidth} */\n        wordWrapWidth: 100,\n    };\n\n    public styleID: number;\n\n    protected _align: TextStyleAlign;\n    protected _breakWords: boolean;\n    protected _dropShadow: boolean;\n    protected _dropShadowAlpha: number;\n    protected _dropShadowAngle: number;\n    protected _dropShadowBlur: number;\n    protected _dropShadowColor: string|number;\n    protected _dropShadowDistance: number;\n    protected _fill: TextStyleFill;\n    protected _fillGradientType: TEXT_GRADIENT;\n    protected _fillGradientStops: number[];\n    protected _fontFamily: string|string[];\n    protected _fontSize: number|string;\n    protected _fontStyle: TextStyleFontStyle;\n    protected _fontVariant: TextStyleFontVariant;\n    protected _fontWeight: TextStyleFontWeight;\n    protected _letterSpacing: number;\n    protected _lineHeight: number;\n    protected _lineJoin: TextStyleLineJoin;\n    protected _miterLimit: number;\n    protected _padding: number;\n    protected _stroke: string|number;\n    protected _strokeThickness: number;\n    protected _textBaseline: TextStyleTextBaseline;\n    protected _trim: boolean;\n    protected _whiteSpace: TextStyleWhiteSpace;\n    protected _wordWrap: boolean;\n    protected _wordWrapWidth: number;\n    protected _leading: number;\n\n    /**\n     * @param style - TextStyle properties to be set on the text. See {@link PIXI.TextStyle.defaultStyle}\n     *       for the default values.\n     */\n    constructor(style?: Partial<ITextStyle>)\n    {\n        this.styleID = 0;\n\n        this.reset();\n\n        deepCopyProperties(this, style, style);\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * Note that the only the properties of the object are cloned.\n     *\n     * @return New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        const clonedProperties: Partial<ITextStyle> = {};\n\n        deepCopyProperties(clonedProperties, this, TextStyle.defaultStyle);\n\n        return new TextStyle(clonedProperties);\n    }\n\n    /** Resets all properties to the defaults specified in TextStyle.prototype._default */\n    public reset(): void\n    {\n        deepCopyProperties(this, TextStyle.defaultStyle, TextStyle.defaultStyle);\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     *\n     * @member {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign\n    {\n        return this._align;\n    }\n    set align(align: TextStyleAlign)\n    {\n        if (this._align !== align)\n        {\n            this._align = align;\n            this.styleID++;\n        }\n    }\n\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean\n    {\n        return this._breakWords;\n    }\n    set breakWords(breakWords: boolean)\n    {\n        if (this._breakWords !== breakWords)\n        {\n            this._breakWords = breakWords;\n            this.styleID++;\n        }\n    }\n\n    /** Set a drop shadow for the text. */\n    get dropShadow(): boolean\n    {\n        return this._dropShadow;\n    }\n    set dropShadow(dropShadow: boolean)\n    {\n        if (this._dropShadow !== dropShadow)\n        {\n            this._dropShadow = dropShadow;\n            this.styleID++;\n        }\n    }\n\n    /** Set alpha for the drop shadow. */\n    get dropShadowAlpha(): number\n    {\n        return this._dropShadowAlpha;\n    }\n    set dropShadowAlpha(dropShadowAlpha: number)\n    {\n        if (this._dropShadowAlpha !== dropShadowAlpha)\n        {\n            this._dropShadowAlpha = dropShadowAlpha;\n            this.styleID++;\n        }\n    }\n\n    /** Set a angle of the drop shadow. */\n    get dropShadowAngle(): number\n    {\n        return this._dropShadowAngle;\n    }\n    set dropShadowAngle(dropShadowAngle: number)\n    {\n        if (this._dropShadowAngle !== dropShadowAngle)\n        {\n            this._dropShadowAngle = dropShadowAngle;\n            this.styleID++;\n        }\n    }\n\n    /** Set a shadow blur radius. */\n    get dropShadowBlur(): number\n    {\n        return this._dropShadowBlur;\n    }\n    set dropShadowBlur(dropShadowBlur: number)\n    {\n        if (this._dropShadowBlur !== dropShadowBlur)\n        {\n            this._dropShadowBlur = dropShadowBlur;\n            this.styleID++;\n        }\n    }\n\n    /** A fill style to be used on the dropshadow e.g., 'red', '#00FF00'. */\n    get dropShadowColor(): number | string\n    {\n        return this._dropShadowColor;\n    }\n    set dropShadowColor(dropShadowColor: number | string)\n    {\n        const outputColor = getColor(dropShadowColor);\n        if (this._dropShadowColor !== outputColor)\n        {\n            this._dropShadowColor = outputColor;\n            this.styleID++;\n        }\n    }\n\n    /** Set a distance of the drop shadow. */\n    get dropShadowDistance(): number\n    {\n        return this._dropShadowDistance;\n    }\n    set dropShadowDistance(dropShadowDistance: number)\n    {\n        if (this._dropShadowDistance !== dropShadowDistance)\n        {\n            this._dropShadowDistance = dropShadowDistance;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     *\n     * Can be an array to create a gradient e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     *\n     * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    get fill(): TextStyleFill\n    {\n        return this._fill;\n    }\n    set fill(fill: TextStyleFill)\n    {\n        // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n        //       the setter converts to string. See this thread for more details:\n        //       https://github.com/microsoft/TypeScript/issues/2521\n        // TODO: Not sure if getColor works properly with CanvasGradient and/or CanvasPattern, can't pass in\n        //       without casting here.\n        const outputColor = getColor(fill as any);\n        if (this._fill !== outputColor)\n        {\n            this._fill = outputColor;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.\n     *\n     * @type {PIXI.TEXT_GRADIENT}\n     */\n    get fillGradientType(): TEXT_GRADIENT\n    {\n        return this._fillGradientType;\n    }\n    set fillGradientType(fillGradientType: TEXT_GRADIENT)\n    {\n        if (this._fillGradientType !== fillGradientType)\n        {\n            this._fillGradientType = fillGradientType;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * If fill is an array of colours to create a gradient, this array can set the stop points\n     * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.\n     */\n    get fillGradientStops(): number[]\n    {\n        return this._fillGradientStops;\n    }\n    set fillGradientStops(fillGradientStops: number[])\n    {\n        if (!areArraysEqual(this._fillGradientStops,fillGradientStops))\n        {\n            this._fillGradientStops = fillGradientStops;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * The font family, can be a single font name, or a list of names where the first\n     * is the preferred font.\n     */\n    get fontFamily(): string | string[]\n    {\n        return this._fontFamily;\n    }\n    set fontFamily(fontFamily: string | string[])\n    {\n        if (this.fontFamily !== fontFamily)\n        {\n            this._fontFamily = fontFamily;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * The font size\n     * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')\n     */\n    get fontSize(): number | string\n    {\n        return this._fontSize;\n    }\n    set fontSize(fontSize: number | string)\n    {\n        if (this._fontSize !== fontSize)\n        {\n            this._fontSize = fontSize;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * The font style.\n     *\n     * @member {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle\n    {\n        return this._fontStyle;\n    }\n    set fontStyle(fontStyle: TextStyleFontStyle)\n    {\n        if (this._fontStyle !== fontStyle)\n        {\n            this._fontStyle = fontStyle;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * The font variant.\n     *\n     * @member {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant\n    {\n        return this._fontVariant;\n    }\n    set fontVariant(fontVariant: TextStyleFontVariant)\n    {\n        if (this._fontVariant !== fontVariant)\n        {\n            this._fontVariant = fontVariant;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * The font weight.\n     *\n     * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight\n    {\n        return this._fontWeight;\n    }\n    set fontWeight(fontWeight: TextStyleFontWeight)\n    {\n        if (this._fontWeight !== fontWeight)\n        {\n            this._fontWeight = fontWeight;\n            this.styleID++;\n        }\n    }\n\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number\n    {\n        return this._letterSpacing;\n    }\n    set letterSpacing(letterSpacing: number)\n    {\n        if (this._letterSpacing !== letterSpacing)\n        {\n            this._letterSpacing = letterSpacing;\n            this.styleID++;\n        }\n    }\n\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number\n    {\n        return this._lineHeight;\n    }\n    set lineHeight(lineHeight: number)\n    {\n        if (this._lineHeight !== lineHeight)\n        {\n            this._lineHeight = lineHeight;\n            this.styleID++;\n        }\n    }\n\n    /** The space between lines. */\n    get leading(): number\n    {\n        return this._leading;\n    }\n    set leading(leading: number)\n    {\n        if (this._leading !== leading)\n        {\n            this._leading = leading;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * The lineJoin property sets the type of corner created, it can resolve spiked text issues.\n     * Default is 'miter' (creates a sharp corner).\n     *\n     * @member {'miter'|'round'|'bevel'}\n     */\n    get lineJoin(): TextStyleLineJoin\n    {\n        return this._lineJoin;\n    }\n    set lineJoin(lineJoin: TextStyleLineJoin)\n    {\n        if (this._lineJoin !== lineJoin)\n        {\n            this._lineJoin = lineJoin;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * The miter limit to use when using the 'miter' lineJoin mode.\n     *\n     * This can reduce or increase the spikiness of rendered text.\n     */\n    get miterLimit(): number\n    {\n        return this._miterLimit;\n    }\n    set miterLimit(miterLimit: number)\n    {\n        if (this._miterLimit !== miterLimit)\n        {\n            this._miterLimit = miterLimit;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     */\n    get padding(): number\n    {\n        return this._padding;\n    }\n    set padding(padding: number)\n    {\n        if (this._padding !== padding)\n        {\n            this._padding = padding;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'\n     */\n    get stroke(): string | number\n    {\n        return this._stroke;\n    }\n    set stroke(stroke: string | number)\n    {\n        // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n        //       the setter converts to string. See this thread for more details:\n        //       https://github.com/microsoft/TypeScript/issues/2521\n        const outputColor = getColor(stroke);\n        if (this._stroke !== outputColor)\n        {\n            this._stroke = outputColor;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * A number that represents the thickness of the stroke.\n     *\n     * @default 0\n     */\n    get strokeThickness(): number\n    {\n        return this._strokeThickness;\n    }\n    set strokeThickness(strokeThickness: number)\n    {\n        if (this._strokeThickness !== strokeThickness)\n        {\n            this._strokeThickness = strokeThickness;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * The baseline of the text that is rendered.\n     *\n     * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline\n    {\n        return this._textBaseline;\n    }\n    set textBaseline(textBaseline: TextStyleTextBaseline)\n    {\n        if (this._textBaseline !== textBaseline)\n        {\n            this._textBaseline = textBaseline;\n            this.styleID++;\n        }\n    }\n\n    /** Trim transparent borders. */\n    get trim(): boolean\n    {\n        return this._trim;\n    }\n    set trim(trim: boolean)\n    {\n        if (this._trim !== trim)\n        {\n            this._trim = trim;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     *\n     * @member {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace\n    {\n        return this._whiteSpace;\n    }\n    set whiteSpace(whiteSpace: TextStyleWhiteSpace)\n    {\n        if (this._whiteSpace !== whiteSpace)\n        {\n            this._whiteSpace = whiteSpace;\n            this.styleID++;\n        }\n    }\n\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean\n    {\n        return this._wordWrap;\n    }\n    set wordWrap(wordWrap: boolean)\n    {\n        if (this._wordWrap !== wordWrap)\n        {\n            this._wordWrap = wordWrap;\n            this.styleID++;\n        }\n    }\n\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number\n    {\n        return this._wordWrapWidth;\n    }\n    set wordWrapWidth(wordWrapWidth: number)\n    {\n        if (this._wordWrapWidth !== wordWrapWidth)\n        {\n            this._wordWrapWidth = wordWrapWidth;\n            this.styleID++;\n        }\n    }\n\n    /**\n     * Generates a font style string to use for `TextMetrics.measureFont()`.\n     *\n     * @return Font style string, for passing to `TextMetrics.measureFont()`\n     */\n    public toFontString(): string\n    {\n        // build canvas api font setting from individual components. Convert a numeric this.fontSize to px\n        const fontSizeString = (typeof this.fontSize === 'number') ? `${this.fontSize}px` : this.fontSize;\n\n        // Clean-up fontFamily property by quoting each font name\n        // this will support font names with spaces\n        let fontFamilies: string|string[] = this.fontFamily;\n\n        if (!Array.isArray(this.fontFamily))\n        {\n            fontFamilies = this.fontFamily.split(',');\n        }\n\n        for (let i = fontFamilies.length - 1; i >= 0; i--)\n        {\n            // Trim any extra white-space\n            let fontFamily = fontFamilies[i].trim();\n\n            // Check if font already contains strings\n            if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n            {\n                fontFamily = `\"${fontFamily}\"`;\n            }\n            (fontFamilies as string[])[i] = fontFamily;\n        }\n\n        return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n    }\n}\n\n/**\n * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.\n * This version can also convert array of colors\n * @private\n * @param color\n * @return The color as a string.\n */\nfunction getColor(color: (string|number)[]): string[];\nfunction getColor(color: string|number): string;\nfunction getColor(color: string|number|(string|number)[]): string|string[]\n{\n    const temp = Color.shared;\n\n    if (!Array.isArray(color))\n    {\n        return temp.setValue(color).toHex();\n    }\n    else\n    {\n        return color.map(c => temp.setValue(c).toHex());\n    }\n}\n\n/**\n * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.\n * This version can also convert array of colors\n * @private\n * @param array1 - First array to compare\n * @param array2 - Second array to compare\n * @return Do the arrays contain the same values in the same order\n */\nfunction areArraysEqual<T>(array1: T[], array2: T[]): boolean\n{\n    if (!Array.isArray(array1) || !Array.isArray(array2))\n    {\n        return false;\n    }\n\n    if (array1.length !== array2.length)\n    {\n        return false;\n    }\n\n    for (let i = 0; i < array1.length; ++i)\n    {\n        if (array1[i] !== array2[i])\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Utility function to ensure that object properties are copied by value, and not by reference\n * @private\n * @param target - Target object to copy properties into\n * @param source - Source object for the properties to copy\n * @param propertyObj - Object containing properties names we want to loop over\n */\nfunction deepCopyProperties(target: Record<string, any>, source: Record<string, any>, propertyObj: Record<string, any>): void {\n    for (const prop in propertyObj) {\n        if (Array.isArray(source[prop])) {\n            target[prop] = source[prop].slice();\n        } else {\n            target[prop] = source[prop];\n        }\n    }\n}\n", "/* eslint max-depth: [2, 8] */\nimport { Color, Rectangle, settings, Texture, utils } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { TEXT_GRADIENT } from './const';\nimport { TextMetrics } from './TextMetrics';\nimport { TextStyle } from './TextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2D, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { ITextStyle } from './TextStyle';\n\nconst defaultDestroyOptions: IDestroyOptions = {\n    texture: true,\n    children: false,\n    baseTexture: true,\n};\n\n/**\n * A Text Object will create a line or multiple lines of text.\n *\n * The text is created using the [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API).\n *\n * The primary advantage of this class over BitmapText is that you have great control over the style of the text,\n * which you can change at runtime.\n *\n * The primary disadvantages is that each piece of text has it's own texture, which can use more memory.\n * When text changes, this texture has to be re-generated and re-uploaded to the GPU, taking up time.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and give the `wordWrapWidth` property a value.\n *\n * A Text can be created directly from a string and a style object,\n * which can be generated [here](https://pixijs.io/pixi-text-style).\n * @example\n * import { Text } from 'pixi.js';\n *\n * const text = new Text('This is a PixiJS text', {\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * @memberof PIXI\n */\nexport class Text extends Sprite\n{\n    /**\n     * Override whether or not the resolution of the text is automatically adjusted to match the resolution of the renderer.\n     * Setting this to false can allow you to get crisper text at lower render resolutions.\n     * @example\n     * // renderer has a resolution of 1\n     * const app = new Application();\n     *\n     * Text.defaultResolution = 2;\n     * Text.defaultAutoResolution = false;\n     * // text has a resolution of 2\n     * const text = new Text('This is a PixiJS text');\n     */\n    public static defaultAutoResolution = true;\n\n    /**\n     * If {@link PIXI.Text.defaultAutoResolution} is false, this will be the default resolution of the text.\n     * If not set it will default to {@link PIXI.settings.RESOLUTION}.\n     * @example\n     * Text.defaultResolution = 2;\n     * Text.defaultAutoResolution = false;\n     *\n     * // text has a resolution of 2\n     * const text = new Text('This is a PixiJS text');\n     */\n    public static defaultResolution: number;\n\n    /**\n     * @see PIXI.TextMetrics.experimentalLetterSpacing\n     * @deprecated since 7.1.0\n     */\n    public static get experimentalLetterSpacing()\n    {\n        return TextMetrics.experimentalLetterSpacing;\n    }\n    public static set experimentalLetterSpacing(value)\n    {\n        // #if _DEBUG\n        utils.deprecation('7.1.0',\n            'Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing');\n        // #endif\n\n        TextMetrics.experimentalLetterSpacing = value;\n    }\n\n    /** The canvas element that everything is drawn to. */\n    public canvas: ICanvas;\n    /** The canvas 2d context that everything is drawn with. */\n    public context: ICanvasRenderingContext2D;\n    public localStyleID: number;\n    public dirty: boolean;\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default PIXI.settings.RESOLUTION\n     */\n    _resolution: number;\n    _autoResolution: boolean;\n\n    /**\n     * Private tracker for the current text.\n     * @private\n     */\n    protected _text: string;\n\n    /**\n     * Private tracker for the current font.\n     * @private\n     */\n    protected _font: string;\n\n    /**\n     * Private tracker for the current style.\n     * @private\n     */\n    protected _style: TextStyle;\n\n    /**\n     * Private listener to track style changes.\n     * @private\n     */\n    protected _styleListener: () => void;\n\n    /**\n     * Keep track if this Text object created it's own canvas\n     * element (`true`) or uses the constructor argument (`false`).\n     * Used to workaround a GC issues with Safari < 13 when\n     * destroying Text. See `destroy` for more info.\n     */\n    private _ownCanvas: boolean;\n\n    /**\n     * @param text - The string that you would like the text to display\n     * @param style - The style parameters\n     * @param canvas - The canvas element for drawing text\n     */\n    constructor(text?: string | number, style?: Partial<ITextStyle> | TextStyle, canvas?: ICanvas)\n    {\n        let ownCanvas = false;\n\n        if (!canvas)\n        {\n            canvas = settings.ADAPTER.createCanvas();\n            ownCanvas = true;\n        }\n\n        canvas.width = 3;\n        canvas.height = 3;\n\n        const texture = Texture.from(canvas);\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        super(texture);\n\n        this._ownCanvas = ownCanvas;\n        this.canvas = canvas;\n        this.context = canvas.getContext('2d', {\n            // required for trimming to work without warnings\n            willReadFrequently: true,\n        });\n\n        this._resolution = Text.defaultResolution ?? settings.RESOLUTION;\n        this._autoResolution = Text.defaultAutoResolution;\n        this._text = null;\n        this._style = null;\n        this._styleListener = null;\n        this._font = '';\n\n        this.text = text;\n        this.style = style;\n\n        this.localStyleID = -1;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n     */\n    public updateText(respectDirty: boolean): void\n    {\n        const style = this._style;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        this._font = this._style.toFontString();\n\n        const context = this.context;\n        const measured = TextMetrics.measureText(this._text || ' ', this._style, this._style.wordWrap, this.canvas);\n        const width = measured.width;\n        const height = measured.height;\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        this.canvas.width = Math.ceil(Math.ceil((Math.max(1, width) + (style.padding * 2))) * this._resolution);\n        this.canvas.height = Math.ceil(Math.ceil((Math.max(1, height) + (style.padding * 2))) * this._resolution);\n\n        context.scale(this._resolution, this._resolution);\n\n        context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        context.font = this._font;\n        context.lineWidth = style.strokeThickness;\n        context.textBaseline = style.textBaseline;\n        context.lineJoin = style.lineJoin;\n        context.miterLimit = style.miterLimit;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * this._resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const dropShadowColor = style.dropShadowColor;\n                const dropShadowBlur = style.dropShadowBlur * this._resolution;\n                const dropShadowDistance = style.dropShadowDistance * this._resolution;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(style.dropShadowAlpha)\n                    .toRgbaString();\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(style.dropShadowAngle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                // set canvas text styles\n                context.fillStyle = this._generateFillStyle(style, lines, measured);\n                // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n                //       the setter converts to string. See this thread for more details:\n                //       https://github.com/microsoft/TypeScript/issues/2521\n                context.strokeStyle = style.stroke as string;\n\n                context.shadowColor = 'black';\n                context.shadowBlur = 0;\n                context.shadowOffsetX = 0;\n                context.shadowOffsetY = 0;\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = style.strokeThickness / 2;\n                linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent\n                    + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style.stroke && style.strokeThickness)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style.fill)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n\n        this.updateTexture();\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private drawLetterSpacing(text: string, x: number, y: number, isStroke = false): void\n    {\n        const style = this._style;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (TextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (TextMetrics.experimentalLetterSpacing)\n            {\n                this.context.letterSpacing = `${letterSpacing}px`;\n                this.context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                this.context.letterSpacing = '0px';\n                this.context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                this.context.strokeText(text, x, y);\n            }\n            else\n            {\n                this.context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = TextMetrics.graphemeSegmenter(text);\n        let previousWidth = this.context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                this.context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                this.context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = this.context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    /** Updates texture size based on canvas size. */\n    private updateTexture(): void\n    {\n        const canvas = this.canvas;\n\n        if (this._style.trim)\n        {\n            const trimmed = utils.trimCanvas(canvas);\n\n            if (trimmed.data)\n            {\n                canvas.width = trimmed.width;\n                canvas.height = trimmed.height;\n                this.context.putImageData(trimmed.data, 0, 0);\n            }\n        }\n\n        const texture = this._texture;\n        const style = this._style;\n        const padding = style.trim ? 0 : style.padding;\n        const baseTexture = texture.baseTexture;\n\n        texture.trim.width = texture._frame.width = canvas.width / this._resolution;\n        texture.trim.height = texture._frame.height = canvas.height / this._resolution;\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);\n\n        texture.updateUvs();\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._render(renderer);\n    }\n\n    /** Updates the transform on all children of this container for rendering. */\n    public updateTransform(): void\n    {\n        this.updateText(true);\n\n        super.updateTransform();\n    }\n\n    public getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle\n    {\n        this.updateText(true);\n\n        if (this._textureID === -1)\n        {\n            // texture was updated: recalculate transforms\n            skipUpdate = false;\n        }\n\n        return super.getBounds(skipUpdate, rect);\n    }\n\n    /**\n     * Gets the local bounds of the text object.\n     * @param rect - The output rectangle.\n     * @returns The bounds.\n     */\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /** Calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account. */\n    protected _calculateBounds(): void\n    {\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        this._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n     * @param style - The style.\n     * @param lines - The lines of text.\n     * @param metrics\n     * @returns The fill style\n     */\n    private _generateFillStyle(\n        style: TextStyle, lines: string[], metrics: TextMetrics\n    ): string | CanvasGradient | CanvasPattern\n    {\n        // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n        //       the setter converts to string. See this thread for more details:\n        //       https://github.com/microsoft/TypeScript/issues/2521\n        const fillStyle: string | string[] | CanvasGradient | CanvasPattern = style.fill as any;\n\n        if (!Array.isArray(fillStyle))\n        {\n            return fillStyle;\n        }\n        else if (fillStyle.length === 1)\n        {\n            return fillStyle[0];\n        }\n\n        // the gradient will be evenly spaced out according to how large the array is.\n        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n        let gradient: string[] | CanvasGradient;\n\n        // a dropshadow will enlarge the canvas and result in the gradient being\n        // generated with the incorrect dimensions\n        const dropShadowCorrection = (style.dropShadow) ? style.dropShadowDistance : 0;\n\n        // should also take padding into account, padding can offset the gradient\n        const padding = style.padding || 0;\n\n        const width = (this.canvas.width / this._resolution) - dropShadowCorrection - (padding * 2);\n        const height = (this.canvas.height / this._resolution) - dropShadowCorrection - (padding * 2);\n\n        // make a copy of the style settings, so we can manipulate them later\n        const fill = fillStyle.slice();\n        const fillGradientStops = style.fillGradientStops.slice();\n\n        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n        if (!fillGradientStops.length)\n        {\n            const lengthPlus1 = fill.length + 1;\n\n            for (let i = 1; i < lengthPlus1; ++i)\n            {\n                fillGradientStops.push(i / lengthPlus1);\n            }\n        }\n\n        // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n        fill.unshift(fillStyle[0]);\n        fillGradientStops.unshift(0);\n\n        fill.push(fillStyle[fillStyle.length - 1]);\n        fillGradientStops.push(1);\n\n        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)\n        {\n            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n            gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n\n            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n\n            // Actual height of the text itself, not counting spacing for lineHeight/leading/dropShadow etc\n            const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n\n            for (let i = 0; i < lines.length; i++)\n            {\n                const lastLineBottom = (metrics.lineHeight * (i - 1)) + textHeight;\n                const thisLineTop = metrics.lineHeight * i;\n                let thisLineGradientStart = thisLineTop;\n\n                // Handle case where last & this line overlap\n                if (i > 0 && lastLineBottom > thisLineTop)\n                {\n                    thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;\n                }\n\n                const thisLineBottom = thisLineTop + textHeight;\n                const nextLineTop = metrics.lineHeight * (i + 1);\n                let thisLineGradientEnd = thisLineBottom;\n\n                // Handle case where this & next line overlap\n                if (i + 1 < lines.length && nextLineTop < thisLineBottom)\n                {\n                    thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;\n                }\n\n                // textHeight, but as a 0-1 size in global gradient stop space\n                const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n\n                for (let j = 0; j < fill.length; j++)\n                {\n                    // 0-1 stop point for the current line, multiplied to global space afterwards\n                    let lineStop = 0;\n\n                    if (typeof fillGradientStops[j] === 'number')\n                    {\n                        lineStop = fillGradientStops[j];\n                    }\n                    else\n                    {\n                        lineStop = j / fill.length;\n                    }\n\n                    let globalStop = Math.min(1, Math.max(0,\n                        (thisLineGradientStart / height) + (lineStop * gradStopLineHeight)));\n\n                    // There's potential for floating point precision issues at the seams between gradient repeats.\n                    globalStop = Number(globalStop.toFixed(5));\n                    gradient.addColorStop(globalStop, fill[j]);\n                }\n            }\n        }\n        else\n        {\n            // start the gradient at the center left of the canvas, and end at the center right of the canvas\n            gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n\n            // can just evenly space out the gradients in this case, as multiple lines makes no difference\n            // to an even left to right gradient\n            const totalIterations = fill.length + 1;\n            let currentIteration = 1;\n\n            for (let i = 0; i < fill.length; i++)\n            {\n                let stop: number;\n\n                if (typeof fillGradientStops[i] === 'number')\n                {\n                    stop = fillGradientStops[i];\n                }\n                else\n                {\n                    stop = currentIteration / totalIterations;\n                }\n                gradient.addColorStop(stop, fill[i]);\n                currentIteration++;\n            }\n        }\n\n        return gradient;\n    }\n\n    /**\n     * Destroys this text object.\n     *\n     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n     * the majority of the time the texture will not be shared with any other Sprites.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        if (typeof options === 'boolean')\n        {\n            options = { children: options };\n        }\n\n        options = Object.assign({}, defaultDestroyOptions, options);\n\n        super.destroy(options);\n\n        // set canvas width and height to 0 to workaround memory leak in Safari < 13\n        // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12\n        if (this._ownCanvas)\n        {\n            this.canvas.height = this.canvas.width = 0;\n        }\n\n        // make sure to reset the context and canvas.. dont want this hanging around in memory!\n        this.context = null;\n        this.canvas = null;\n\n        this._style = null;\n    }\n\n    /** The width of the Text, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value: number)\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /** The height of the Text, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value: number)\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     *\n     * If setting the `style` can also be partial {@link PIXI.ITextStyle}.\n     */\n    get style(): TextStyle\n    {\n        return this._style;\n    }\n\n    set style(style: TextStyle | Partial<ITextStyle>)\n    {\n        style = style || {};\n\n        if (style instanceof TextStyle)\n        {\n            this._style = style;\n        }\n        else\n        {\n            this._style = new TextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    get text(): string\n    {\n        return this._text;\n    }\n\n    set text(text: string | number)\n    {\n        text = String(text === null || text === undefined ? '' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n}\n", "export { TEXT_GRADIENT } from './const.mjs';\nexport { Text } from './Text.mjs';\nexport { TextMetrics } from './TextMetrics.mjs';\nexport { TextStyle } from './TextStyle.mjs';\n//# sourceMappingURL=index.mjs.map\n", "/* eslint-disable max-len */\n\n/**\n * Normalized parsed data from .fnt files.\n * @memberof PIXI\n */\nexport class BitmapFontData\n{\n    /** @readonly */\n    public info: IBitmapFontDataInfo[];\n\n    /** @readonly */\n    public common: IBitmapFontDataCommon[];\n\n    /** @readonly */\n    public page: IBitmapFontDataPage[];\n\n    /** @readonly */\n    public char: IBitmapFontDataChar[];\n\n    /** @readonly */\n    public kerning: IBitmapFontDataKerning[];\n\n    /** @readonly */\n    public distanceField: IBitmapFontDataDistanceField[];\n\n    constructor()\n    {\n        this.info = [];\n        this.common = [];\n        this.page = [];\n        this.char = [];\n        this.kerning = [];\n        this.distanceField = [];\n    }\n}\n\n/** @memberof PIXI */\nexport interface IBitmapFontDataInfo\n{\n    /** Font face */\n    face: string;\n\n    /** Font size */\n    size: number;\n}\n\n/** @memberof PIXI */\nexport interface IBitmapFontDataCommon\n{\n    /** Line height, in pixels. */\n    lineHeight: number;\n}\n\n/** @memberof PIXI */\nexport interface IBitmapFontDataPage\n{\n    /** Unique id for bitmap texture */\n    id: number;\n\n    /** File name */\n    file: string;\n}\n\n/** @memberof PIXI */\nexport interface IBitmapFontDataChar\n{\n    /** Unique id of character */\n    id: number;\n\n    /** {@link PIXI.IBitmapFontDataPage} id */\n    page: number;\n\n    /** x-position of character in page. */\n    x: number;\n\n    /** y-position of character in page. */\n    y: number;\n\n    /** Width of character in page. */\n    width: number;\n\n    /** Height of character in page. */\n    height: number;\n\n    /** x-offset to apply when rendering character */\n    xoffset: number;\n\n    /** y-offset to apply when rendering character. */\n    yoffset: number;\n\n    /** Advancement to apply to next character. */\n    xadvance: number;\n}\n\n/** @memberof PIXI */\nexport interface IBitmapFontDataKerning\n{\n    /** First character of pair */\n    first: number;\n\n    /** Second character of pair */\n    second: number;\n\n    /** x-offset to apply between first & second characters when they are next to each other. */\n    amount: number;\n}\n\n/** @memberof PIXI */\nexport interface IBitmapFontDataDistanceField\n{\n    /** Type of distance field */\n    fieldType: string;\n\n    /** Range of distance */\n    distanceRange: number;\n}\n", "import { BitmapFontData } from '../BitmapFontData';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface IBitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string;\n        page: string;\n        x: string;\n        y: string;\n        width: string;\n        height: string;\n        xoffset: string;\n        yoffset: string;\n        xadvance: string;\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: string;\n        distanceRange: string;\n    }[]\n}\n\n/**\n * BitmapFont format that's Text-based.\n * @private\n */\nexport class TextFormat\n{\n    /**\n     * Check if resource refers to txt font data.\n     * @param data\n     * @returns - True if resource could be treated as font data, false otherwise.\n     */\n    static test(data: unknown): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    }\n\n    /**\n     * Convert text font data to a javascript object.\n     * @param txt - Raw string data to be converted\n     * @returns - Parsed font data\n     */\n    static parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: IBitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font = new BitmapFontData();\n\n        rawData.info.forEach((info) => font.info.push({\n            face: info.face,\n            size: parseInt(info.size, 10),\n        }));\n\n        rawData.common.forEach((common) => font.common.push({\n            lineHeight: parseInt(common.lineHeight, 10),\n        }));\n\n        rawData.page.forEach((page) => font.page.push({\n            id: parseInt(page.id, 10),\n            file: page.file,\n        }));\n\n        rawData.char.forEach((char) => font.char.push({\n            id: parseInt(char.id, 10),\n            page: parseInt(char.page, 10),\n            x: parseInt(char.x, 10),\n            y: parseInt(char.y, 10),\n            width: parseInt(char.width, 10),\n            height: parseInt(char.height, 10),\n            xoffset: parseInt(char.xoffset, 10),\n            yoffset: parseInt(char.yoffset, 10),\n            xadvance: parseInt(char.xadvance, 10),\n        }));\n\n        rawData.kerning.forEach((kerning) => font.kerning.push({\n            first: parseInt(kerning.first, 10),\n            second: parseInt(kerning.second, 10),\n            amount: parseInt(kerning.amount, 10),\n        }));\n\n        rawData.distanceField.forEach((df) => font.distanceField.push({\n            distanceRange: parseInt(df.distanceRange, 10),\n            fieldType: df.fieldType,\n        }));\n\n        return font;\n    }\n}\n", "import { BitmapFontData } from '../BitmapFontData';\n\n/**\n * BitmapFont format that's XML-based.\n * @private\n */\nexport class XMLFormat\n{\n    /**\n     * Check if resource refers to xml font data.\n     * @param data\n     * @returns - True if resource could be treated as font data, false otherwise.\n     */\n    static test(data: unknown): boolean\n    {\n        const xml = data as Document;\n\n        return 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    }\n\n    /**\n     * Convert the XML into BitmapFontData that we can use.\n     * @param xml\n     * @returns - Data to use for BitmapFont\n     */\n    static parse(xml: Document): BitmapFontData\n    {\n        const data = new BitmapFontData();\n        const info = xml.getElementsByTagName('info');\n        const common = xml.getElementsByTagName('common');\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n        const distanceField = xml.getElementsByTagName('distanceField');\n\n        for (let i = 0; i < info.length; i++)\n        {\n            data.info.push({\n                face: info[i].getAttribute('face'),\n                size: parseInt(info[i].getAttribute('size'), 10),\n            });\n        }\n\n        for (let i = 0; i < common.length; i++)\n        {\n            data.common.push({\n                lineHeight: parseInt(common[i].getAttribute('lineHeight'), 10),\n            });\n        }\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.page.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const letter = char[i];\n\n            data.char.push({\n                id: parseInt(letter.getAttribute('id'), 10),\n                page: parseInt(letter.getAttribute('page'), 10) || 0,\n                x: parseInt(letter.getAttribute('x'), 10),\n                y: parseInt(letter.getAttribute('y'), 10),\n                width: parseInt(letter.getAttribute('width'), 10),\n                height: parseInt(letter.getAttribute('height'), 10),\n                xoffset: parseInt(letter.getAttribute('xoffset'), 10),\n                yoffset: parseInt(letter.getAttribute('yoffset'), 10),\n                xadvance: parseInt(letter.getAttribute('xadvance'), 10),\n            });\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            data.kerning.push({\n                first: parseInt(kerning[i].getAttribute('first'), 10),\n                second: parseInt(kerning[i].getAttribute('second'), 10),\n                amount: parseInt(kerning[i].getAttribute('amount'), 10),\n            });\n        }\n\n        for (let i = 0; i < distanceField.length; i++)\n        {\n            data.distanceField.push({\n                fieldType: distanceField[i].getAttribute('fieldType'),\n                distanceRange: parseInt(distanceField[i].getAttribute('distanceRange'), 10),\n            });\n        }\n\n        return data;\n    }\n}\n", "import { settings } from '@pixi/core';\nimport { XMLFormat } from './XMLFormat';\n\nimport type { BitmapFontData } from '../BitmapFontData';\n\n/**\n * BitmapFont format that's XML-based.\n * @private\n */\nexport class XMLStringFormat\n{\n    /**\n     * Check if resource refers to text xml font data.\n     * @param data\n     * @returns - True if resource could be treated as font data, false otherwise.\n     */\n    static test(data: unknown): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return XMLFormat.test(settings.ADAPTER.parseXML(data));\n        }\n\n        return false;\n    }\n\n    /**\n     * Convert the text XML into BitmapFontData that we can use.\n     * @param xmlTxt\n     * @returns - Data to use for BitmapFont\n     */\n    static parse(xmlTxt: string): BitmapFontData\n    {\n        return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));\n    }\n}\n", "import { TextFormat } from './TextFormat';\nimport { XMLFormat } from './XMLFormat';\nimport { XMLStringFormat } from './XMLStringFormat';\n\n// Registered formats, maybe make this extensible in the future?\nconst formats = [\n    TextFormat,\n    XMLFormat,\n    XMLStringFormat,\n] as const;\n\n/**\n * Auto-detect BitmapFont parsing format based on data.\n * @private\n * @param {any} data - Data to detect format\n * @returns {any} Format or null\n */\nexport function autoDetectFormat(data: unknown): typeof formats[number] | null\n{\n    for (let i = 0; i < formats.length; i++)\n    {\n        if (formats[i].test(data))\n        {\n            return formats[i];\n        }\n    }\n\n    return null;\n}\n\nexport type { IBitmapFontRawData } from './TextFormat';\nexport { TextFormat, XMLFormat, XMLStringFormat };\n", "import { TEXT_GRADIENT } from '@pixi/text';\n\nimport type { ICanvas, ICanvasRenderingContext2D } from '@pixi/core';\nimport type { TextMetrics, TextStyle } from '@pixi/text';\n\n// TODO: Prevent code duplication b/w generateFillStyle & Text#generateFillStyle\n\n/**\n * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n * @private\n * @param canvas\n * @param context\n * @param {object} style - The style.\n * @param resolution\n * @param {string[]} lines - The lines of text.\n * @param metrics\n * @returns {string|number|CanvasGradient} The fill style\n */\nexport function generateFillStyle(\n    canvas: ICanvas,\n    context: ICanvasRenderingContext2D,\n    style: TextStyle,\n    resolution: number,\n    lines: string[],\n    metrics: TextMetrics\n): string | CanvasGradient | CanvasPattern\n{\n    // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n    //       the setter converts to string. See this thread for more details:\n    //       https://github.com/microsoft/TypeScript/issues/2521\n    const fillStyle: string | string[] | CanvasGradient | CanvasPattern = style.fill as any;\n\n    if (!Array.isArray(fillStyle))\n    {\n        return fillStyle;\n    }\n    else if (fillStyle.length === 1)\n    {\n        return fillStyle[0];\n    }\n\n    // the gradient will be evenly spaced out according to how large the array is.\n    // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n    let gradient: string[] | CanvasGradient;\n\n    // a dropshadow will enlarge the canvas and result in the gradient being\n    // generated with the incorrect dimensions\n    const dropShadowCorrection = (style.dropShadow) ? style.dropShadowDistance : 0;\n\n    // should also take padding into account, padding can offset the gradient\n    const padding = style.padding || 0;\n\n    const width = (canvas.width / resolution) - dropShadowCorrection - (padding * 2);\n    const height = (canvas.height / resolution) - dropShadowCorrection - (padding * 2);\n\n    // make a copy of the style settings, so we can manipulate them later\n    const fill = fillStyle.slice();\n    const fillGradientStops = style.fillGradientStops.slice();\n\n    // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n    if (!fillGradientStops.length)\n    {\n        const lengthPlus1 = fill.length + 1;\n\n        for (let i = 1; i < lengthPlus1; ++i)\n        {\n            fillGradientStops.push(i / lengthPlus1);\n        }\n    }\n\n    // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n    // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n    fill.unshift(fillStyle[0]);\n    fillGradientStops.unshift(0);\n\n    fill.push(fillStyle[fillStyle.length - 1]);\n    fillGradientStops.push(1);\n\n    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)\n    {\n        // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n        gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n\n        // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n        // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n\n        // There's potential for floating point precision issues at the seams between gradient repeats.\n        // The loop below generates the stops in order, so track the last generated one to prevent\n        // floating point precision from making us go the teeniest bit backwards, resulting in\n        // the first and last colors getting swapped.\n        let lastIterationStop = 0;\n\n        // Actual height of the text itself, not counting spacing for lineHeight/leading/dropShadow etc\n        const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n\n        // textHeight, but as a 0-1 size in global gradient stop space\n        const gradStopLineHeight = textHeight / height;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const thisLineTop = metrics.lineHeight * i;\n\n            for (let j = 0; j < fill.length; j++)\n            {\n                // 0-1 stop point for the current line, multiplied to global space afterwards\n                let lineStop = 0;\n\n                if (typeof fillGradientStops[j] === 'number')\n                {\n                    lineStop = fillGradientStops[j];\n                }\n                else\n                {\n                    lineStop = j / fill.length;\n                }\n\n                const globalStop = (thisLineTop / height) + (lineStop * gradStopLineHeight);\n\n                // Prevent color stop generation going backwards from floating point imprecision\n                let clampedStop = Math.max(lastIterationStop, globalStop);\n\n                clampedStop = Math.min(clampedStop, 1); // Cap at 1 as well for safety's sake to avoid a possible throw.\n                gradient.addColorStop(clampedStop, fill[j]);\n                lastIterationStop = clampedStop;\n            }\n        }\n    }\n    else\n    {\n        // start the gradient at the center left of the canvas, and end at the center right of the canvas\n        gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n\n        // can just evenly space out the gradients in this case, as multiple lines makes no difference\n        // to an even left to right gradient\n        const totalIterations = fill.length + 1;\n        let currentIteration = 1;\n\n        for (let i = 0; i < fill.length; i++)\n        {\n            let stop: number;\n\n            if (typeof fillGradientStops[i] === 'number')\n            {\n                stop = fillGradientStops[i];\n            }\n            else\n            {\n                stop = currentIteration / totalIterations;\n            }\n            gradient.addColorStop(stop, fill[i]);\n            currentIteration++;\n        }\n    }\n\n    return gradient;\n}\n", "import { Color } from '@pixi/core';\nimport { generateFillStyle } from './generateFillStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2D } from '@pixi/core';\nimport type { TextMetrics, TextStyle } from '@pixi/text';\n\n// TODO: Prevent code duplication b/w drawGlyph & Text#updateText\n\n/**\n * Draws the glyph `metrics.text` on the given canvas.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {PIXI.ICanvas} canvas\n * @param {PIXI.ICanvasRenderingContext2D} context\n * @param {TextMetrics} metrics\n * @param {number} x\n * @param {number} y\n * @param {number} resolution\n * @param {TextStyle} style\n */\nexport function drawGlyph(\n    canvas: ICanvas,\n    context: ICanvasRenderingContext2D,\n    metrics: TextMetrics,\n    x: number,\n    y: number,\n    resolution: number,\n    style: TextStyle\n): void\n{\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n\n    context.translate(x, y);\n    context.scale(resolution, resolution);\n\n    const tx = style.strokeThickness / 2;\n    const ty = -(style.strokeThickness / 2);\n\n    context.font = style.toFontString();\n    context.lineWidth = style.strokeThickness;\n    context.textBaseline = style.textBaseline;\n    context.lineJoin = style.lineJoin;\n    context.miterLimit = style.miterLimit;\n\n    // set canvas text styles\n    context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);\n    context.strokeStyle = style.stroke as string;\n\n    if (style.dropShadow)\n    {\n        const dropShadowColor = style.dropShadowColor;\n        const dropShadowBlur = style.dropShadowBlur * resolution;\n        const dropShadowDistance = style.dropShadowDistance * resolution;\n\n        context.shadowColor = Color.shared\n            .setValue(dropShadowColor)\n            .setAlpha(style.dropShadowAlpha)\n            .toRgbaString();\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;\n    }\n    else\n    {\n        context.shadowColor = 'black';\n        context.shadowBlur = 0;\n        context.shadowOffsetX = 0;\n        context.shadowOffsetY = 0;\n    }\n\n    if (style.stroke && style.strokeThickness)\n    {\n        context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n    }\n    if (style.fill)\n    {\n        context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n    }\n\n    context.setTransform(1, 0, 0, 1, 0, 0); // defaults needed for older browsers (e.g. Opera 29)\n\n    context.fillStyle = 'rgba(0, 0, 0, 0)';\n}\n", "/**\n * Ponyfill for IE because it doesn't support `codePointAt`\n * @param str\n * @private\n */\nexport function extractCharCode(str: string): number\n{\n    return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);\n}\n", "/**\n * Ponyfill for IE because it doesn't support `Array.from`\n * @param text\n * @private\n */\nexport function splitTextToCharacters(text: string): string[]\n{\n    return Array.from ? Array.from(text) : text.split('');\n}\n", "import { splitTextToCharacters } from './splitTextToCharacters';\n\n/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        // Handle a character set string\n        else\n        {\n            result.push(...splitTextToCharacters(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n", "export { drawGlyph } from './drawGlyph.mjs';\nexport { extractCharCode } from './extractCharCode.mjs';\nexport { generateFillStyle } from './generateFillStyle.mjs';\nexport { resolveCharacters } from './resolveCharacters.mjs';\nexport { splitTextToCharacters } from './splitTextToCharacters.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { ALPHA_MODES, BaseTexture, MIPMAP_MODES, Rectangle, settings, Texture, utils } from '@pixi/core';\nimport { TextMetrics, TextStyle } from '@pixi/text';\nimport { BitmapFontData } from './BitmapFontData';\nimport { autoDetectFormat } from './formats';\nimport { drawGlyph, extractCharCode, resolveCharacters } from './utils';\n\nimport type { IBaseTextureOptions, ICanvas, ICanvasRenderingContext2D, SCALE_MODES } from '@pixi/core';\nimport type { ITextStyle } from '@pixi/text';\n\nexport interface IBitmapFontCharacter\n{\n    xOffset: number;\n    yOffset: number;\n    xAdvance: number;\n    texture: Texture;\n    page: number;\n    kerning: utils.Dict<number>;\n}\n\ntype BaseOptions = Pick<IBaseTextureOptions, 'scaleMode' | 'mipmap' | 'anisotropicLevel' | 'alphaMode'>;\n\n/** @memberof PIXI */\nexport interface IBitmapFontOptions extends BaseOptions\n{\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default PIXI.BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n\n    /**\n     * Optional width of atlas, smaller values to reduce memory.\n     * @default 512\n     */\n    textureWidth?: number;\n\n    /**\n     * Optional height of atlas, smaller values to reduce memory.\n     * @default 512\n     */\n    textureHeight?: number;\n\n    /**\n     * If mipmapping is enabled for texture. For instance, by default PixiJS only enables mipmapping\n     * on Power-of-Two textures. If your textureWidth or textureHeight are not power-of-two, you\n     * may consider enabling mipmapping to get better quality with lower font sizes. Note:\n     * for MSDF/SDF fonts, mipmapping is not supported.\n     * @default PIXI.BaseTexture.defaultOptions.mipmap\n     */\n    mipmap?: MIPMAP_MODES;\n\n    /**\n     * Anisotropic filtering level of texture.\n     * @default PIXI.BaseTexture.defaultOptions.anisotropicLevel\n     */\n    anisotropicLevel?: number;\n\n    /**\n     * Default scale mode, linear, nearest. Nearest can be helpful for bitmap-style fonts.\n     * @default PIXI.BaseTexture.defaultOptions.scaleMode\n     */\n    scaleMode?: SCALE_MODES;\n\n    /**\n     * Pre multiply the image alpha.  Note: for MSDF/SDF fonts, alphaMode is not supported.\n     * @default PIXI.BaseTexture.defaultOptions.alphaMode\n     */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * BitmapFont represents a typeface available for use with the BitmapText class. Use the `install`\n * method for adding a font to be used.\n * @memberof PIXI\n */\nexport class BitmapFont\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public static readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public static readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public static readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public static readonly ASCII = [[' ', '~']];\n\n    /**\n     * Collection of default options when using `BitmapFont.from`.\n     * @property {number} [resolution=1] -\n     * @property {number} [textureWidth=512] -\n     * @property {number} [textureHeight=512] -\n     * @property {number} [padding=4] -\n     * @property {string|string[]|string[][]} chars = PIXI.BitmapFont.ALPHANUMERIC\n     */\n    public static readonly defaultOptions: IBitmapFontOptions = {\n        resolution: 1,\n        textureWidth: 512,\n        textureHeight: 512,\n        padding: 4,\n        chars: BitmapFont.ALPHANUMERIC,\n    };\n\n    /** Collection of available/installed fonts. */\n    public static readonly available: utils.Dict<BitmapFont> = {};\n\n    /** The name of the font face. */\n    public readonly font: string;\n\n    /** The size of the font face in pixels. */\n    public readonly size: number;\n\n    /** The line-height of the font face in pixels. */\n    public readonly lineHeight: number;\n\n    /** The map of characters by character code. */\n    public readonly chars: utils.Dict<IBitmapFontCharacter>;\n\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pageTextures: utils.Dict<Texture>;\n\n    /** The range of the distance field in pixels. */\n    public readonly distanceFieldRange: number;\n\n    /** The kind of distance field for this font or \"none\". */\n    public readonly distanceFieldType: string;\n\n    private _ownsTextures: boolean;\n\n    /**\n     * @param data\n     * @param textures\n     * @param ownsTextures - Setting to `true` will destroy page textures\n     *        when the font is uninstalled.\n     */\n    constructor(data: BitmapFontData, textures: Texture[] | utils.Dict<Texture>, ownsTextures?: boolean)\n    {\n        const [info] = data.info;\n        const [common] = data.common;\n        const [page] = data.page;\n        const [distanceField] = data.distanceField;\n        const res = utils.getResolutionOfUrl(page.file);\n        const pageTextures: utils.Dict<Texture> = {};\n\n        this._ownsTextures = ownsTextures;\n        this.font = info.face;\n        this.size = info.size;\n        this.lineHeight = common.lineHeight / res;\n        this.chars = {};\n        this.pageTextures = pageTextures;\n\n        // Convert the input Texture, Textures or object\n        // into a page Texture lookup by \"id\"\n        for (let i = 0; i < data.page.length; i++)\n        {\n            const { id, file } = data.page[i];\n\n            pageTextures[id] = textures instanceof Array\n                ? textures[i] : textures[file];\n\n            // only MSDF and SDF fonts need no-premultiplied-alpha\n            if (distanceField?.fieldType && distanceField.fieldType !== 'none')\n            {\n                pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;\n                pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;\n            }\n        }\n\n        // parse letters\n        for (let i = 0; i < data.char.length; i++)\n        {\n            const { id, page } = data.char[i];\n            let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];\n\n            x /= res;\n            y /= res;\n            width /= res;\n            height /= res;\n            xoffset /= res;\n            yoffset /= res;\n            xadvance /= res;\n\n            const rect = new Rectangle(\n                x + (pageTextures[page].frame.x / res),\n                y + (pageTextures[page].frame.y / res),\n                width,\n                height\n            );\n\n            this.chars[id] = {\n                xOffset: xoffset,\n                yOffset: yoffset,\n                xAdvance: xadvance,\n                kerning: {},\n                texture: new Texture(\n                    pageTextures[page].baseTexture,\n                    rect\n                ),\n                page,\n            };\n        }\n\n        // parse kernings\n        for (let i = 0; i < data.kerning.length; i++)\n        {\n            let { first, second, amount } = data.kerning[i];\n\n            first /= res;\n            second /= res;\n            amount /= res;\n\n            if (this.chars[second])\n            {\n                this.chars[second].kerning[first] = amount;\n            }\n        }\n\n        // Store distance field information\n        this.distanceFieldRange = distanceField?.distanceRange;\n        this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? 'none';\n    }\n\n    /** Remove references to created glyph textures. */\n    public destroy(): void\n    {\n        for (const id in this.chars)\n        {\n            this.chars[id].texture.destroy();\n            this.chars[id].texture = null;\n        }\n\n        for (const id in this.pageTextures)\n        {\n            if (this._ownsTextures)\n            {\n                this.pageTextures[id].destroy(true);\n            }\n\n            this.pageTextures[id] = null;\n        }\n\n        // Set readonly null.\n        (this as any).chars = null;\n        (this as any).pageTextures = null;\n    }\n\n    /**\n     * Register a new bitmap font.\n     * @param data - The\n     *        characters map that could be provided as xml or raw string.\n     * @param textures - List of textures for each page.\n     * @param ownsTextures - Set to `true` to destroy page textures\n     *        when the font is uninstalled. By default fonts created with\n     *        `BitmapFont.from` or from the `BitmapFontLoader` are `true`.\n     * @returns {PIXI.BitmapFont} Result font object with font, size, lineHeight\n     *         and char fields.\n     */\n    public static install(\n        data: string | XMLDocument | BitmapFontData,\n        textures: Texture | Texture[] | utils.Dict<Texture>,\n        ownsTextures?: boolean\n    ): BitmapFont\n    {\n        let fontData;\n\n        if (data instanceof BitmapFontData)\n        {\n            fontData = data;\n        }\n        else\n        {\n            const format = autoDetectFormat(data);\n\n            if (!format)\n            {\n                throw new Error('Unrecognized data format for font.');\n            }\n\n            fontData = format.parse(data as any);\n        }\n\n        // Single texture, convert to list\n        if (textures instanceof Texture)\n        {\n            textures = [textures];\n        }\n\n        const font = new BitmapFont(fontData, textures, ownsTextures);\n\n        BitmapFont.available[font.font] = font;\n\n        return font;\n    }\n\n    /**\n     * Remove bitmap font by name.\n     * @param name - Name of the font to uninstall.\n     */\n    public static uninstall(name: string): void\n    {\n        const font = BitmapFont.available[name];\n\n        if (!font)\n        {\n            throw new Error(`No font found named '${name}'`);\n        }\n\n        font.destroy();\n        delete BitmapFont.available[name];\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set. This does not support\n     * kernings yet. With `style` properties, only the following non-layout properties are used:\n     *\n     * - {@link PIXI.TextStyle#dropShadow|dropShadow}\n     * - {@link PIXI.TextStyle#dropShadowDistance|dropShadowDistance}\n     * - {@link PIXI.TextStyle#dropShadowColor|dropShadowColor}\n     * - {@link PIXI.TextStyle#dropShadowBlur|dropShadowBlur}\n     * - {@link PIXI.TextStyle#dropShadowAngle|dropShadowAngle}\n     * - {@link PIXI.TextStyle#fill|fill}\n     * - {@link PIXI.TextStyle#fillGradientStops|fillGradientStops}\n     * - {@link PIXI.TextStyle#fillGradientType|fillGradientType}\n     * - {@link PIXI.TextStyle#fontFamily|fontFamily}\n     * - {@link PIXI.TextStyle#fontSize|fontSize}\n     * - {@link PIXI.TextStyle#fontVariant|fontVariant}\n     * - {@link PIXI.TextStyle#fontWeight|fontWeight}\n     * - {@link PIXI.TextStyle#lineJoin|lineJoin}\n     * - {@link PIXI.TextStyle#miterLimit|miterLimit}\n     * - {@link PIXI.TextStyle#stroke|stroke}\n     * - {@link PIXI.TextStyle#strokeThickness|strokeThickness}\n     * - {@link PIXI.TextStyle#textBaseline|textBaseline}\n     * @param name - The name of the custom font to use with BitmapText.\n     * @param textStyle - Style options to render with BitmapFont.\n     * @param options - Setup options for font or name of the font.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.from('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText('This is the title', { fontName: 'TitleFont' });\n     */\n    public static from(name: string, textStyle?: TextStyle | Partial<ITextStyle>, options?: IBitmapFontOptions): BitmapFont\n    {\n        if (!name)\n        {\n            throw new Error('[BitmapFont] Property `name` is required.');\n        }\n\n        const {\n            chars,\n            padding,\n            resolution,\n            textureWidth,\n            textureHeight,\n            ...baseOptions\n        } = Object.assign({}, BitmapFont.defaultOptions, options);\n\n        const charsList = resolveCharacters(chars);\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const lineWidth = textureWidth;\n        const fontData = new BitmapFontData();\n\n        fontData.info[0] = {\n            face: style.fontFamily as string,\n            size: style.fontSize as number,\n        };\n        fontData.common[0] = {\n            lineHeight: style.fontSize as number,\n        };\n\n        let positionX = 0;\n        let positionY = 0;\n\n        let canvas: ICanvas;\n        let context: ICanvasRenderingContext2D;\n        let baseTexture: BaseTexture;\n        let maxCharHeight = 0;\n        const baseTextures: BaseTexture[] = [];\n        const textures: Texture[] = [];\n\n        for (let i = 0; i < charsList.length; i++)\n        {\n            if (!canvas)\n            {\n                canvas = settings.ADAPTER.createCanvas();\n                canvas.width = textureWidth;\n                canvas.height = textureHeight;\n\n                context = canvas.getContext('2d');\n                baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions });\n\n                baseTextures.push(baseTexture);\n                textures.push(new Texture(baseTexture));\n\n                fontData.page.push({\n                    id: textures.length - 1,\n                    file: '',\n                });\n            }\n\n            // Measure glyph dimensions\n            const character = charsList[i];\n            const metrics = TextMetrics.measureText(character, style, false, canvas);\n            const width = metrics.width;\n            const height = Math.ceil(metrics.height);\n\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            // Can't fit char anymore: next canvas please!\n            if (positionY >= textureHeight - (height * resolution))\n            {\n                if (positionY === 0)\n                {\n                    // We don't want user debugging an infinite loop (or do we? :)\n                    throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small `\n                        + `(fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);\n                }\n\n                --i;\n\n                // Create new atlas once current has filled up\n                canvas = null;\n                context = null;\n                baseTexture = null;\n                positionY = 0;\n                positionX = 0;\n                maxCharHeight = 0;\n\n                continue;\n            }\n\n            maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);\n\n            // Wrap line once full row has been rendered\n            if ((textureGlyphWidth * resolution) + positionX >= lineWidth)\n            {\n                if (positionX === 0)\n                {\n                    // Avoid infinite loop (There can be some very wide char like '\\uFDFD'!)\n                    throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small `\n                        + `(fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);\n                }\n\n                --i;\n                positionY += maxCharHeight * resolution;\n                positionY = Math.ceil(positionY);\n                positionX = 0;\n                maxCharHeight = 0;\n\n                continue;\n            }\n\n            drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);\n\n            // Unique (numeric) ID mapping to this glyph\n            const id = extractCharCode(metrics.text);\n\n            // Create a texture holding just the glyph\n            fontData.char.push({\n                id,\n                page: textures.length - 1,\n                x: positionX / resolution,\n                y: positionY / resolution,\n                width: textureGlyphWidth,\n                height,\n                xoffset: 0,\n                yoffset: 0,\n                xadvance: width\n                        - (style.dropShadow ? style.dropShadowDistance : 0)\n                        - (style.stroke ? style.strokeThickness : 0),\n            });\n\n            positionX += (textureGlyphWidth + (2 * padding)) * resolution;\n            positionX = Math.ceil(positionX);\n        }\n\n        // Brute-force kerning info, this can be expensive b/c it's an O(n²),\n        // but we're using measureText which is native and fast.\n        for (let i = 0, len = charsList.length; i < len; i++)\n        {\n            const first = charsList[i];\n\n            for (let j = 0; j < len; j++)\n            {\n                const second = charsList[j];\n                const c1 = context.measureText(first).width;\n                const c2 = context.measureText(second).width;\n                const total = context.measureText(first + second).width;\n                const amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    fontData.kerning.push({\n                        first: extractCharCode(first),\n                        second: extractCharCode(second),\n                        amount,\n                    });\n                }\n            }\n        }\n\n        const font = new BitmapFont(fontData, textures, true);\n\n        // Make it easier to replace a font\n        if (BitmapFont.available[name] !== undefined)\n        {\n            BitmapFont.uninstall(name);\n        }\n\n        BitmapFont.available[name] = font;\n\n        return font;\n    }\n}\n", "import type { Buffer, TextureMatrix } from '@pixi/core';\n\n/**\n * Class controls cache for UV mapping from Texture normal space to BaseTexture normal space.\n * @memberof PIXI\n */\nexport class MeshBatchUvs\n{\n    /** UV Buffer data. */\n    public readonly data: Float32Array;\n\n    /** Buffer with normalized UV's. */\n    public uvBuffer: Buffer;\n\n    /** Material UV matrix. */\n    public uvMatrix: TextureMatrix;\n\n    private _bufferUpdateId: number;\n    private _textureUpdateId: number;\n\n    // Internal-only properties\n    _updateID: number;\n\n    /**\n     * @param uvBuffer - Buffer with normalized uv's\n     * @param uvMatrix - Material UV matrix\n     */\n    constructor(uvBuffer: Buffer, uvMatrix: TextureMatrix)\n    {\n        this.uvBuffer = uvBuffer;\n        this.uvMatrix = uvMatrix;\n        this.data = null;\n\n        this._bufferUpdateId = -1;\n        this._textureUpdateId = -1;\n        this._updateID = 0;\n    }\n\n    /**\n     * Updates\n     * @param forceUpdate - force the update\n     */\n    public update(forceUpdate?: boolean): void\n    {\n        if (!forceUpdate\n            && this._bufferUpdateId === this.uvBuffer._updateID\n            && this._textureUpdateId === this.uvMatrix._updateID\n        )\n        {\n            return;\n        }\n\n        this._bufferUpdateId = this.uvBuffer._updateID;\n        this._textureUpdateId = this.uvMatrix._updateID;\n\n        const data = this.uvBuffer.data as Float32Array;\n\n        if (!this.data || this.data.length !== data.length)\n        {\n            (this.data as any) = new Float32Array(data.length);\n        }\n\n        this.uvMatrix.multiplyUvs(data, this.data);\n\n        this._updateID++;\n    }\n}\n", "import { DRAW_MODES, Point, Polygon, settings, State } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { MeshBatchUvs } from './MeshBatchUvs';\n\nimport type { BLEND_MODES, Buffer, ColorSource, Geometry, IPointData, Renderer, Shader, Texture } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { MeshMaterial } from './MeshMaterial';\n\nconst tempPoint = new Point();\nconst tempPolygon = new Polygon();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Mesh extends GlobalMixins.Mesh {}\n\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL visuals you can think of.\n * This class assumes a certain level of WebGL knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof PIXI\n */\nexport class Mesh<T extends Shader = MeshMaterial> extends Container\n{\n    /**\n     * Used by the @pixi/canvas-mesh package to draw meshes using canvas.\n     * Added here because we cannot mixin a static property to Mesh type.\n     * @ignore\n     */\n    public static defaultCanvasPadding: number;\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     * @type {PIXI.Shader|PIXI.MeshMaterial}\n     */\n    public shader: T;\n\n    /**\n     * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    public state: State;\n\n    /** The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants. */\n    public drawMode: DRAW_MODES;\n\n    /**\n     * Typically the index of the IndexBuffer where to start drawing.\n     * @default 0\n     */\n    public start: number;\n\n    /**\n     * How much of the geometry to draw, by default `0` renders everything.\n     * @default 0\n     */\n    public size: number;\n\n    private _geometry: Geometry;\n\n    /** This is the caching layer used by the batcher. */\n    private vertexData: Float32Array;\n\n    /** If geometry is changed used to decide to re-transform the vertexData. */\n    private vertexDirty: number;\n    private _transformID: number;\n\n    /** Internal roundPixels field. */\n    private _roundPixels: boolean;\n\n    /** Batched UV's are cached for atlas textures. */\n    private batchUvs: MeshBatchUvs;\n\n    // Internal-only properties\n    /**\n     * These are used as easy access for batching.\n     * @private\n     */\n    uvs: Float32Array;\n\n    /**\n     * These are used as easy access for batching.\n     * @private\n     */\n    indices: Uint16Array;\n    _tintRGB: number;\n    _texture: Texture;\n\n    /**\n     * @param geometry - The geometry the mesh will use.\n     * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.\n     * @param state - The state that the WebGL context is required to be in to render the mesh\n     *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.\n     * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.\n     */\n    constructor(geometry: Geometry, shader: T, state?: State, drawMode: DRAW_MODES = DRAW_MODES.TRIANGLES)\n    {\n        super();\n\n        this.geometry = geometry;\n        this.shader = shader;\n        this.state = state || State.for2d();\n        this.drawMode = drawMode;\n        this.start = 0;\n        this.size = 0;\n\n        this.uvs = null;\n        this.indices = null;\n        this.vertexData = new Float32Array(1);\n        this.vertexDirty = -1;\n\n        this._transformID = -1;\n        this._roundPixels = settings.ROUND_PIXELS;\n        this.batchUvs = null;\n    }\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    get geometry(): Geometry\n    {\n        return this._geometry;\n    }\n\n    set geometry(value: Geometry)\n    {\n        if (this._geometry === value)\n        {\n            return;\n        }\n\n        if (this._geometry)\n        {\n            this._geometry.refCount--;\n\n            if (this._geometry.refCount === 0)\n            {\n                this._geometry.dispose();\n            }\n        }\n\n        this._geometry = value;\n\n        if (this._geometry)\n        {\n            this._geometry.refCount++;\n        }\n\n        this.vertexDirty = -1;\n    }\n\n    /**\n     * To change mesh uv's, change its uvBuffer data and increment its _updateID.\n     * @readonly\n     */\n    get uvBuffer(): Buffer\n    {\n        return this.geometry.buffers[1];\n    }\n\n    /**\n     * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n     * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n     * @readonly\n     */\n    get verticesBuffer(): Buffer\n    {\n        return this.geometry.buffers[0];\n    }\n\n    /** Alias for {@link PIXI.Mesh#shader}. */\n    set material(value: T)\n    {\n        this.shader = value;\n    }\n\n    get material(): T\n    {\n        return this.shader;\n    }\n\n    /**\n     * The blend mode to be applied to the Mesh. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL;\n     */\n    set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default false\n     */\n    set roundPixels(value: boolean)\n    {\n        if (this._roundPixels !== value)\n        {\n            this._transformID = -1;\n        }\n        this._roundPixels = value;\n    }\n\n    get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    /**\n     * The multiply tint applied to the Mesh. This is a hex value. A value of\n     * `0xFFFFFF` will remove any tint effect.\n     *\n     * Null for non-MeshMaterial shaders\n     * @default 0xFFFFFF\n     */\n    get tint(): ColorSource\n    {\n        return 'tint' in this.shader ? (this.shader as unknown as MeshMaterial).tint : null;\n    }\n\n    set tint(value: ColorSource)\n    {\n        (this.shader as unknown as MeshMaterial).tint = value;\n    }\n\n    /**\n     * The tint color as a RGB integer\n     * @ignore\n     */\n    get tintValue(): number\n    {\n        return (this.shader as unknown as MeshMaterial).tintValue;\n    }\n\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    get texture(): Texture\n    {\n        return 'texture' in this.shader ? (this.shader as unknown as MeshMaterial).texture : null;\n    }\n\n    set texture(value: Texture)\n    {\n        (this.shader as unknown as MeshMaterial).texture = value;\n    }\n\n    /**\n     * Standard renderer draw.\n     * @param renderer - Instance to renderer.\n     */\n    protected _render(renderer: Renderer): void\n    {\n        // set properties for batching..\n        // TODO could use a different way to grab verts?\n        const vertices = this.geometry.buffers[0].data;\n        const shader = this.shader as unknown as MeshMaterial;\n\n        // TODO benchmark check for attribute size..\n        if (\n            shader.batchable\n            && this.drawMode === DRAW_MODES.TRIANGLES\n            && vertices.length < Mesh.BATCHABLE_SIZE * 2\n        )\n        {\n            this._renderToBatch(renderer);\n        }\n        else\n        {\n            this._renderDefault(renderer);\n        }\n    }\n\n    /**\n     * Standard non-batching way of rendering.\n     * @param renderer - Instance to renderer.\n     */\n    protected _renderDefault(renderer: Renderer): void\n    {\n        const shader = this.shader as unknown as MeshMaterial;\n\n        shader.alpha = this.worldAlpha;\n        if (shader.update)\n        {\n            shader.update();\n        }\n\n        renderer.batch.flush();\n\n        // bind and sync uniforms..\n        shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n        renderer.shader.bind(shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // bind the geometry...\n        renderer.geometry.bind(this.geometry, shader);\n\n        // then render it\n        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }\n\n    /**\n     * Rendering by using the Batch system.\n     * @param renderer - Instance to renderer.\n     */\n    protected _renderToBatch(renderer: Renderer): void\n    {\n        const geometry = this.geometry;\n        const shader = this.shader as unknown as MeshMaterial;\n\n        if (shader.uvMatrix)\n        {\n            shader.uvMatrix.update();\n            this.calculateUvs();\n        }\n\n        // set properties for batching..\n        this.calculateVertices();\n        this.indices = geometry.indexBuffer.data as Uint16Array;\n        this._tintRGB = shader._tintRGB;\n        this._texture = shader.texture;\n\n        const pluginName = (this.material as unknown as MeshMaterial).pluginName;\n\n        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n        renderer.plugins[pluginName].render(this);\n    }\n\n    /** Updates vertexData field based on transform and vertices. */\n    public calculateVertices(): void\n    {\n        const geometry = this.geometry;\n        const verticesBuffer = geometry.buffers[0];\n        const vertices = verticesBuffer.data;\n        const vertexDirtyId = verticesBuffer._updateID;\n\n        if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)\n        {\n            return;\n        }\n\n        this._transformID = this.transform._worldID;\n\n        if (this.vertexData.length !== vertices.length)\n        {\n            this.vertexData = new Float32Array(vertices.length);\n        }\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const vertexData = this.vertexData;\n\n        for (let i = 0; i < vertexData.length / 2; i++)\n        {\n            const x = vertices[(i * 2)];\n            const y = vertices[(i * 2) + 1];\n\n            vertexData[(i * 2)] = (a * x) + (c * y) + tx;\n            vertexData[(i * 2) + 1] = (b * x) + (d * y) + ty;\n        }\n\n        if (this._roundPixels)\n        {\n            const resolution = settings.RESOLUTION;\n\n            for (let i = 0; i < vertexData.length; ++i)\n            {\n                vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n            }\n        }\n\n        this.vertexDirty = vertexDirtyId;\n    }\n\n    /** Updates uv field based on from geometry uv's or batchUvs. */\n    public calculateUvs(): void\n    {\n        const geomUvs = this.geometry.buffers[1];\n        const shader = this.shader as unknown as MeshMaterial;\n\n        if (!shader.uvMatrix.isSimple)\n        {\n            if (!this.batchUvs)\n            {\n                this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n            }\n            this.batchUvs.update();\n            this.uvs = this.batchUvs.data;\n        }\n        else\n        {\n            this.uvs = geomUvs.data as Float32Array;\n        }\n    }\n\n    /**\n     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.\n     */\n    protected _calculateBounds(): void\n    {\n        this.calculateVertices();\n\n        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.\n     * @param point - The point to test.\n     * @returns - The result of the test.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.geometry.getBuffer('aVertexPosition').data;\n\n        const points = tempPolygon.points;\n        const indices = this.geometry.getIndex().data;\n        const len = indices.length;\n        const step = this.drawMode === 4 ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        if (this._cachedTexture)\n        {\n            this._cachedTexture.destroy();\n            this._cachedTexture = null;\n        }\n\n        this.geometry = null;\n        this.shader = null;\n        this.state = null;\n        this.uvs = null;\n        this.indices = null;\n        this.vertexData = null;\n    }\n\n    /** The maximum number of vertices to consider batchable. Generally, the complexity of the geometry. */\n    public static BATCHABLE_SIZE = 100;\n}\n", "import { Buffer, Geometry, TYPES } from '@pixi/core';\n\nimport type { IArrayBuffer } from '@pixi/core';\n\n/**\n * Standard 2D geometry used in PixiJS.\n *\n * Geometry can be defined without passing in a style or data if required.\n * @example\n * import { Geometry } from 'pixi.js';\n *\n * const geometry = new Geometry();\n *\n * geometry.addAttribute('positions', [0, 0, 100, 0, 100, 100, 0, 100], 2);\n * geometry.addAttribute('uvs', [0, 0, 1, 0, 1, 1, 0, 1], 2);\n * geometry.addIndex([0, 1, 2, 1, 3, 2]);\n * @memberof PIXI\n */\nexport class MeshGeometry extends Geometry\n{\n    // Internal-only properties\n    /**\n     * Dirty flag to limit update calls on Mesh. For example,\n     * limiting updates on a single Mesh instance with a shared Geometry\n     * within the render loop.\n     * @private\n     * @default -1\n     */\n    _updateId: number;\n\n    /**\n     * @param {Float32Array|number[]} [vertices] - Positional data on geometry.\n     * @param {Float32Array|number[]} [uvs] - Texture UVs.\n     * @param {Uint16Array|number[]} [index] - IndexBuffer\n     */\n    constructor(vertices?: IArrayBuffer, uvs?: IArrayBuffer, index?: IArrayBuffer)\n    {\n        super();\n\n        const verticesBuffer = new Buffer(vertices);\n        const uvsBuffer = new Buffer(uvs, true);\n        const indexBuffer = new Buffer(index, true, true);\n\n        this.addAttribute('aVertexPosition', verticesBuffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aTextureCoord', uvsBuffer, 2, false, TYPES.FLOAT)\n            .addIndex(indexBuffer);\n\n        this._updateId = -1;\n    }\n\n    /**\n     * If the vertex position is updated.\n     * @readonly\n     * @private\n     */\n    get vertexDirtyId(): number\n    {\n        return this.buffers[0]._updateID;\n    }\n}\n", "var fragment = \"varying vec2 vTextureCoord;\\nuniform vec4 uColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mesh.mjs.map\n", "var vertex = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTextureMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mesh2.mjs.map\n", "import { Color, Matrix, Program, Shader, TextureMatrix } from '@pixi/core';\nimport fragment from './shader/mesh.frag';\nimport vertex from './shader/mesh.vert';\n\nimport type { ColorSource, Texture, utils } from '@pixi/core';\n\nexport interface IMeshMaterialOptions\n{\n    alpha?: number;\n    tint?: ColorSource;\n    pluginName?: string;\n    program?: Program;\n    uniforms?: utils.Dict<unknown>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MeshMaterial extends GlobalMixins.MeshMaterial {}\n\n/**\n * Slightly opinionated default shader for PixiJS 2D objects.\n * @memberof PIXI\n */\nexport class MeshMaterial extends Shader\n{\n    /**\n     * TextureMatrix instance for this Mesh, used to track Texture changes.\n     * @readonly\n     */\n    public readonly uvMatrix: TextureMatrix;\n\n    /**\n     * `true` if shader can be batch with the renderer's batch system.\n     * @default true\n     */\n    public batchable: boolean;\n\n    /**\n     * Renderer plugin for batching.\n     * @default 'batch'\n     */\n    public pluginName: string;\n\n    // Internal-only properties\n    _tintRGB: number;\n\n    /**\n     * Only do update if tint or alpha changes.\n     * @private\n     * @default false\n     */\n    private _colorDirty: boolean;\n    private _alpha: number;\n    private _tintColor: Color;\n\n    /**\n     * @param uSampler - Texture that material uses to render.\n     * @param options - Additional options\n     * @param {number} [options.alpha=1] - Default alpha.\n     * @param {PIXI.ColorSource} [options.tint=0xFFFFFF] - Default tint.\n     * @param {string} [options.pluginName='batch'] - Renderer plugin for batching.\n     * @param {PIXI.Program} [options.program=0xFFFFFF] - Custom program.\n     * @param {object} [options.uniforms] - Custom uniforms.\n     */\n    constructor(uSampler: Texture, options?: IMeshMaterialOptions)\n    {\n        const uniforms = {\n            uSampler,\n            alpha: 1,\n            uTextureMatrix: Matrix.IDENTITY,\n            uColor: new Float32Array([1, 1, 1, 1]),\n        };\n\n        // Set defaults\n        options = Object.assign({\n            tint: 0xFFFFFF,\n            alpha: 1,\n            pluginName: 'batch',\n        }, options);\n\n        if (options.uniforms)\n        {\n            Object.assign(uniforms, options.uniforms);\n        }\n\n        super(options.program || Program.from(vertex, fragment), uniforms);\n\n        this._colorDirty = false;\n\n        this.uvMatrix = new TextureMatrix(uSampler);\n        this.batchable = options.program === undefined;\n        this.pluginName = options.pluginName;\n\n        this._tintColor = new Color(options.tint);\n        this._tintRGB = this._tintColor.toLittleEndianNumber();\n        this._colorDirty = true;\n        this.alpha = options.alpha;\n    }\n\n    /** Reference to the texture being rendered. */\n    get texture(): Texture\n    {\n        return this.uniforms.uSampler;\n    }\n    set texture(value: Texture)\n    {\n        if (this.uniforms.uSampler !== value)\n        {\n            if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode)\n            {\n                this._colorDirty = true;\n            }\n\n            this.uniforms.uSampler = value;\n            this.uvMatrix.texture = value;\n        }\n    }\n\n    /**\n     * This gets automatically set by the object using this.\n     * @default 1\n     */\n    set alpha(value: number)\n    {\n        if (value === this._alpha) return;\n\n        this._alpha = value;\n        this._colorDirty = true;\n    }\n    get alpha(): number\n    {\n        return this._alpha;\n    }\n\n    /**\n     * Multiply tint for the material.\n     * @default 0xFFFFFF\n     */\n    set tint(value: ColorSource)\n    {\n        if (value === this.tint) return;\n\n        this._tintColor.setValue(value);\n        this._tintRGB = this._tintColor.toLittleEndianNumber();\n        this._colorDirty = true;\n    }\n    get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    /**\n     * Get the internal number from tint color\n     * @ignore\n     */\n    get tintValue(): number\n    {\n        return this._tintColor.toNumber();\n    }\n\n    /** Gets called automatically by the Mesh. Intended to be overridden for custom {@link PIXI.MeshMaterial} objects. */\n    public update(): void\n    {\n        if (this._colorDirty)\n        {\n            this._colorDirty = false;\n            const baseTexture = this.texture.baseTexture;\n            const applyToChannels = (baseTexture.alphaMode as unknown as boolean);\n\n            Color.shared\n                .setValue(this._tintColor)\n                .premultiply(this._alpha, applyToChannels)\n                .toArray(this.uniforms.uColor);\n        }\n        if (this.uvMatrix.update())\n        {\n            this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;\n        }\n    }\n}\n", "export { Mesh } from './Mesh.mjs';\nexport { MeshBatchUvs } from './MeshBatchUvs.mjs';\nexport { MeshGeometry } from './MeshGeometry.mjs';\nexport { MeshMaterial } from './MeshMaterial.mjs';\n//# sourceMappingURL=index.mjs.map\n", "var msdfFrag = \"// Pixi texture info\\r\\nvarying vec2 vTextureCoord;\\r\\nuniform sampler2D uSampler;\\r\\n\\r\\n// Tint\\r\\nuniform vec4 uColor;\\r\\n\\r\\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\\r\\nuniform float uFWidth;\\r\\n\\r\\nvoid main(void) {\\r\\n\\r\\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\\r\\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\\r\\n\\r\\n  // MSDF\\r\\n  float median = texColor.r + texColor.g + texColor.b -\\r\\n                  min(texColor.r, min(texColor.g, texColor.b)) -\\r\\n                  max(texColor.r, max(texColor.g, texColor.b));\\r\\n  // SDF\\r\\n  median = min(median, texColor.a);\\r\\n\\r\\n  float screenPxDistance = uFWidth * (median - 0.5);\\r\\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\\r\\n  if (median < 0.01) {\\r\\n    alpha = 0.0;\\r\\n  } else if (median > 0.99) {\\r\\n    alpha = 1.0;\\r\\n  }\\r\\n\\r\\n  // Gamma correction for coverage-like alpha\\r\\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\\r\\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\\r\\n  float coverage = pow(uColor.a * alpha, gamma);  \\r\\n\\r\\n  // NPM Textures, NPM outputs\\r\\n  gl_FragColor = vec4(uColor.rgb, coverage);\\r\\n}\\r\\n\";\n\nexport { msdfFrag as default };\n//# sourceMappingURL=msdf.mjs.map\n", "var msdfVert = \"// Mesh material default fragment\\r\\nattribute vec2 aVertexPosition;\\r\\nattribute vec2 aTextureCoord;\\r\\n\\r\\nuniform mat3 projectionMatrix;\\r\\nuniform mat3 translationMatrix;\\r\\nuniform mat3 uTextureMatrix;\\r\\n\\r\\nvarying vec2 vTextureCoord;\\r\\n\\r\\nvoid main(void)\\r\\n{\\r\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\\n\\r\\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\r\\n}\\r\\n\";\n\nexport { msdfVert as default };\n//# sourceMappingURL=msdf2.mjs.map\n", "import { BLEND_MODES, Color, ObservablePoint, Point, Program, settings, Texture, utils } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\nimport { BitmapFont } from './BitmapFont';\nimport msdfFrag from './shader/msdf.frag';\nimport msdfVert from './shader/msdf.vert';\nimport { extractCharCode, splitTextToCharacters } from './utils';\n\nimport type { ColorSource, Rectangle, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { TextStyleAlign } from '@pixi/text';\nimport type { IBitmapTextStyle } from './BitmapTextStyle';\n\ninterface PageMeshData\n{\n    index: number;\n    indexCount: number;\n    vertexCount: number;\n    uvsCount: number;\n    total: number;\n    mesh: Mesh;\n    vertices?: Float32Array;\n    uvs?: Float32Array;\n    indices?: Uint16Array;\n}\ninterface CharRenderData\n{\n    texture: Texture;\n    line: number;\n    charCode: number;\n    position: Point;\n    prevSpaces: number;\n}\n\n// If we ever need more than two pools, please make a Dict or something better.\nconst pageMeshDataDefaultPageMeshData: PageMeshData[] = [];\nconst pageMeshDataMSDFPageMeshData: PageMeshData[] = [];\nconst charRenderDataPool: CharRenderData[] = [];\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font.\n *\n * The primary advantage of this class over Text is that all of your textures are pre-generated and loading,\n * meaning that rendering is fast, and changing text has no performance implications.\n *\n * Supporting character sets other than latin, such as CJK languages, may be impractical due to the number of characters.\n *\n * To split a line you can use '\\n', '\\r' or '\\r\\n' in your string.\n *\n * PixiJS can auto-generate fonts on-the-fly using BitmapFont or use fnt files provided by:\n * http://www.angelcode.com/products/bmfont/ for Windows or\n * http://www.bmglyph.com/ for Mac.\n *\n * You can also use SDF, MSDF and MTSDF BitmapFonts for vector-like scaling appearance provided by:\n * https://github.com/soimy/msdf-bmfont-xml for SDF and MSDF fnt files or\n * https://github.com/Chlumsky/msdf-atlas-gen for SDF, MSDF and MTSDF json files\n *\n * A BitmapText can only be created when the font is loaded.\n * @example\n * import { BitmapText } from 'pixi.js';\n *\n * // in this case the font is in a file called 'desyrel.fnt'\n * const bitmapText = new BitmapText('text using a fancy font!', {\n *     fontName: 'Desyrel',\n *     fontSize: 35,\n *     align: 'right',\n * });\n * @memberof PIXI\n */\nexport class BitmapText extends Container\n{\n    public static styleDefaults: Partial<IBitmapTextStyle> = {\n        align: 'left',\n        tint: 0xFFFFFF,\n        maxWidth: 0,\n        letterSpacing: 0,\n    };\n\n    /** Set to `true` if the BitmapText needs to be redrawn. */\n    public dirty: boolean;\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default PIXI.settings.RESOLUTION\n     */\n    _resolution: number;\n    _autoResolution: boolean;\n\n    /**\n     * Private tracker for the width of the overall text.\n     * @private\n     */\n    protected _textWidth: number;\n\n    /**\n     * Private tracker for the height of the overall text.\n     * @private\n     */\n    protected _textHeight: number;\n\n    /**\n     * Private tracker for the current text.\n     * @private\n     */\n    protected _text: string;\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     * @private\n     */\n    protected _maxWidth: number;\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align. (Internally used)\n     * @private\n     */\n    protected _maxLineHeight: number;\n\n    /**\n     * Letter spacing. This is useful for setting the space between characters.\n     * @private\n     */\n    protected _letterSpacing: number;\n\n    /**\n     * Text anchor.\n     * @readonly\n     * @private\n     */\n    protected _anchor: ObservablePoint;\n\n    /**\n     * Private tracker for the current font.\n     * @private\n     */\n    protected _font?: BitmapFont;\n\n    /**\n     * Private tracker for the current font name.\n     * @private\n     */\n    protected _fontName: string;\n\n    /**\n     * Private tracker for the current font size.\n     * @private\n     */\n    protected _fontSize?: number;\n\n    /**\n     * Private tracker for the current text align.\n     * @type {string}\n     * @private\n     */\n    protected _align: TextStyleAlign;\n\n    /** Collection of page mesh data. */\n    protected _activePagesMeshData: PageMeshData[];\n\n    /**\n     * Private tracker for the current tint.\n     * @private\n     */\n    protected _tintColor: Color;\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering.\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    protected _roundPixels: boolean;\n\n    /** Cached char texture is destroyed when BitmapText is destroyed. */\n    private _textureCache: Record<number, Texture>;\n\n    /**\n     * @param text - A string that you would like the text to display.\n     * @param style - The style parameters.\n     * @param {string} style.fontName - The installed BitmapFont name.\n     * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,\n     *.     this will default to the BitmapFont size.\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center', 'right' or 'justify'),\n     *      does not affect single line text.\n     * @param {PIXI.ColorSource} [style.tint=0xFFFFFF] - The tint color.\n     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.\n     * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.\n     */\n    constructor(text: string, style: Partial<IBitmapTextStyle> = {})\n    {\n        super();\n\n        // Apply the defaults\n        const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign(\n            {}, BitmapText.styleDefaults, style);\n\n        if (!BitmapFont.available[fontName])\n        {\n            throw new Error(`Missing BitmapFont \"${fontName}\"`);\n        }\n\n        this._activePagesMeshData = [];\n        this._textWidth = 0;\n        this._textHeight = 0;\n        this._align = align;\n        this._tintColor = new Color(tint);\n        this._font = undefined;\n        this._fontName = fontName;\n        this._fontSize = fontSize;\n        this.text = text;\n        this._maxWidth = maxWidth;\n        this._maxLineHeight = 0;\n        this._letterSpacing = letterSpacing;\n        this._anchor = new ObservablePoint((): void => { this.dirty = true; }, this, 0, 0);\n        this._roundPixels = settings.ROUND_PIXELS;\n        this.dirty = true;\n        this._resolution = settings.RESOLUTION;\n        this._autoResolution = true;\n        this._textureCache = {};\n    }\n\n    /** Renders text and updates it when needed. This should only be called if the BitmapFont is regenerated. */\n    public updateText(): void\n    {\n        const data = BitmapFont.available[this._fontName];\n        const fontSize = this.fontSize;\n        const scale = fontSize / data.size;\n        const pos = new Point();\n        const chars: CharRenderData[] = [];\n        const lineWidths = [];\n        const lineSpaces = [];\n        const text = this._text.replace(/(?:\\r\\n|\\r)/g, '\\n') || ' ';\n        const charsInput = splitTextToCharacters(text);\n        const maxWidth = this._maxWidth * data.size / fontSize;\n        const pageMeshDataPool = data.distanceFieldType === 'none'\n            ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n\n        let prevCharCode = null;\n        let lastLineWidth = 0;\n        let maxLineWidth = 0;\n        let line = 0;\n        let lastBreakPos = -1;\n        let lastBreakWidth = 0;\n        let spacesRemoved = 0;\n        let maxLineHeight = 0;\n        let spaceCount = 0;\n\n        for (let i = 0; i < charsInput.length; i++)\n        {\n            const char = charsInput[i];\n            const charCode = extractCharCode(char);\n\n            if ((/(?:\\s)/).test(char))\n            {\n                lastBreakPos = i;\n                lastBreakWidth = lastLineWidth;\n                spaceCount++;\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                lineWidths.push(lastLineWidth);\n                lineSpaces.push(-1);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                ++line;\n                ++spacesRemoved;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                spaceCount = 0;\n                continue;\n            }\n\n            const charData = data.chars[charCode];\n\n            if (!charData)\n            {\n                continue;\n            }\n\n            if (prevCharCode && charData.kerning[prevCharCode])\n            {\n                pos.x += charData.kerning[prevCharCode];\n            }\n\n            const charRenderData: CharRenderData = charRenderDataPool.pop() || {\n                texture: Texture.EMPTY,\n                line: 0,\n                charCode: 0,\n                prevSpaces: 0,\n                position: new Point(),\n            };\n\n            charRenderData.texture = charData.texture;\n            charRenderData.line = line;\n            charRenderData.charCode = charCode;\n            charRenderData.position.x = Math.round(pos.x + charData.xOffset + (this._letterSpacing / 2));\n            charRenderData.position.y = Math.round(pos.y + charData.yOffset);\n            charRenderData.prevSpaces = spaceCount;\n\n            chars.push(charRenderData);\n\n            lastLineWidth = charRenderData.position.x\n                + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n            pos.x += charData.xAdvance + this._letterSpacing;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n\n            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth)\n            {\n                ++spacesRemoved;\n                utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n                i = lastBreakPos;\n                lastBreakPos = -1;\n\n                lineWidths.push(lastBreakWidth);\n                lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                spaceCount = 0;\n            }\n        }\n\n        const lastChar = charsInput[charsInput.length - 1];\n\n        if (lastChar !== '\\r' && lastChar !== '\\n')\n        {\n            if ((/(?:\\s)/).test(lastChar))\n            {\n                lastLineWidth = lastBreakWidth;\n            }\n\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n            lineSpaces.push(-1);\n        }\n\n        const lineAlignOffsets = [];\n\n        for (let i = 0; i <= line; i++)\n        {\n            let alignOffset = 0;\n\n            if (this._align === 'right')\n            {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._align === 'center')\n            {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n            else if (this._align === 'justify')\n            {\n                alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];\n            }\n\n            lineAlignOffsets.push(alignOffset);\n        }\n\n        const lenChars = chars.length;\n\n        const pagesMeshData: Record<number, PageMeshData> = {};\n\n        const newPagesMeshData: PageMeshData[] = [];\n\n        const activePagesMeshData = this._activePagesMeshData;\n\n        pageMeshDataPool.push(...activePagesMeshData);\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            const texture = chars[i].texture;\n            const baseTextureUid = texture.baseTexture.uid;\n\n            if (!pagesMeshData[baseTextureUid])\n            {\n                let pageMeshData = pageMeshDataPool.pop();\n\n                if (!pageMeshData)\n                {\n                    const geometry = new MeshGeometry();\n                    let material: MeshMaterial;\n                    let meshBlendMode: BLEND_MODES;\n\n                    if (data.distanceFieldType === 'none')\n                    {\n                        material = new MeshMaterial(Texture.EMPTY);\n                        meshBlendMode = BLEND_MODES.NORMAL;\n                    }\n                    else\n                    {\n                        material = new MeshMaterial(Texture.EMPTY,\n                            { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });\n                        meshBlendMode = BLEND_MODES.NORMAL_NPM;\n                    }\n\n                    const mesh = new Mesh(geometry, material);\n\n                    mesh.blendMode = meshBlendMode;\n\n                    pageMeshData = {\n                        index: 0,\n                        indexCount: 0,\n                        vertexCount: 0,\n                        uvsCount: 0,\n                        total: 0,\n                        mesh,\n                        vertices: null,\n                        uvs: null,\n                        indices: null,\n                    };\n                }\n\n                // reset data..\n                pageMeshData.index = 0;\n                pageMeshData.indexCount = 0;\n                pageMeshData.vertexCount = 0;\n                pageMeshData.uvsCount = 0;\n                pageMeshData.total = 0;\n\n                // TODO need to get page texture here somehow..\n                const { _textureCache } = this;\n\n                _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);\n                pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n\n                pageMeshData.mesh.tint = this._tintColor.value;\n\n                newPagesMeshData.push(pageMeshData);\n\n                pagesMeshData[baseTextureUid] = pageMeshData;\n            }\n\n            pagesMeshData[baseTextureUid].total++;\n        }\n\n        // lets find any previously active pageMeshDatas that are no longer required for\n        // the updated text (if any), removed and return them to the pool.\n        for (let i = 0; i < activePagesMeshData.length; i++)\n        {\n            if (!newPagesMeshData.includes(activePagesMeshData[i]))\n            {\n                this.removeChild(activePagesMeshData[i].mesh);\n            }\n        }\n\n        // next lets add any new meshes, that have not yet been added to this BitmapText\n        // we only add if its not already a child of this BitmapObject\n        for (let i = 0; i < newPagesMeshData.length; i++)\n        {\n            if (newPagesMeshData[i].mesh.parent !== this)\n            {\n                this.addChild(newPagesMeshData[i].mesh);\n            }\n        }\n\n        // active page mesh datas are set to be the new pages added.\n        this._activePagesMeshData = newPagesMeshData;\n\n        for (const i in pagesMeshData)\n        {\n            const pageMeshData = pagesMeshData[i];\n            const total = pageMeshData.total;\n\n            // lets only allocate new buffers if we can fit the new text in the current ones..\n            // unless that is, we will be batching. Currently batching dose not respect the size property of mesh\n            if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2)\n            {\n                pageMeshData.vertices = new Float32Array(4 * 2 * total);\n                pageMeshData.uvs = new Float32Array(4 * 2 * total);\n                pageMeshData.indices = new Uint16Array(6 * total);\n            }\n            else\n            {\n                const total = pageMeshData.total;\n                const vertices = pageMeshData.vertices;\n\n                // Clear the garbage at the end of the vertices buffer. This will prevent the bounds miscalculation.\n                for (let i = total * 4 * 2; i < vertices.length; i++)\n                {\n                    vertices[i] = 0;\n                }\n            }\n\n            // as a buffer maybe bigger than the current word, we set the size of the meshMaterial\n            // to match the number of letters needed\n            pageMeshData.mesh.size = 6 * total;\n        }\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            const char = chars[i];\n            let offset = char.position.x + (lineAlignOffsets[char.line] * (this._align === 'justify' ? char.prevSpaces : 1));\n\n            if (this._roundPixels)\n            {\n                offset = Math.round(offset);\n            }\n\n            const xPos = offset * scale;\n            const yPos = char.position.y * scale;\n            const texture = char.texture;\n\n            const pageMesh = pagesMeshData[texture.baseTexture.uid];\n\n            const textureFrame = texture.frame;\n            const textureUvs = texture._uvs;\n\n            const index = pageMesh.index++;\n\n            pageMesh.indices[(index * 6) + 0] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 1] = 1 + (index * 4);\n            pageMesh.indices[(index * 6) + 2] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 3] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 4] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 5] = 3 + (index * 4);\n\n            pageMesh.vertices[(index * 8) + 0] = xPos;\n            pageMesh.vertices[(index * 8) + 1] = yPos;\n\n            pageMesh.vertices[(index * 8) + 2] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 3] = yPos;\n\n            pageMesh.vertices[(index * 8) + 4] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 5] = yPos + (textureFrame.height * scale);\n\n            pageMesh.vertices[(index * 8) + 6] = xPos;\n            pageMesh.vertices[(index * 8) + 7] = yPos + (textureFrame.height * scale);\n\n            pageMesh.uvs[(index * 8) + 0] = textureUvs.x0;\n            pageMesh.uvs[(index * 8) + 1] = textureUvs.y0;\n\n            pageMesh.uvs[(index * 8) + 2] = textureUvs.x1;\n            pageMesh.uvs[(index * 8) + 3] = textureUvs.y1;\n\n            pageMesh.uvs[(index * 8) + 4] = textureUvs.x2;\n            pageMesh.uvs[(index * 8) + 5] = textureUvs.y2;\n\n            pageMesh.uvs[(index * 8) + 6] = textureUvs.x3;\n            pageMesh.uvs[(index * 8) + 7] = textureUvs.y3;\n        }\n\n        this._textWidth = maxLineWidth * scale;\n        this._textHeight = (pos.y + data.lineHeight) * scale;\n\n        for (const i in pagesMeshData)\n        {\n            const pageMeshData = pagesMeshData[i];\n\n            // apply anchor\n            if (this.anchor.x !== 0 || this.anchor.y !== 0)\n            {\n                let vertexCount = 0;\n\n                const anchorOffsetX = this._textWidth * this.anchor.x;\n                const anchorOffsetY = this._textHeight * this.anchor.y;\n\n                for (let i = 0; i < pageMeshData.total; i++)\n                {\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n                }\n            }\n\n            this._maxLineHeight = maxLineHeight * scale;\n\n            const vertexBuffer = pageMeshData.mesh.geometry.getBuffer('aVertexPosition');\n            const textureBuffer = pageMeshData.mesh.geometry.getBuffer('aTextureCoord');\n            const indexBuffer = pageMeshData.mesh.geometry.getIndex();\n\n            vertexBuffer.data = pageMeshData.vertices;\n            textureBuffer.data = pageMeshData.uvs;\n            indexBuffer.data = pageMeshData.indices;\n\n            vertexBuffer.update();\n            textureBuffer.update();\n            indexBuffer.update();\n        }\n\n        for (let i = 0; i < chars.length; i++)\n        {\n            charRenderDataPool.push(chars[i]);\n        }\n\n        this._font = data;\n        this.dirty = false;\n    }\n\n    updateTransform(): void\n    {\n        this.validate();\n        this.containerUpdateTransform();\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        // Update the uniform\n        const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];\n\n        if (distanceFieldType !== 'none')\n        {\n            // Inject the shader code with the correct value\n            const { a, b, c, d } = this.worldTransform;\n\n            const dx = Math.sqrt((a * a) + (b * b));\n            const dy = Math.sqrt((c * c) + (d * d));\n            const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n            const fontScale = this.fontSize / size;\n\n            const resolution = renderer._view.resolution;\n\n            for (const mesh of this._activePagesMeshData)\n            {\n                mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n            }\n        }\n\n        super._render(renderer);\n    }\n\n    /**\n     * Validates text before calling parent's getLocalBounds\n     * @returns - The rectangular bounding area\n     */\n    public getLocalBounds(): Rectangle\n    {\n        this.validate();\n\n        return super.getLocalBounds();\n    }\n\n    /**\n     * Updates text when needed\n     * @private\n     */\n    protected validate(): void\n    {\n        const font = BitmapFont.available[this._fontName];\n\n        if (!font)\n        {\n            throw new Error(`Missing BitmapFont \"${this._fontName}\"`);\n        }\n        if (this._font !== font)\n        {\n            this.dirty = true;\n        }\n\n        if (this.dirty)\n        {\n            this.updateText();\n        }\n    }\n\n    /**\n     * The tint of the BitmapText object.\n     * @default 0xffffff\n     */\n    public get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    public set tint(value: ColorSource)\n    {\n        if (this.tint === value) return;\n\n        this._tintColor.setValue(value);\n\n        for (let i = 0; i < this._activePagesMeshData.length; i++)\n        {\n            this._activePagesMeshData[i].mesh.tint = value;\n        }\n    }\n\n    /**\n     * The alignment of the BitmapText object.\n     * @member {string}\n     * @default 'left'\n     */\n    public get align(): TextStyleAlign\n    {\n        return this._align;\n    }\n\n    public set align(value: TextStyleAlign)\n    {\n        if (this._align !== value)\n        {\n            this._align = value;\n            this.dirty = true;\n        }\n    }\n\n    /** The name of the BitmapFont. */\n    public get fontName(): string\n    {\n        return this._fontName;\n    }\n\n    public set fontName(value: string)\n    {\n        if (!BitmapFont.available[value])\n        {\n            throw new Error(`Missing BitmapFont \"${value}\"`);\n        }\n\n        if (this._fontName !== value)\n        {\n            this._fontName = value;\n            this.dirty = true;\n        }\n    }\n\n    /** The size of the font to display. */\n    public get fontSize(): number\n    {\n        return this._fontSize ?? BitmapFont.available[this._fontName].size;\n    }\n\n    public set fontSize(value: number | undefined)\n    {\n        if (this._fontSize !== value)\n        {\n            this._fontSize = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     *\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     */\n    public get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    public set anchor(value: ObservablePoint)\n    {\n        if (typeof value === 'number')\n        {\n            this._anchor.set(value);\n        }\n        else\n        {\n            this._anchor.copyFrom(value);\n        }\n    }\n\n    /** The text of the BitmapText object. */\n    public get text(): string\n    {\n        return this._text;\n    }\n\n    public set text(text: string)\n    {\n        text = String(text === null || text === undefined ? '' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting the value to 0.\n     */\n    public get maxWidth(): number\n    {\n        return this._maxWidth;\n    }\n\n    public set maxWidth(value: number)\n    {\n        if (this._maxWidth === value)\n        {\n            return;\n        }\n        this._maxWidth = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * i.e. when trying to vertically align.\n     * @readonly\n     */\n    public get maxLineHeight(): number\n    {\n        this.validate();\n\n        return this._maxLineHeight;\n    }\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    public get textWidth(): number\n    {\n        this.validate();\n\n        return this._textWidth;\n    }\n\n    /** Additional space between characters. */\n    public get letterSpacing(): number\n    {\n        return this._letterSpacing;\n    }\n\n    public set letterSpacing(value: number)\n    {\n        if (this._letterSpacing !== value)\n        {\n            this._letterSpacing = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    public get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    public set roundPixels(value: boolean)\n    {\n        if (value !== this._roundPixels)\n        {\n            this._roundPixels = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    public get textHeight(): number\n    {\n        this.validate();\n\n        return this._textHeight;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n\n    destroy(options?: boolean | IDestroyOptions): void\n    {\n        const { _textureCache } = this;\n        const data = BitmapFont.available[this._fontName];\n        const pageMeshDataPool = data.distanceFieldType === 'none'\n            ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n\n        pageMeshDataPool.push(...this._activePagesMeshData);\n        for (const pageMeshData of this._activePagesMeshData)\n        {\n            this.removeChild(pageMeshData.mesh);\n        }\n        this._activePagesMeshData = [];\n\n        // Release references to any cached textures in page pool\n        pageMeshDataPool\n            .filter((page) => _textureCache[page.mesh.texture.baseTexture.uid])\n            .forEach((page) =>\n            {\n                page.mesh.texture = Texture.EMPTY;\n            });\n\n        for (const id in _textureCache)\n        {\n            const texture = _textureCache[id];\n\n            texture.destroy();\n            delete _textureCache[id];\n        }\n\n        this._font = null;\n        this._tintColor = null;\n        this._textureCache = null;\n\n        super.destroy(options);\n    }\n}\n", "export function checkDataUrl(url: string, mimes: string | string[]): boolean\n{\n    if (Array.isArray(mimes))\n    {\n        for (const mime of mimes)\n        {\n            if (url.startsWith(`data:${mime}`)) return true;\n        }\n\n        return false;\n    }\n\n    return url.startsWith(`data:${mimes}`);\n}\n", "import { utils } from '@pixi/core';\n\nexport function checkExtension(url: string, extension: string | string[]): boolean\n{\n    const tempURL = url.split('?')[0];\n    const ext = utils.path.extname(tempURL).toLowerCase();\n\n    if (Array.isArray(extension))\n    {\n        return extension.includes(ext);\n    }\n\n    return ext === extension;\n}\n", "export const convertToList = <T>(input: string | T | (string | T)[], transform?: (input: string) => T): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string')\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n", "/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n", "function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n", "/**\n * Checks if the given value is an array.\n * @param item - The item to test\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n", "export { checkDataUrl } from './checkDataUrl.mjs';\nexport { checkExtension } from './checkExtension.mjs';\nexport { convertToList } from './convertToList.mjs';\nexport { copySearchParams } from './copySearchParams.mjs';\nexport { createStringVariations } from './createStringVariations.mjs';\nexport { isSingleItem } from './isSingleItem.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { BaseTexture, Texture } from '@pixi/core';\nimport { convertToList } from '../utils';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSprite Sheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @memberof PIXI\n * @class Cache\n */\nclass CacheClass\n{\n    private _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<string, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: string): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: string): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: string | string[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        if (!cacheableAssets)\n        {\n            cacheableAssets = {};\n\n            keys.forEach((key) =>\n            {\n                cacheableAssets[key] = value;\n            });\n        }\n\n        const cacheKeys = Object.keys(cacheableAssets);\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            if (this._cache.has(key) && this._cache.get(key) !== value)\n            {\n                // #if _DEBUG\n                console.warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableAssets[key]);\n        });\n\n        // temporary to keep compatible with existing texture caching.. until we remove them!\n        if (value instanceof Texture)\n        {\n            const texture: Texture = value;\n\n            keys.forEach((key) =>\n            {\n                if (texture.baseTexture !== Texture.EMPTY.baseTexture)\n                {\n                    BaseTexture.addToCache(texture.baseTexture, key);\n                }\n\n                Texture.addToCache(texture, key);\n            });\n        }\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: string): void\n    {\n        this._cacheMap.get(key);\n\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n", "import type { ExtensionMetadata } from '@pixi/core';\nimport type { Loader } from '../Loader';\nimport type { LoadAsset } from '../types';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @memberof PIXI\n * @enum {number}\n */\nexport enum LoaderParserPriority\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * All functions are optional here. The flow:\n *\n * for every asset,\n *\n * 1. `parser.test()`: Test the asset url.\n * 2. `parser.load()`: If test passes call the load function with the url\n * 3. `parser.testParse()`: Test to see if the asset should be parsed by the plugin\n * 4. `parse.parse()`: If test is parsed, then run the parse function on the asset.\n *\n * some plugins may only be used for parsing,\n * some only for loading\n * and some for both!\n * @memberof PIXI\n */\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n{\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /** The name of the parser (this can be used when specifying loadParser in a LoadAsset) */\n    name?: string;\n\n    /**\n     * each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful than\n     * @param asset - The loaded asset data\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param loadAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: ASSET, loadAsset?: LoadAsset<META_DATA>, loader?: Loader) => void;\n}\n", "import { extensions, ExtensionType, settings } from '@pixi/core';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validJSONExtension = '.json';\nconst validJSONMIME = 'application/json';\n\n/** simple loader plugin for loading json data */\nexport const loadJson = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadJson',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n    },\n\n    async load<T>(url: string): Promise<T>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        const json = await response.json();\n\n        return json as T;\n    },\n} as LoaderParser;\n\nextensions.add(loadJson);\n", "import { extensions, ExtensionType, settings } from '@pixi/core';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validTXTExtension = '.txt';\nconst validTXTMIME = 'text/plain';\n\n/** Simple loader plugin for loading text data */\nexport const loadTxt = {\n\n    name: 'loadTxt',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n    },\n\n    async load(url: string): Promise<string>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        const txt = await response.text();\n\n        return txt;\n    },\n} as LoaderParser;\n\nextensions.add(loadTxt);\n", "import { extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoadAsset } from '../types';\nimport type { LoaderParser } from './LoaderParser';\n\nconst validWeights = [\n    'normal', 'bold',\n    '100', '200', '300', '400', '500', '600', '700', '800', '900',\n];\nconst validFontExtensions = ['.ttf', '.otf', '.woff', '.woff2'];\nconst validFontMIMEs = [\n    'font/ttf',\n    'font/otf',\n    'font/woff',\n    'font/woff2',\n];\n\n/**\n * Loader plugin for handling web fonts\n * @memberof PIXI\n */\nexport type LoadFontData = {\n    family: string;\n    display: string;\n    featureSettings: string;\n    stretch: string;\n    style: string;\n    unicodeRange: string;\n    variant: string;\n    weights: string[];\n};\n\n/**\n * RegExp for matching CSS <ident-token>. It doesn't consider escape and non-ASCII characters, but enough for us.\n * @see {@link https://www.w3.org/TR/css-syntax-3/#ident-token-diagram}\n */\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\n\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/tital-one.woff' turns into 'Titan One'\n * @param url - File url\n */\nexport function getFontFamilyName(url: string): string\n{\n    const ext = utils.path.extname(url);\n    const name = utils.path.basename(url, ext);\n\n    // Replace dashes by white spaces\n    const nameWithSpaces = name.replace(/(-|_)/g, ' ');\n\n    // Upper case first character of each word\n    const nameTokens = nameWithSpaces.toLowerCase()\n        .split(' ')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n\n    let valid = nameTokens.length > 0;\n\n    for (const token of nameTokens)\n    {\n        if (!token.match(CSS_IDENT_TOKEN_REGEX))\n        {\n            valid = false;\n            break;\n        }\n    }\n\n    let fontFamilyName = nameTokens.join(' ');\n\n    if (!valid)\n    {\n        fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, '\\\\$&')}\"`;\n    }\n\n    return fontFamilyName;\n}\n\n/** Web font loader plugin */\nexport const loadWebFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadWebFont',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n    },\n\n    async load(url: string, options?: LoadAsset<LoadFontData>): Promise<FontFace | FontFace[]>\n    {\n        const fonts = settings.ADAPTER.getFontFaceSet();\n\n        if (fonts)\n        {\n            const fontFaces: FontFace[] = [];\n            const name = options.data?.family ?? getFontFamilyName(url);\n            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ['normal'];\n            const data = options.data ?? {};\n\n            for (let i = 0; i < weights.length; i++)\n            {\n                const weight = weights[i];\n\n                const font = new FontFace(name, `url(${encodeURI(url)})`, {\n                    ...data,\n                    weight,\n                });\n\n                await font.load();\n\n                fonts.add(font);\n\n                fontFaces.push(font);\n            }\n\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n\n        // #if _DEBUG\n        console.warn('[loadWebFont] FontFace API is not supported. Skipping loading font');\n        // #endif\n\n        return null;\n    },\n\n    unload(font: FontFace | FontFace[]): void\n    {\n        (Array.isArray(font) ? font : [font])\n            .forEach((t) => settings.ADAPTER.getFontFaceSet().delete(t));\n    }\n} as LoaderParser<FontFace | FontFace[]>;\n\nextensions.add(loadWebFont);\n", "import { Texture } from '@pixi/core';\n\nimport type { BaseTexture } from '@pixi/core';\nimport type { Loader } from '../../../Loader';\n\nexport function createTexture(base: BaseTexture, loader: Loader, url: string)\n{\n    const texture = new Texture(base);\n\n    // make sure to nuke the promise if a texture is destroyed..\n    texture.baseTexture.on('dispose', () =>\n    {\n        delete loader.promiseCache[url];\n    });\n\n    return texture;\n}\n", "let UUID = 0;\nlet MAX_WORKERS: number;\n\n// 1x1 White PNG Data URL\nconst WHITE_PNG = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42m'\n    + 'P8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=';\nconst checkImageBitmapCode = {\n    id: 'checkImageBitmap',\n    code: `\n    async function checkImageBitmap()\n    {\n        try\n        {\n            if (typeof createImageBitmap !== 'function') return false;\n\n            const response = await fetch('${WHITE_PNG}');\n            const imageBlob =  await response.blob();\n            const imageBitmap = await createImageBitmap(imageBlob);\n\n            return imageBitmap.width === 1 && imageBitmap.height === 1;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    }\n    checkImageBitmap().then((result) => { self.postMessage(result); });\n    `,\n};\n\ntype LoadImageBitmapResult = {\n    data?: ImageBitmap,\n    error?: Error,\n    uuid: number,\n    id: string,\n};\n\nconst workerCode = {\n    id: 'loadImageBitmap',\n    code: `\n    async function loadImageBitmap(url)\n    {\n        const response = await fetch(url);\n\n        if (!response.ok)\n        {\n            throw new Error(\\`[WorkerManager.loadImageBitmap] Failed to fetch \\${url}: \\`\n                + \\`\\${response.status} \\${response.statusText}\\`);\n        }\n\n        const imageBlob =  await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n\n        return imageBitmap;\n    }\n    self.onmessage = async (event) =>\n    {\n        try\n        {\n            const imageBitmap = await loadImageBitmap(event.data.data[0]);\n\n            self.postMessage({\n                data: imageBitmap,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            }, [imageBitmap]);\n        }\n        catch(e)\n        {\n            self.postMessage({\n                error: e,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            });\n        }\n    };`,\n};\n\nlet workerURL: string;\n\nclass WorkerManagerClass\n{\n    public worker: Worker;\n    private resolveHash: {\n        [key: string]: {\n            resolve: (...param: any[]) => void;\n            reject: (...param: any[]) => void;\n        }\n    };\n    private readonly workerPool: Worker[];\n    private readonly queue: {\n        id: string;\n        arguments: any[];\n        resolve: (...param: any[]) => void;\n        reject: (...param: any[]) => void;\n    }[];\n    private _initialized = false;\n    private _createdWorkers = 0;\n    private _isImageBitmapSupported?: Promise<boolean>;\n\n    constructor()\n    {\n        this.workerPool = [];\n        this.queue = [];\n\n        this.resolveHash = {};\n    }\n\n    public isImageBitmapSupported(): Promise<boolean>\n    {\n        if (this._isImageBitmapSupported !== undefined) return this._isImageBitmapSupported;\n\n        this._isImageBitmapSupported = new Promise((resolve) =>\n        {\n            const workerURL = URL.createObjectURL(new Blob([checkImageBitmapCode.code],\n                { type: 'application/javascript' }));\n            const worker = new Worker(workerURL);\n\n            worker.addEventListener('message', (event: MessageEvent<boolean>) =>\n            {\n                worker.terminate();\n                URL.revokeObjectURL(workerURL);\n                resolve(event.data);\n            });\n        });\n\n        return this._isImageBitmapSupported;\n    }\n\n    public loadImageBitmap(src: string): Promise<ImageBitmap>\n    {\n        return this._run('loadImageBitmap', [src]) as Promise<ImageBitmap>;\n    }\n\n    private async _initWorkers()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n    }\n\n    private getWorker(): Worker\n    {\n        if (MAX_WORKERS === undefined)\n        {\n            MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        }\n        let worker = this.workerPool.pop();\n\n        if (!worker && this._createdWorkers < MAX_WORKERS)\n        {\n            if (!workerURL)\n            {\n                workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: 'application/javascript' }));\n            }\n\n            // only create as many as MAX_WORKERS allows..\n            this._createdWorkers++;\n            worker = new Worker(workerURL);\n\n            worker.addEventListener('message', (event: MessageEvent) =>\n            {\n                this.complete(event.data);\n\n                this.returnWorker(event.target as Worker);\n                this.next();\n            });\n        }\n\n        return worker;\n    }\n\n    private returnWorker(worker: Worker)\n    {\n        this.workerPool.push(worker);\n    }\n\n    private complete(data: LoadImageBitmapResult): void\n    {\n        if (data.error !== undefined)\n        {\n            this.resolveHash[data.uuid].reject(data.error);\n        }\n        else\n        {\n            this.resolveHash[data.uuid].resolve(data.data);\n        }\n\n        this.resolveHash[data.uuid] = null;\n    }\n\n    private async _run(id: string, args: any[]): Promise<any>\n    {\n        await this._initWorkers();\n        // push into the queue...\n\n        const promise = new Promise((resolve, reject) =>\n        {\n            this.queue.push({ id, arguments: args, resolve, reject });\n        });\n\n        this.next();\n\n        return promise;\n    }\n\n    private next(): void\n    {\n        // nothing to do\n        if (!this.queue.length) return;\n\n        const worker = this.getWorker();\n\n        // no workers available...\n        if (!worker)\n        {\n            return;\n        }\n\n        const toDo = this.queue.pop();\n\n        const id = toDo.id;\n\n        this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: UUID++,\n            id,\n        });\n    }\n}\n\nconst WorkerManager = new WorkerManagerClass();\n\nexport {\n    WorkerManager,\n};\n", "import { BaseTexture, extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { WorkerManager } from '../WorkerManager';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { Loader } from '../../Loader';\nimport type { LoadAsset } from '../../types';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the `loadTextures` loader plugin.\n * @memberof PIXI\n * @see PIXI.loadTextures\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n */\nexport async function loadImageBitmap(url: string): Promise<ImageBitmap>\n{\n    const response = await settings.ADAPTER.fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n\n    return imageBitmap;\n}\n\n/**\n * Loads our textures!\n * this makes use of imageBitmaps where available.\n * We load the ImageBitmap on a different thread using the WorkerManager\n * We can then use the ImageBitmap as a source for a Pixi Texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * ```js\n * // Set the config\n * import { loadTextures } from '@pixi/assets';\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap\n *    // If false then this will also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @memberof PIXI\n */\nexport const loadTextures = {\n\n    name: 'loadTextures',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: LoadAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url);\n            }\n            else\n            {\n                src = await loadImageBitmap(url);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = this.config.crossOrigin;\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new BaseTexture(src, {\n            resolution: utils.getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        base.resource.src = url;\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, IBaseTextureOptions, LoadTextureConfig>;\n\nextensions.add(loadTextures);\n", "import { BaseTexture, extensions, ExtensionType, settings, SVGResource, utils } from '@pixi/core';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { loadTextures } from './loadTextures';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { Loader } from '../../Loader';\nimport type { LoadAsset } from '../../types';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validSVGExtension = '.svg';\nconst validSVGMIME = 'image/svg+xml';\n\n/** Loads SVG's into Textures */\nexport const loadSVG = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    name: 'loadSVG',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return SVGResource.test(data);\n    },\n\n    async parse(asset: string, data: LoadAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        const src = new SVGResource(asset, data?.data?.resourceOptions);\n\n        await src.load();\n\n        const base = new BaseTexture(src, {\n            resolution: utils.getResolutionOfUrl(asset),\n            ...data?.data,\n        });\n\n        base.resource.src = asset;\n\n        const texture = createTexture(base, loader, asset);\n\n        return texture;\n    },\n\n    async load(url: string, _options: LoadAsset): Promise<string>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        return response.text();\n    },\n\n    unload: loadTextures.unload,\n\n} as LoaderParser<Texture | string, IBaseTextureOptions>;\n\nextensions.add(loadSVG);\n", "import type { LoadAsset } from './loader';\nimport type { Loader } from './loader/Loader';\n\n/**\n * Quietly Loads assets in the background.\n * @memberof PIXI\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: LoadAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /** Should the loader log to the console. */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds an array of assets to load.\n     * @param assetUrls - assets to load\n     */\n    public add(assetUrls: LoadAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        // eslint-disable-next-line no-console\n        if (this.verbose)console.log('[BackgroundLoader] assets: ', this._assetList);\n\n        if (this._isActive && !this._isLoading)\n        {\n            this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            this._next();\n        }\n    }\n\n    /**\n     * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n     * @returns whether the class is active\n     */\n    get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            this._next();\n        }\n    }\n}\n", "import { utils } from '@pixi/core';\nimport { convertToList, isSingleItem } from '../utils';\n\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { LoadAsset, PromiseAndParser } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @memberof PIXI\n * @class AssetLoader\n */\nexport class Loader\n{\n    private _parsers: LoaderParser[] = [];\n    private _parserHash: Record<string, LoaderParser>;\n\n    private _parsersValidated = false;\n\n    /** All loader parsers registered */\n    public parsers = new Proxy(this._parsers, {\n        set: (target, key, value) =>\n        {\n            this._parsersValidated = false;\n\n            target[key as any as number] = value;\n\n            return true;\n        }\n    });\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: LoadAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            let parser: LoaderParser = null;\n\n            // first check to see if the user has specified a parser\n            if (data.loadParser)\n            {\n                // they have? lovely, lets use it\n                parser = this._parserHash[data.loadParser];\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    console.warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n                    // #endif\n                }\n            }\n\n            // no parser specified, so lets try and find one using the tests\n            if (!parser)\n            {\n                for (let i = 0; i < this.parsers.length; i++)\n                {\n                    const parserX = this.parsers[i];\n\n                    if (parserX.load && parserX.test?.(url, data, this))\n                    {\n                        parser = parserX;\n                        break;\n                    }\n                }\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    // #endif\n\n                    return null;\n                }\n            }\n\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - For multiple asset loading only, an optional function that is called\n     * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n     * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n     * to detect when assets are complete and available, instead use the Promise returned by this function.\n     */\n    public async load<T = any>(\n        assetsToLoadIn: string | LoadAsset,\n        onProgress?: (progress: number) => void,\n    ): Promise<T>;\n    public async load<T = any>(\n        assetsToLoadIn: string[] | LoadAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        assetsToLoadIn: string | string[] | LoadAsset | LoadAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._parsersValidated)\n        {\n            this._validateParsers();\n        }\n\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<LoadAsset>(assetsToLoadIn, (item) => ({\n            src: item,\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: LoadAsset) =>\n        {\n            const url = utils.path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | LoadAsset | LoadAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<LoadAsset>(assetsToUnloadIn, (item) => ({\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: LoadAsset) =>\n        {\n            const url = utils.path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                loadPromise.parser?.unload?.(loadedAsset, asset, this);\n\n                delete this.promiseCache[url];\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n    private _validateParsers()\n    {\n        this._parsersValidated = true;\n\n        this._parserHash = this._parsers\n            .filter((parser) => parser.name)\n            .reduce((hash, parser) =>\n            {\n                if (hash[parser.name])\n                {\n                    // #if _DEBUG\n                    console.warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n                    // #endif\n                }\n\n                return { ...hash, [parser.name]: parser };\n            }, {} as Record<string, LoaderParser>);\n    }\n}\n", "export { createTexture } from './createTexture.mjs';\n//# sourceMappingURL=index.mjs.map\n", "export { loadSVG } from './loadSVG.mjs';\nexport { loadImageBitmap, loadTextures } from './loadTextures.mjs';\nimport './utils/index.mjs';\n//# sourceMappingURL=index.mjs.map\n", "export { LoaderParserPriority } from './LoaderParser.mjs';\nexport { loadJson } from './loadJson.mjs';\nexport { loadTxt } from './loadTxt.mjs';\nexport { getFontFamilyName, loadWebFont } from './loadWebFont.mjs';\nimport './textures/index.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { utils } from '@pixi/core';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type { PreferOrder, ResolveAsset, ResolverBundle, ResolverManifest, ResolveURLParser } from './types';\n\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof PIXI\n */\nexport class Resolver\n{\n    private _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolveAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolveAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: ResolverManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: ResolverManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            console.warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: ResolverBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n        if (Array.isArray(assets))\n        {\n            assets.forEach((asset) =>\n            {\n                if (typeof asset.name === 'string')\n                {\n                    const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);\n\n                    assetNames.push(bundleAssetId);\n\n                    this.add([asset.name, bundleAssetId], asset.srcs, asset.data);\n                }\n                else\n                {\n                    const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));\n\n                    bundleIds.forEach((bundleId) =>\n                    {\n                        assetNames.push(bundleId);\n                    });\n\n                    this.add([...asset.name, ...bundleIds], asset.srcs);\n                }\n            });\n        }\n        else\n        {\n            Object.keys(assets).forEach((key) =>\n            {\n                assetNames.push(this._createBundleAssetId(bundleId, key));\n                this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);\n            });\n        }\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add('foo', 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add(['foo', 'boo'], 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add(['foo', 'boo'], ['bar.png', 'bar.webp']);\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add(\n     *     'bunnyBooBooSmooth',\n     *     'bunny{png,webp}',\n     *     { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * );\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param keysIn - The keys to map, can be an array or a single key\n     * @param assetsIn - The assets to associate with the key(s)\n     * @param data - The data that will be attached to the object that resolved object.\n     */\n    public add(keysIn: string | string[], assetsIn: string | ResolveAsset | (string | ResolveAsset)[], data?: unknown): void\n    {\n        const keys: string[] = convertToList<string>(keysIn);\n\n        keys.forEach((key) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                console.warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        });\n\n        if (!Array.isArray(assetsIn))\n        {\n            if (typeof assetsIn === 'string')\n            {\n                assetsIn = createStringVariations(assetsIn);\n            }\n            else\n            {\n                assetsIn = [assetsIn];\n            }\n        }\n\n        const assetMap: ResolveAsset[] = assetsIn.map((asset): ResolveAsset =>\n        {\n            let formattedAsset = asset as ResolveAsset;\n\n            // check if is a string\n            if (typeof asset === 'string')\n            {\n                // first see if it contains any {} tags...\n\n                let parsed = false;\n\n                for (let i = 0; i < this._parsers.length; i++)\n                {\n                    const parser = this._parsers[i];\n\n                    if (parser.test(asset))\n                    {\n                        formattedAsset = parser.parse(asset);\n                        parsed = true;\n                        break;\n                    }\n                }\n\n                if (!parsed)\n                {\n                    formattedAsset = {\n                        src: asset,\n                    };\n                }\n            }\n\n            if (!formattedAsset.format)\n            {\n                formattedAsset.format = formattedAsset.src.split('.').pop();\n            }\n\n            if (!formattedAsset.alias)\n            {\n                formattedAsset.alias = keys;\n            }\n\n            if (this._basePath || this._rootPath)\n            {\n                formattedAsset.src = utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n            }\n\n            formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n\n            formattedAsset.data = formattedAsset.data ?? data;\n\n            return formattedAsset;\n        });\n\n        keys.forEach((key) =>\n        {\n            this._assetMap[key] = assetMap;\n        });\n    }\n\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     name: 'background',\n     *                     srcs: 'sunset.png',\n     *                 },\n     *                 {\n     *                     name: 'bar',\n     *                     srcs: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     name: 'character',\n     *                     srcs: 'robot.png',\n     *                 },\n     *                 {\n     *                     name: 'enemy',\n     *                     srcs: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: string | string[]):\n    Record<string, ResolveAsset> | Record<string, Record<string, ResolveAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolveAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolveAsset>;\n\n                const assets: Record<string, ResolveAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: string | string[]): string | Record<string, string>\n    {\n        const result = this.resolve(key);\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolveAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolveAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string | string[]): ResolveAsset | Record<string, ResolveAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolveAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    const bestAsset = assets[0];\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey])\n                                {\n                                    return asset[priorityKey] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = (assets[0] ?? bestAsset);\n                }\n                else\n                {\n                    let src = key;\n\n                    if (this._basePath || this._rootPath)\n                    {\n                        src = utils.path.toAbsolute(src, this._basePath, this._rootPath);\n                    }\n\n                    // make sure to append any default parameters\n                    src = this._appendDefaultSearchParams(src);\n\n                    // if the resolver fails we just pass back the key assuming its a url\n                    this._resolverHash[key] = {\n                        src,\n                    };\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolveAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n}\n", "import { extensions, ExtensionType, utils } from '@pixi/core';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport { Loader } from './loader/Loader';\nimport { loadTextures } from './loader/parsers';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nimport type { FormatDetectionParser } from './detections';\nimport type { LoadAsset } from './loader';\nimport type { LoadTextureConfig } from './loader/parsers';\nimport type { ResolveAsset, ResolverBundle, ResolverManifest } from './resolver';\nimport type { BundleIdentifierOptions } from './resolver/Resolver';\n\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @memberof PIXI\n */\nexport interface AssetsPreferences extends LoadTextureConfig, GlobalMixins.AssetsPreferences {}\n\n/**\n * Initialization options object for Asset Class.\n * @memberof PIXI\n */\nexport interface AssetInitOptions\n{\n    // basic...\n    /** a base path for any assets loaded */\n    basePath?: string;\n\n    /** a default URL parameter string to append to all assets loaded */\n    defaultSearchParams?: string | Record<string, any>;\n\n    /**\n     * a manifest to tell the asset loader upfront what all your assets are\n     * this can be the manifest object itself, or a URL to the manifest.\n     */\n    manifest?: string | ResolverManifest;\n    /**\n     * optional preferences for which textures preferences you have when resolving assets\n     * for example you might set the resolution to 0.5 if the user is on a rubbish old phone\n     * or you might set the resolution to 2 if the user is on a retina display\n     */\n    texturePreference?: {\n        /** the resolution order you prefer, can be an array (priority order - first is prefered) or a single resolutions  */\n        resolution?: number | number[];\n        /** the formats you prefer, by default this will be:  ['avif', 'webp', 'png', 'jpg', 'jpeg'] */\n        format?: string | string[];\n    };\n\n    /** advanced - override how bundlesIds are generated */\n    bundleIdentifier?: BundleIdentifierOptions;\n\n    /** Optional loader preferences */\n    preferences?: Partial<AssetsPreferences>;\n}\n\n/**\n * A one stop shop for all Pixi resource management!\n * Super modern and easy to use, with enough flexibility to customize and do what you need!\n * @memberof PIXI\n * @namespace Assets\n *\n * Only one Asset Class exists accessed via the Global Asset object.\n *\n * It has four main responsibilities:\n * 1. Allows users to map URLs to keys and resolve them according to the user's browser capabilities\n * 2. Loads the resources and transforms them into assets that developers understand.\n * 3. Caches the assets and provides a way to access them.\n * 4. Allow developers to unload assets and clear the cache.\n *\n * It also has a few advanced features:\n * 1. Allows developers to provide a manifest upfront of all assets and help manage them via 'bundles'.\n * 2. Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature,\n * in-game loading bars can be a thing of the past!\n *\n * ### Assets Loading\n *\n * Do not be afraid to load things multiple times - under the hood, it will NEVER load anything more than once.\n *\n * For example:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * promise1 = Assets.load('bunny.png')\n * promise2 = Assets.load('bunny.png')\n *\n * // promise1 === promise2\n * ```\n *\n * Here both promises will be the same. Once resolved... Forever resolved! It makes for really easy resource management!\n *\n * Out of the box it supports the following files:\n * - textures (avif, webp, png, jpg, gif, svg)\n * - sprite sheets (json)\n * - bitmap fonts (xml, fnt, txt)\n * - web fonts (ttf, woff, woff2)\n * - json files (json)\n * - text files (txt)\n *\n * More types can be added fairly easily by creating additional loader parsers.\n *\n * ### Textures\n * - Textures are loaded as ImageBitmap on a worker thread where possible.\n * Leading to much less janky load + parse times.\n * - By default, we will prefer to load AVIF and WebP image files if you specify them.\n * But if the browser doesn't support AVIF or WebP we will fall back to png and jpg.\n * - Textures can also be accessed via Texture.from(...) and now use this asset manager under the hood!\n * - Don't worry if you set preferences for textures that don't exist (for example you prefer 2x resolutions images\n *  but only 1x is available for that texture, the Asset manager will pick that up as a fallback automatically)\n *\n * #### Sprite sheets\n * - It's hard to know what resolution a sprite sheet is without loading it first, to address this\n * there is a naming convention we have added that will let Pixi understand the image format and resolution\n * of the spritesheet via its file name:\n *\n * `my-spritesheet{resolution}.{imageFormat}.json`\n *\n * For example:\n *\n * `my-spritesheet@2x.webp.json` // 2x resolution, WebP sprite sheet\n * `my-spritesheet@0.5x.png.json` // 0.5x resolution, png sprite sheet\n *\n * This is optional! You can just load a sprite sheet as normal.\n * This is only useful if you have a bunch of different res / formatted spritesheets.\n *\n * ### Fonts\n * Web fonts will be loaded with all weights.\n * It is possible to load only specific weights by doing the following:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Load specific weights..\n * await Assets.load({\n *     data: {\n *         weights: ['normal'], // Only loads the weight\n *     },\n *     src: `outfit.woff2`,\n * });\n *\n * // Load everything...\n * await Assets.load(`outfit.woff2`);\n * ```\n *\n * ### Background Loading\n * Background loading will load stuff for you passively behind the scenes. To minimize jank,\n * it will only load one asset at a time. As soon as a developer calls `Assets.load(...)` the\n * background loader is paused and requested assets are loaded as a priority.\n * Don't worry if something is in there that's already loaded, it will just get skipped!\n *\n * You still need to call `Assets.load(...)` to get an asset that has been loaded in the background.\n * It's just that this promise will resolve instantly if the asset\n * has already been loaded.\n *\n * ### Manifest and Bundles\n * - Manifest is a JSON file that contains a list of all assets and their properties.\n * - Bundles are a way to group assets together.\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Manifest Example\n * const manifest = {\n *     bundles: [\n *         {\n *             name: 'load-screen',\n *             assets: [\n *                 {\n *                     name: 'background',\n *                     srcs: 'sunset.png',\n *                 },\n *                 {\n *                     name: 'bar',\n *                     srcs: 'load-bar.{png,webp}',\n *                 },\n *             ],\n *         },\n *         {\n *             name: 'game-screen',\n *             assets: [\n *                 {\n *                     name: 'character',\n *                     srcs: 'robot.png',\n *                 },\n *                 {\n *                     name: 'enemy',\n *                     srcs: 'bad-guy.png',\n *                 },\n *             ],\n *         },\n *     ]\n * };\n *\n * await Asset.init({ manifest });\n *\n * // Load a bundle...\n * loadScreenAssets = await Assets.loadBundle('load-screen');\n * // Load another bundle...\n * gameScreenAssets = await Assets.loadBundle('game-screen');\n * ```\n * @example\n * import { Assets } from 'pixi.js';\n *\n * const bunny = await Assets.load('bunny.png');\n */\nexport class AssetsClass\n{\n    /** the resolver to map various urls */\n    public resolver: Resolver;\n    /**\n     * The loader, loads stuff!\n     * @type {PIXI.AssetLoader}\n     */\n    public loader: Loader;\n    /**\n     * The global cache of all assets within PixiJS\n     * @type {PIXI.Cache}\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Best practice is to call this function before any loading commences\n     * Initiating is the best time to add any customization to the way things are loaded.\n     *\n     * you do not need to call this for the Asset class to work, only if you want to set any initial properties\n     * @param options - options to initialize the Asset manager with\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            console.warn('[Assets]AssetManager already initialized, did you load before calling this Asset.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.defaultSearchParams)\n        {\n            this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        }\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.bundleIdentifier)\n        {\n            this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<ResolverManifest>(manifest);\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        let formats: string[] = [];\n\n        if (options.texturePreference?.format)\n        {\n            const formatPref = options.texturePreference?.format;\n\n            formats = (typeof formatPref === 'string') ? [formatPref] : formatPref;\n\n            // we should remove any formats that are not supported by the browser\n            for (const detection of this._detections)\n            {\n                if (!await detection.test())\n                {\n                    formats = await detection.remove(formats);\n                }\n            }\n        }\n        else\n        {\n            // we should add any formats that are supported by the browser\n            for (const detection of this._detections)\n            {\n                if (await detection.test())\n                {\n                    formats = await detection.add(formats);\n                }\n            }\n        }\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n\n        if (options.preferences)\n        {\n            this.setPreferences(options.preferences);\n        }\n    }\n\n    /**\n     * Allows you to specify how to resolve any assets load requests.\n     * There are a few ways to add things here as shown below:\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Simple\n     * Assets.add('bunnyBooBoo', 'bunny.png');\n     * const bunny = await Assets.load('bunnyBooBoo');\n     *\n     * // Multiple keys:\n     * Assets.add(['burger', 'chicken'], 'bunny.png');\n     *\n     * const bunny = await Assets.load('burger');\n     * const bunny2 = await Assets.load('chicken');\n     *\n     * // passing options to to the object\n     * Assets.add(\n     *     'bunnyBooBooSmooth',\n     *     'bunny{png,webp}',\n     *     { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n     * );\n     *\n     * // Multiple assets\n     *\n     * // The following all do the same thing:\n     *\n     * Assets.add('bunnyBooBoo', 'bunny{png,webp}');\n     *\n     * Assets.add('bunnyBooBoo', [\n     *     'bunny.png',\n     *     'bunny.webp',\n     * ]);\n     *\n     * Assets.add('bunnyBooBoo', [\n     *     {\n     *         format: 'png',\n     *         src: 'bunny.png',\n     *     },\n     *     {\n     *         format: 'webp',\n     *         src: 'bunny.webp',\n     *     },\n     * ]);\n     *\n     * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n     * @param keysIn - the key or keys that you will reference when loading this asset\n     * @param assetsIn - the asset or assets that will be chosen from when loading via the specified key\n     * @param data - asset-specific data that will be passed to the loaders\n     * - Useful if you want to initiate loaded objects with specific data\n     */\n    public add(keysIn: string | string[], assetsIn: string | (ResolveAsset | string)[], data?: unknown): void\n    {\n        this.resolver.add(keysIn, assetsIn, data);\n    }\n\n    /**\n     * Loads your assets! You pass in a key or URL and it will return a promise that\n     * resolves to the loaded asset. If multiple assets a requested, it will return a hash of assets.\n     *\n     * Don't worry about loading things multiple times, behind the scenes assets are only ever loaded\n     * once and the same promise reused behind the scenes so you can safely call this function multiple\n     * times with the same key and it will always return the same asset.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * Assets.add('thumper', 'bunny.png');\n     * Assets.add('chicko', 'chicken.png');\n     *\n     * // Load multiple assets:\n     * const textures = await Assets.load(['thumper', 'chicko']); // => {thumper: Texture, chicko: Texture}\n     * @param urls - the urls to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage\n     * (0.0 - 1.0) of the assets loaded.\n     * @returns - the assets that were loaded, either a single asset or a hash of assets\n     */\n    public async load<T = any>(\n        urls: string | LoadAsset,\n        onProgress?: ProgressCallback,\n    ): Promise<T>;\n    public async load<T = any>(\n        urls: string[] | LoadAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        urls: string | string[] | LoadAsset | LoadAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray = convertToList<ResolveAsset>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    this.resolver.add(url.src as string, url);\n\n                    return url.src;\n                }\n\n                if (!this.resolver.hasKey(url))\n                {\n                    this.resolver.add(url, url);\n                }\n\n                return url;\n            });\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can load them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const assets = await Assets.loadBundle('animals');\n     * @param bundleId - the id of the bundle to add\n     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: ResolverBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Bundles are a way to load multiple assets at once.\n     * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n     * you can also add bundles via `addBundle`\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     name: 'background',\n     *                     srcs: 'sunset.png',\n     *                 },\n     *                 {\n     *                     name: 'bar',\n     *                     srcs: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     name: 'character',\n     *                     srcs: 'robot.png',\n     *                 },\n     *                 {\n     *                     name: 'enemy',\n     *                     srcs: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * await Asset.init({ manifest });\n     *\n     * // Load a bundle...\n     * loadScreenAssets = await Assets.loadBundle('load-screen');\n     * // Load another bundle...\n     * gameScreenAssets = await Assets.loadBundle('game-screen');\n     * @param bundleIds - the bundle id or ids to load\n     * @param onProgress - Optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n     * of the assets loaded. Do not use this function to detect when assets are complete and available,\n     * instead use the Promise returned by this function.\n     * @returns all the bundles assets or a hash of assets for each bundle specified\n     */\n    public async loadBundle(bundleIds: string | string[], onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = () =>\n        {\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n\n            total += Object.keys(resolveResult).length;\n\n            return this._mapLoadToResolve(resolveResult, _onProgress)\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n     *\n     * An example of this might be that you would background load game assets after your inital load.\n     * then when you got to actually load your game screen assets when a player goes to the game - the loading\n     * would already have stared or may even be complete, saving you having to show an interim load bar.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.backgroundLoad('bunny.png');\n     *\n     * // later on in your app...\n     * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n     * @param urls - the url / urls you want to background load\n     */\n    public async backgroundLoad(urls: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n     * this can only be used if the loader has been initiated with a manifest\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *                 name: 'load-screen',\n     *                 assets: [...],\n     *             },\n     *             ...\n     *         ],\n     *     },\n     * });\n     *\n     * Assets.backgroundLoadBundle('load-screen');\n     *\n     * // Later on in your app...\n     * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n     * @param bundleIds - the bundleId / bundleIds you want to background load\n     */\n    public async backgroundLoadBundle(bundleIds: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. If the asset has not yet been loaded,\n     * it will return undefined. So it's on you! When in doubt just use `Assets.load` instead.\n     * (Remember, the loader will never load things more than once!)\n     * @param keys - The key or keys for the assets that you want to access\n     * @returns - The assets or hash of assets requested\n     */\n    public get<T = any>(keys: string): T;\n    public get<T = any>(keys: string[]): Record<string, T>;\n    public get<T = any>(keys: string | string[]): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param onProgress - the progress callback\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolveAsset | Record<string, ResolveAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = Object.values(resolveResults);\n        const resolveKeys = Object.keys(resolveResults);\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load<T>(resolveArray, onProgress);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult, i) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            out[resolveKeys[i]] = asset;\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n     * this will make sure to destroy any assets and release them from memory.\n     * Once unloaded, you will need to load the asset again.\n     *\n     * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n     *\n     * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n     * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * await Assets.unload('http://some.url.com/image.png')\n     *\n     * // myImageTexture will be destroyed now.\n     *\n     * // Unload multiple assets:\n     * const textures = await Assets.unload(['thumper', 'chicko']);\n     * @param urls - the urls to unload\n     */\n    public async unload(\n        urls: string | string[] | LoadAsset | LoadAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | LoadAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Bundles are a way to manage multiple assets at once.\n     * this will unload all files in a bundle.\n     *\n     * once a bundle has been unloaded, you need to load it again to have access to the assets.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle({\n     *     'thumper': 'http://some.url.com/thumper.png',\n     * })\n     *\n     * const assets = await Assets.loadBundle('thumper');\n     *\n     * // Now to unload...\n     *\n     * await Assets.unloadBundle('thumper');\n     *\n     * // All assets in the assets object will now have been destroyed and purged from the cache\n     * @param bundleIds - the bundle id or ids to unload\n     */\n    public async unloadBundle(bundleIds: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolveAsset | Record<string, ResolveAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /** All the detection parsers currently added to the Assets class. */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n\n    /**\n     * @deprecated since 7.2.0\n     * @see {@link Assets.setPreferences}\n     */\n    public get preferWorkers(): boolean\n    {\n        return loadTextures.config.preferWorkers;\n    }\n    public set preferWorkers(value: boolean)\n    {\n        // #if _DEBUG\n        utils.deprecation('7.2.0', 'Assets.prefersWorkers is deprecated, '\n            + 'use Assets.setPreferences({ preferWorkers: true }) instead.');\n        // #endif\n        this.setPreferences({ preferWorkers: value });\n    }\n\n    /**\n     * General setter for preferences. This is a helper function to set preferences on all parsers.\n     * @param preferences - the preferences to set\n     */\n    public setPreferences(preferences: Partial<AssetsPreferences>): void\n    {\n        // Find matching config keys in loaders with preferences\n        // and set the values\n        this.loader.parsers.forEach((parser) =>\n        {\n            if (!parser.config) return;\n\n            (Object.keys(parser.config) as (keyof AssetsPreferences)[])\n                .filter((key) => key in preferences)\n                .forEach((key) =>\n                {\n                    parser.config[key] = preferences[key];\n                });\n        });\n    }\n}\n\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\n", "import { extensions, ExtensionType, Texture } from '@pixi/core';\n\nimport type { CacheParser } from '../CacheParser';\n\nexport const cacheTextureArray: CacheParser<Texture[]> = {\n    extension: ExtensionType.CacheParser,\n\n    test: (asset: any[]) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n\n    getCacheableAssets: (keys: string[], asset: Texture[]) =>\n    {\n        const out: Record<string, Texture> = {};\n\n        keys.forEach((key: string) =>\n        {\n            asset.forEach((item: Texture, i: number) =>\n            {\n                out[key + (i === 0 ? '' : i + 1)] = item;\n            });\n        });\n\n        return out;\n    }\n};\n\nextensions.add(cacheTextureArray);\n", "import { extensions, ExtensionType, settings } from '@pixi/core';\n\nimport type { FormatDetectionParser } from '..';\n\nexport const detectAvif: FormatDetectionParser = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 1,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        if (!globalThis.createImageBitmap) return false;\n\n        // eslint-disable-next-line max-len\n        const avifData = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=';\n        const blob = await settings.ADAPTER.fetch(avifData).then((r) => r.blob());\n\n        return createImageBitmap(blob).then(() => true, () => false);\n    },\n    add: async (formats) => [...formats, 'avif'],\n    remove: async (formats) => formats.filter((f) => f !== 'avif'),\n};\n\nextensions.add(detectAvif);\n", "import { extensions, ExtensionType, settings } from '@pixi/core';\n\nimport type { FormatDetectionParser } from '..';\n\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        if (!globalThis.createImageBitmap) return false;\n\n        const webpData = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=';\n        const blob = await settings.ADAPTER.fetch(webpData).then((r) => r.blob());\n\n        return createImageBitmap(blob).then(() => true, () => false);\n    },\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n\nextensions.add(detectWebp);\n", "import { extensions, ExtensionType } from '@pixi/core';\n\nimport type { FormatDetectionParser } from '..';\n\nconst imageFormats = ['png', 'jpg', 'jpeg'];\n\nexport const detectDefaults = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: -1,\n    },\n    test: (): Promise<boolean> => Promise.resolve(true),\n    add: async (formats) => [...formats, ...imageFormats],\n    remove: async (formats) => formats.filter((f) => !imageFormats.includes(f)),\n} as FormatDetectionParser;\n\nextensions.add(detectDefaults);\n", "\n//# sourceMappingURL=types.mjs.map\n", "import './parsers/index.mjs';\nimport './types.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { extensions, ExtensionType, settings } from '@pixi/core';\nimport { loadTextures } from '../../loader';\n\nimport type { ResolveAsset, ResolveURLParser } from '../types';\n\nexport const resolveTextureUrl = {\n    extension: ExtensionType.ResolveParser,\n    test: loadTextures.test,\n    parse: (value: string): ResolveAsset =>\n        ({\n            resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format: value.split('.').pop(),\n            src: value,\n        }),\n} as ResolveURLParser;\n\nextensions.add(resolveTextureUrl);\n", "import { extensions, ExtensionType } from '@pixi/core';\n\nimport type { CacheParser } from './cache';\nimport type { FormatDetectionParser } from './detections';\nimport type { LoaderParser } from './loader';\nimport type { ResolveURLParser } from './resolver';\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n/**\n * This developer convenience object allows developers to group\n * together the various asset parsers into a single object.\n * @memberof PIXI\n */\ninterface AssetExtension<ASSET = any, META_DATA = any>\n{\n    extension: ExtensionType.Asset,\n    loader?: Partial<LoaderParser<ASSET, META_DATA>>,\n    resolver?: Partial<ResolveURLParser>,\n    cache?: Partial<CacheParser<ASSET>>,\n    detection?: Partial<FormatDetectionParser>,\n}\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n\nexport type { AssetExtension };\n", "\n//# sourceMappingURL=CacheParser.mjs.map\n", "export { cacheTextureArray } from './cacheTextureArray.mjs';\n//# sourceMappingURL=index.mjs.map\n", "export { Cache } from './Cache.mjs';\nimport './CacheParser.mjs';\nimport './parsers/index.mjs';\n//# sourceMappingURL=index.mjs.map\n", "export { detectAvif } from './detectAvif.mjs';\nexport { detectWebp } from './detectWebp.mjs';\nexport { detectDefaults } from './detectDefaults.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import './parsers/index.mjs';\n//# sourceMappingURL=index.mjs.map\n", "export { resolveTextureUrl } from './resolveTextureUrl.mjs';\n//# sourceMappingURL=index.mjs.map\n", "\n//# sourceMappingURL=types.mjs.map\n", "import './parsers/index.mjs';\nimport './types.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import './AssetExtension.mjs';\nexport { Assets, AssetsClass } from './Assets.mjs';\nimport './cache/index.mjs';\nimport './detections/index.mjs';\nimport './loader/index.mjs';\nimport './resolver/index.mjs';\nimport './utils/index.mjs';\nexport { Cache } from './cache/Cache.mjs';\nexport { cacheTextureArray } from './cache/parsers/cacheTextureArray.mjs';\nexport { detectAvif } from './detections/parsers/detectAvif.mjs';\nexport { detectWebp } from './detections/parsers/detectWebp.mjs';\nexport { detectDefaults } from './detections/parsers/detectDefaults.mjs';\nexport { LoaderParserPriority } from './loader/parsers/LoaderParser.mjs';\nexport { loadJson } from './loader/parsers/loadJson.mjs';\nexport { loadTxt } from './loader/parsers/loadTxt.mjs';\nexport { getFontFamilyName, loadWebFont } from './loader/parsers/loadWebFont.mjs';\nexport { loadSVG } from './loader/parsers/textures/loadSVG.mjs';\nexport { loadImageBitmap, loadTextures } from './loader/parsers/textures/loadTextures.mjs';\nexport { createTexture } from './loader/parsers/textures/utils/createTexture.mjs';\nexport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl.mjs';\nexport { checkDataUrl } from './utils/checkDataUrl.mjs';\nexport { checkExtension } from './utils/checkExtension.mjs';\nexport { convertToList } from './utils/convertToList.mjs';\nexport { copySearchParams } from './utils/copySearchParams.mjs';\nexport { createStringVariations } from './utils/createStringVariations.mjs';\nexport { isSingleItem } from './utils/isSingleItem.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { copySearchParams, LoaderParserPriority } from '@pixi/assets';\nimport { extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { BitmapFont } from './BitmapFont';\nimport { TextFormat, XMLStringFormat } from './formats';\n\nimport type { LoadAsset, Loader, LoaderParser } from '@pixi/assets';\nimport type { Texture } from '@pixi/core';\nimport type { BitmapFontData } from './BitmapFontData';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    name: 'loadBitmapFont',\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(utils.path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return TextFormat.test(data) || XMLStringFormat.test(data);\n    },\n\n    async parse(asset: string, data: LoadAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const fontData: BitmapFontData = TextFormat.test(asset)\n            ? TextFormat.parse(asset)\n            : XMLStringFormat.parse(asset);\n\n        const { src } = data;\n        const { page: pages } = fontData;\n        const textureUrls = [];\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = utils.path.join(utils.path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push(imagePath);\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url]);\n\n        return BitmapFont.install(fontData, textures, true);\n    },\n\n    async load(url: string, _options: LoadAsset): Promise<string>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        return response.text();\n    },\n\n    unload(bitmapFont: BitmapFont): void\n    {\n        bitmapFont.destroy();\n    }\n} as LoaderParser<BitmapFont | string>;\n\nextensions.add(loadBitmapFont);\n", "\n//# sourceMappingURL=BitmapTextStyle.mjs.map\n", "export { BitmapFont } from './BitmapFont.mjs';\nexport { BitmapFontData } from './BitmapFontData.mjs';\nexport { BitmapText } from './BitmapText.mjs';\nimport './BitmapTextStyle.mjs';\nexport { autoDetectFormat } from './formats/index.mjs';\nexport { loadBitmapFont } from './loadBitmapFont.mjs';\nexport { TextFormat } from './formats/TextFormat.mjs';\nexport { XMLFormat } from './formats/XMLFormat.mjs';\nexport { XMLStringFormat } from './formats/XMLStringFormat.mjs';\n//# sourceMappingURL=index.mjs.map\n", "/**\n * Supported line joints in `PIXI.LineStyle` for graphics.\n * @see PIXI.Graphics#lineStyle\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\n * @memberof PIXI\n * @static\n * @enum {string}\n */\nexport enum LINE_JOIN\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * 'miter': make a sharp corner where outer part of lines meet\n     * @default miter\n     */\n    MITER = 'miter',\n    /**\n     * 'bevel': add a square butt at each end of line segment and fill the triangle at turn\n     * @default bevel\n     */\n    BEVEL = 'bevel',\n    /**\n     * 'round': add an arc at the joint\n     * @default round\n     */\n    ROUND = 'round'\n}\n\n/**\n * Support line caps in `PIXI.LineStyle` for graphics.\n * @see PIXI.Graphics#lineStyle\n * @memberof PIXI\n * @static\n * @enum {string}\n */\nexport enum LINE_CAP\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * 'butt': don't add any cap at line ends (leaves orthogonal edges)\n     * @default butt\n     */\n    BUTT = 'butt',\n    /**\n     * 'round': add semicircle at ends\n     * @default round\n     */\n    ROUND = 'round',\n    /**\n     * 'square': add square at end (like `BUTT` except more length at end)\n     * @default square\n     */\n    SQUARE = 'square'\n}\n\n/**\n * @memberof PIXI\n * @deprecated\n */\nexport interface IGraphicsCurvesSettings\n{\n    adaptive: boolean;\n    maxLength: number;\n    minSegments: number;\n    maxSegments: number;\n\n    epsilon: number;\n\n    _segmentsCount(length: number, defaultSegments?: number): number;\n}\n\n/**\n * @private\n */\nexport const curves = {\n    adaptive: true,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments:  2048,\n\n    epsilon: 0.0001,\n\n    _segmentsCount(length: number, defaultSegments = 20)\n    {\n        if (!this.adaptive || !length || isNaN(length))\n        {\n            return defaultSegments;\n        }\n\n        let result = Math.ceil(length / this.maxLength);\n\n        if (result < this.minSegments)\n        {\n            result = this.minSegments;\n        }\n        else if (result > this.maxSegments)\n        {\n            result = this.maxSegments;\n        }\n\n        return result;\n    },\n};\n\n/**\n * @static\n * @readonly\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @deprecated since 7.1.0\n * @see PIXI.Graphics.curves\n */\nexport const GRAPHICS_CURVES = curves;\n", "import type { IShape, Matrix, SHAPES } from '@pixi/core';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/**\n * A class to contain data useful for Graphics objects\n * @memberof PIXI\n */\nexport class GraphicsData\n{\n    /**\n     * The shape object to draw.\n     * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n     */\n    shape: IShape;\n\n    /** The style of the line. */\n    lineStyle: LineStyle;\n\n    /** The style of the fill. */\n    fillStyle: FillStyle;\n\n    /** The transform matrix. */\n    matrix: Matrix;\n\n    /** The type of the shape, see the Const.Shapes file for all the existing types, */\n    type: SHAPES;\n\n    /** The collection of points. */\n    points: number[] = [];\n\n    /** The collection of holes. */\n\n    holes: Array<GraphicsData> = [];\n\n    /**\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - the width of the line to draw\n     * @param lineStyle - the color of the line to draw\n     * @param matrix - Transform matrix\n     */\n    constructor(shape: IShape, fillStyle: FillStyle = null, lineStyle: LineStyle = null, matrix: Matrix = null)\n    {\n        this.shape = shape;\n        this.lineStyle = lineStyle;\n        this.fillStyle = fillStyle;\n        this.matrix = matrix;\n        this.type = shape.type;\n    }\n\n    /**\n     * Creates a new GraphicsData object with the same values as this one.\n     * @returns - Cloned GraphicsData object\n     */\n    public clone(): GraphicsData\n    {\n        return new GraphicsData(\n            this.shape,\n            this.fillStyle,\n            this.lineStyle,\n            this.matrix\n        );\n    }\n\n    /** Destroys the Graphics data. */\n    public destroy(): void\n    {\n        this.shape = null;\n        this.holes.length = 0;\n        this.holes = null;\n        this.points.length = 0;\n        this.points = null;\n        this.lineStyle = null;\n        this.fillStyle = null;\n    }\n}\n", "// for type only\nimport { SHAPES } from '@pixi/core';\n\nimport type { Circle, Ellipse, RoundedRectangle } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const points = graphicsData.points;\n\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n        else if (graphicsData.type === SHAPES.ELIP)\n        {\n            const ellipse = graphicsData.shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.width;\n            ry = ellipse.height;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            points.length = 0;\n\n            return;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        points.length = m;\n\n        if (m === 0)\n        {\n            return;\n        }\n\n        if (n === 0)\n        {\n            points.length = 8;\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        {\n            const x0 = dx + rx;\n            const y0 = dy;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n\n            if (dy)\n            {\n                const y2 = y - y0;\n\n                points[j3++] = x2;\n                points[j3++] = y2;\n                points[--j4] = y2;\n                points[--j4] = x1;\n            }\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        {\n            const x0 = dx;\n            const y0 = dy + ry;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x1;\n\n            if (dx)\n            {\n                points[j1++] = x2;\n                points[j1++] = y1;\n                points[--j4] = y2;\n                points[--j4] = x2;\n            }\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        let x;\n        let y;\n\n        if (graphicsData.type !== SHAPES.RREC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n\n            x = roundedRect.x + (roundedRect.width / 2);\n            y = roundedRect.y + (roundedRect.height / 2);\n        }\n\n        const matrix = graphicsData.matrix;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        vertPos++;\n\n        verts.push(points[0], points[1]);\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n\n        indices.push(center + 1, center, vertPos);\n    },\n};\n", "import { utils } from '@pixi/core';\n\nimport type { Polygon } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\nfunction fixOrientation(points: number[], hole = false)\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if ((!hole && area > 0) || (hole && area <= 0))\n    {\n        const n = m / 2;\n\n        for (let i = n + (n % 2); i < m; i += 2)\n        {\n            const i1 = m - i - 2;\n            const i2 = m - i - 1;\n            const i3 = i;\n            const i4 = i + 1;\n\n            [points[i1], points[i3]] = [points[i3], points[i1]];\n            [points[i2], points[i4]] = [points[i4], points[i2]];\n        }\n    }\n}\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildPoly: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        graphicsData.points = (graphicsData.shape as Polygon).points.slice();\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        let points = graphicsData.points;\n        const holes = graphicsData.holes;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length >= 6)\n        {\n            fixOrientation(points, false);\n\n            const holeArray = [];\n            // Process holes..\n\n            for (let i = 0; i < holes.length; i++)\n            {\n                const hole = holes[i];\n\n                fixOrientation(hole.points, true);\n\n                holeArray.push(points.length / 2);\n                points = points.concat(hole.points);\n            }\n\n            // sort color\n            const triangles = utils.earcut(points, holeArray, 2);\n\n            if (!triangles)\n            {\n                return;\n            }\n\n            const vertPos = verts.length / 2;\n\n            for (let i = 0; i < triangles.length; i += 3)\n            {\n                indices.push(triangles[i] + vertPos);\n                indices.push(triangles[i + 1] + vertPos);\n                indices.push(triangles[i + 2] + vertPos);\n            }\n\n            for (let i = 0; i < points.length; i++)\n            {\n                verts.push(points[i]);\n            }\n        }\n    },\n};\n", "import type { Rectangle } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape as Rectangle;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        if (!(width >= 0 && height >= 0))\n        {\n            return;\n        }\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        const vertPos = verts.length / 2;\n\n        verts.push(points[0], points[1],\n            points[2], points[3],\n            points[6], points[7],\n            points[4], points[5]);\n\n        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,\n            vertPos + 1, vertPos + 2, vertPos + 3);\n    },\n};\n", "// for type only\nimport { buildCircle } from './buildCircle';\n\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRoundedRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        buildCircle.build(graphicsData);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        buildCircle.triangulate(graphicsData, graphicsGeometry);\n    },\n};\n", "import { PI_2 } from '@pixi/core';\nimport { curves } from '../const';\n\ninterface IArcLikeShape\n{\n    cx: number;\n    cy: number;\n    radius: number;\n    startAngle: number;\n    endAngle: number;\n    anticlockwise: boolean;\n}\n\n/**\n * Utilities for arc curves.\n * @private\n */\nexport class ArcUtils\n{\n    /**\n     * Calculate information of the arc for {@link PIXI.Graphics.arcTo}.\n     * @private\n     * @param x1 - The x-coordinate of the first control point of the arc\n     * @param y1 - The y-coordinate of the first control point of the arc\n     * @param x2 - The x-coordinate of the second control point of the arc\n     * @param y2 - The y-coordinate of the second control point of the arc\n     * @param radius - The radius of the arc\n     * @param points - Collection of points to add to\n     * @returns - If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n     */\n    static curveTo(x1: number, y1: number, x2: number, y2: number, radius: number, points: Array<number>): IArcLikeShape\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n\n            return null;\n        }\n\n        const dd = (a1 * a1) + (b1 * b1);\n        const cc = (a2 * a2) + (b2 * b2);\n        const tt = (a1 * a2) + (b1 * b2);\n        const k1 = radius * Math.sqrt(dd) / mm;\n        const k2 = radius * Math.sqrt(cc) / mm;\n        const j1 = k1 * tt / dd;\n        const j2 = k2 * tt / cc;\n        const cx = (k1 * b2) + (k2 * b1);\n        const cy = (k1 * a2) + (k2 * a1);\n        const px = b1 * (k2 + j1);\n        const py = a1 * (k2 + j1);\n        const qx = b2 * (k1 + j2);\n        const qy = a2 * (k1 + j2);\n        const startAngle = Math.atan2(py - cy, px - cx);\n        const endAngle = Math.atan2(qy - cy, qx - cx);\n\n        return {\n            cx: (cx + x1),\n            cy: (cy + y1),\n            radius,\n            startAngle,\n            endAngle,\n            anticlockwise: (b1 * a2 > b2 * a1),\n        };\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     * @private\n     * @param _startX - Start x location of arc\n     * @param _startY - Start y location of arc\n     * @param cx - The x-coordinate of the center of the circle\n     * @param cy - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param endAngle - The ending angle, in radians\n     * @param _anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @param points - Collection of points to add to\n     */\n    static arc(_startX: number, _startY: number, cx: number, cy: number, radius: number,\n        startAngle: number, endAngle: number, _anticlockwise: boolean, points: Array<number>): void\n    {\n        const sweep = endAngle - startAngle;\n        const n = curves._segmentsCount(\n            Math.abs(sweep) * radius,\n            Math.ceil(Math.abs(sweep) / PI_2) * 40\n        );\n\n        const theta = (sweep) / (n * 2);\n        const theta2 = theta * 2;\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n        const segMinus = n - 1;\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n            const angle = ((theta) + startAngle + (theta2 * real));\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n    }\n}\n", "import type { FillStyle } from '../styles/FillStyle';\nimport type { LineStyle } from '../styles/LineStyle';\n\n/**\n * A structure to hold interim batch objects for Graphics.\n * @memberof PIXI.graphicsUtils\n */\nexport class BatchPart\n{\n    public style: LineStyle | FillStyle;\n    public start: number;\n    public size: number;\n    public attribStart: number;\n    public attribSize: number;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Begin batch part.\n     * @param style\n     * @param startIndex\n     * @param attribStart\n     */\n    public begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void\n    {\n        this.reset();\n        this.style = style;\n        this.start = startIndex;\n        this.attribStart = attribStart;\n    }\n\n    /**\n     * End batch part.\n     * @param endIndex\n     * @param endAttrib\n     */\n    public end(endIndex: number, endAttrib: number): void\n    {\n        this.attribSize = endAttrib - this.attribStart;\n        this.size = endIndex - this.start;\n    }\n\n    public reset(): void\n    {\n        this.style = null;\n        this.size = 0;\n        this.start = 0;\n        this.attribStart = 0;\n        this.attribSize = 0;\n    }\n}\n", "import { curves } from '../const';\n\n/**\n * Utilities for bezier curves\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     * @private\n     * @param fromX - Starting point x\n     * @param fromY - Starting point y\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns - Length of bezier curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number): number\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     * @ignore\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Path array to push points into\n     */\n    static curveTo(\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number,\n        points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = curves._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n", "import { Point, SHAPES } from '@pixi/core';\nimport { curves, LINE_CAP, LINE_JOIN } from '../const';\n\nimport type { Polygon } from '@pixi/core';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(\n        eix, eiy,\n        eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -curves.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(\n            cx, cy,\n            sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(\n                cx, cy,\n                cx + ((Math.sin(angle) * radius)), cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(\n            cx, cy,\n            ex, ey);\n    }\n    else\n    {\n        verts.push(\n            sx, sy,\n            cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(\n                cx + ((Math.sin(angle) * radius)), cy + ((Math.cos(angle) * radius)),\n                cx, cy);\n        }\n\n        verts.push(\n            ex, ey,\n            cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight), y0 - (perpy * innerWeight),\n        x0 + (perpx * outerWeight), y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === LINE_JOIN.ROUND)\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight), y1 - (perp1y * outerWeight),\n                    x1 + (perp1x * innerWeight), y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n        let join = style.join;\n\n        if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared)\n        {\n            join = LINE_JOIN.BEVEL;\n        }\n\n        if (insideMiterOk)\n        {\n            switch (join)\n            {\n                case LINE_JOIN.MITER:\n                {\n                    verts.push(\n                        imx, imy,\n                        omx, omy);\n                    break;\n                }\n                case LINE_JOIN.BEVEL:\n                {\n                    if (clockwise) /* rotating at inner angle */\n                    {\n                        verts.push(\n                            imx, imy, // inner miter point\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight), // first segment's outer vertex\n                            imx, imy, // inner miter point\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                    }\n                    else /* rotating at outer angle */\n                    {\n                        verts.push(\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight), // first segment's inner vertex\n                            omx, omy, // outer miter point\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight), // second segment's outer vertex\n                            omx, omy); // outer miter point\n                    }\n\n                    indexCount += 2;\n                    break;\n                }\n                case LINE_JOIN.ROUND:\n                {\n                    if (clockwise) /* arc is outside */\n                    {\n                        verts.push(\n                            imx, imy,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                        indexCount += round(\n                            x1, y1,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                            verts, true\n                        ) + 4;\n\n                        verts.push(\n                            imx, imy,\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                    }\n                    else /* arc is inside */\n                    {\n                        verts.push(\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            omx, omy);\n\n                        indexCount += round(\n                            x1, y1,\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            verts, false\n                        ) + 4;\n\n                        verts.push(\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            omx, omy);\n                    }\n                    break;\n                }\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(\n                x1 - (perpx * innerWeight), y1 - (perpy * innerWeight), // first segment's inner vertex\n                x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n            switch (join)\n            {\n                case LINE_JOIN.MITER:\n                {\n                    if (clockwise)\n                    {\n                        verts.push(\n                            omx, omy, // inner miter point\n                            omx, omy); // inner miter point\n                    }\n                    else\n                    {\n                        verts.push(\n                            imx, imy, // outer miter point\n                            imx, imy); // outer miter point\n                    }\n                    indexCount += 2;\n                    break;\n                }\n                case LINE_JOIN.ROUND:\n                {\n                    if (clockwise) /* arc is outside */\n                    {\n                        indexCount += round(\n                            x1, y1,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                            verts, true\n                        ) + 2;\n                    }\n                    else /* arc is inside */\n                    {\n                        indexCount += round(\n                            x1, y1,\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            verts, false\n                        ) + 2;\n                    }\n                    break;\n                }\n            }\n            verts.push(\n                x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight), // second segment's inner vertex\n                x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(\n        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = curves.epsilon * curves.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n", "import { curves } from '../const';\n\n/**\n * Utilities for quadratic curves.\n * @private\n */\nexport class QuadraticUtils\n{\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     * @private\n     * @param fromX - x-coordinate of curve start point\n     * @param fromY - y-coordinate of curve start point\n     * @param cpX - x-coordinate of curve control point\n     * @param cpY - y-coordinate of curve control point\n     * @param toX - x-coordinate of curve end point\n     * @param toY - y-coordinate of curve end point\n     * @returns - Length of quadratic curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        toX: number, toY: number): number\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n            (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                    ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                )\n        ) / (4.0 * a32);\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     * @private\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Points to add segments to.\n     */\n    static curveTo(cpX: number, cpY: number, toX: number, toY: number, points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const n = curves._segmentsCount(\n            QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)\n        );\n\n        let xa = 0;\n        let ya = 0;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n    }\n}\n", "/**\n * Generalized convenience utilities for Graphics.\n * @namespace graphicsUtils\n * @memberof PIXI\n */\n\n// for type only\nimport { SHAPES } from '@pixi/core';\nimport { buildCircle } from './buildCircle';\nimport { buildPoly } from './buildPoly';\nimport { buildRectangle } from './buildRectangle';\nimport { buildRoundedRectangle } from './buildRoundedRectangle';\n\nimport type { BatchDrawCall } from '@pixi/core';\nimport type { BatchPart } from './BatchPart';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\nexport * from './ArcUtils';\nexport * from './BatchPart';\nexport * from './BezierUtils';\nexport * from './buildCircle';\nexport * from './buildLine';\nexport * from './buildPoly';\nexport * from './buildRectangle';\nexport * from './buildRoundedRectangle';\nexport * from './QuadraticUtils';\n\n/**\n * Map of fill commands for each shape type.\n * @memberof PIXI.graphicsUtils\n * @member {object} FILL_COMMANDS\n */\nexport const FILL_COMMANDS: Record<SHAPES, IShapeBuildCommand> = {\n    [SHAPES.POLY]: buildPoly,\n    [SHAPES.CIRC]: buildCircle,\n    [SHAPES.ELIP]: buildCircle,\n    [SHAPES.RECT]: buildRectangle,\n    [SHAPES.RREC]: buildRoundedRectangle,\n};\n\n/**\n * Batch pool, stores unused batches for preventing allocations.\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.graphicsUtils.BatchPart>} BATCH_POOL\n */\nexport const BATCH_POOL: Array<BatchPart> = [];\n\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.BatchDrawCall>} DRAW_CALL_POOL\n */\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\n", "import {\n    BaseTexture,\n    BatchDrawCall,\n    BatchGeometry,\n    BatchTextureArray,\n    Color,\n    DRAW_MODES,\n    Point,\n    WRAP_MODES\n} from '@pixi/core';\nimport { Bounds } from '@pixi/display';\nimport { GraphicsData } from './GraphicsData';\nimport {\n    BATCH_POOL, BatchPart, buildLine,\n    buildPoly,\n    DRAW_CALL_POOL,\n    FILL_COMMANDS\n} from './utils';\n\nimport type { IPointData, IShape, Matrix, Texture } from '@pixi/core';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\nconst tmpPoint = new Point();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    /** The maximum number of points to consider an object \"batchable\", able to be batched by the renderer's batch system. */\n    public static BATCHABLE_SIZE = 100;\n\n    /** Minimal distance between points that are considered different. Affects line tesselation. */\n    public closePointEps = 1e-4;\n\n    /** Padding to add to the bounds. */\n    public boundsPadding = 0;\n\n    uvsFloat32: Float32Array = null;\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable = false;\n\n    /** An array of points to draw, 2 numbers per point */\n    points: number[] = [];\n\n    /** The collection of colors */\n    colors: number[] = [];\n\n    /** The UVs collection */\n    uvs: number[] = [];\n\n    /** The indices of the vertices */\n    indices: number[] = [];\n\n    /** Reference to the texture IDs. */\n    textureIds: number[] = [];\n\n    /**\n     * The collection of drawn shapes.\n     * @member {PIXI.GraphicsData[]}\n     */\n    graphicsData: Array<GraphicsData> = [];\n\n    /**\n     * List of current draw calls drived from the batches.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    drawCalls: Array<BatchDrawCall> = [];\n\n    /** Batches need to regenerated if the geometry is updated. */\n    batchDirty = -1;\n\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    batches: Array<BatchPart> = [];\n\n    /** Used to detect if the graphics object has changed. */\n    protected dirty = 0;\n\n    /** Used to check if the cache is dirty. */\n    protected cacheDirty = -1;\n\n    /** Used to detect if we cleared the graphicsData. */\n    protected clearDirty = 0;\n\n    /** Index of the last batched shape in the stack of calls. */\n    protected shapeIndex = 0;\n\n    /** Cached bounds. */\n    protected _bounds: Bounds = new Bounds();\n\n    /** The bounds dirty flag. */\n    protected boundsDirty = -1;\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * Since 6.5.0, bounds of the graphics geometry are calculated based on the vertices of generated geometry.\n     * Since shapes or strokes with full transparency (`alpha: 0`) will not generate geometry, they are not considered\n     * when calculating bounds for the graphics geometry. See PR [#8343]{@link https://github.com/pixijs/pixijs/pull/8343}\n     * and issue [#8623]{@link https://github.com/pixijs/pixijs/pull/8623}.\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        this.updateBatches();\n\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /** Call if you changed graphicsData manually. Empties all batch buffers. */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     * @returns - This GraphicsGeometry object. Good for chaining method calls\n     */\n    public clear(): GraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - Defines style of the fill.\n     * @param lineStyle - Defines style of the lines.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): GraphicsGeometry\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawHole(shape: IShape, matrix: Matrix = null): GraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /** Destroys the GraphicsGeometry object. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     */\n    updateBatches(): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            if (fillStyle.visible || lineStyle.visible)\n            {\n                this.processHoles(data.holes);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (batchPart)\n        {\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        const need32 = attrib > 0xffff;\n\n        // prevent allocation when length is same as buffer\n        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length\n            && need32 === (this.indicesUint16.BYTES_PER_ELEMENT > 2))\n        {\n            this.indicesUint16.set(this.indices);\n        }\n        else\n        {\n            this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     * @param styleA\n     * @param styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!(styleA as LineStyle).native !== !!(styleB as LineStyle).native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /** Test geometry for batching process. */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /** Offset the indices so that it works with the batcher. */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     */\n    protected isBatchable(): boolean\n    {\n        // prevent heavy mesh batching\n        if (this.points.length > 0xffff * 2)\n        {\n            return false;\n        }\n\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if ((batches[i].style as LineStyle).native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /** Converts intermediate batches data to drawCalls. */\n    protected buildDrawCalls(): void\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup: BatchDrawCall = DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.texArray = new BatchTextureArray();\n        }\n        currentGroup.texArray.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const maxTextures = 8;\n\n            // Forced cast for checking `native` without errors\n            const style = data.style as LineStyle;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = maxTextures;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === maxTextures)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.texArray = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.texArray.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    // Hack! Because texture has protected `touched`\n                    nextTexture.touched = 1;// touch;\n\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                    currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n            this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /** Packs attributes to single buffer. */\n    protected packAttributes(): void\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     * @param data\n     */\n    protected processFill(data: GraphicsData): void\n    {\n        if (data.holes.length)\n        {\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     * @param data\n     */\n    protected processLine(data: GraphicsData): void\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     * @param holes\n     */\n    protected processHoles(holes: Array<GraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /** Update the local bounds of the object. Expensive to use performance-wise. */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n        bounds.addVertexData((this.points as any), 0, this.points.length);\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     * @param points - Points to transform\n     * @param matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     * @param colors - List of colors to add to\n     * @param color - Color to add\n     * @param alpha - Alpha to use\n     * @param size - Number of colors to add\n     * @param offset\n     */\n    protected addColors(\n        colors: Array<number>,\n        color: number,\n        alpha: number,\n        size: number,\n        offset = 0): void\n    {\n        const bgr = Color.shared\n            .setValue(color)\n            .toLittleEndianNumber();\n\n        const result = Color.shared\n            .setValue(bgr)\n            .toPremultiplied(alpha);\n\n        colors.length = Math.max(colors.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            colors[offset + i] = result;\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     * @param textureIds\n     * @param id\n     * @param size\n     * @param offset\n     */\n    protected addTextureIds(\n        textureIds: Array<number>,\n        id: number,\n        size: number,\n        offset = 0): void\n    {\n        textureIds.length = Math.max(textureIds.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            textureIds[offset + i] = id;\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     * @param verts - Vertices\n     * @param uvs - UVs\n     * @param texture - Reference to Texture\n     * @param start - Index buffer start index.\n     * @param size - The size/length for index buffer.\n     * @param matrix - Optional transform for all points.\n     */\n    protected addUvs(\n        verts: Array<number>,\n        uvs: Array<number>,\n        texture: Texture,\n        start: number,\n        size: number,\n        matrix: Matrix = null): void\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     * @param uvs - array\n     * @param texture - region\n     * @param start - starting index for uvs\n     * @param size - how many points to adjust\n     */\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n", "import { Texture } from '@pixi/core';\n\nimport type { Matrix } from '@pixi/core';\n\n/**\n * Fill style object for Graphics.\n * @memberof PIXI\n */\nexport class FillStyle\n{\n    /**\n     * The hex color value used when coloring the Graphics object.\n     * @default 0xFFFFFF\n     */\n    public color = 0xFFFFFF;\n\n    /** The alpha value used when filling the Graphics object. */\n    public alpha = 1.0;\n\n    /**\n     * The texture to be used for the fill.\n     * @default 0\n     */\n    public texture: Texture = Texture.WHITE;\n\n    /**\n     * The transform applied to the texture.\n     * @default null\n     */\n    public matrix: Matrix = null;\n\n    /** If the current fill is visible. */\n    public visible = false;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /** Clones the object */\n    public clone(): FillStyle\n    {\n        const obj = new FillStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n\n        return obj;\n    }\n\n    /** Reset */\n    public reset(): void\n    {\n        this.color = 0xFFFFFF;\n        this.alpha = 1;\n        this.texture = Texture.WHITE;\n        this.matrix = null;\n        this.visible = false;\n    }\n\n    /** Destroy and don't use after this. */\n    public destroy(): void\n    {\n        this.texture = null;\n        this.matrix = null;\n    }\n}\n", "import { LINE_CAP, LINE_JOIN } from '../const';\nimport { FillStyle } from './FillStyle';\n\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n */\nexport class LineStyle extends FillStyle\n{\n    /** The width (thickness) of any lines drawn. */\n    public width = 0;\n\n    /** The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner). WebGL only. */\n    public alignment = 0.5;\n\n    /** If true the lines will be draw using LINES instead of TRIANGLE_STRIP. */\n    public native = false;\n\n    /**\n     * Line cap style.\n     * @member {PIXI.LINE_CAP}\n     * @default PIXI.LINE_CAP.BUTT\n     */\n    public cap = LINE_CAP.BUTT;\n\n    /**\n     * Line join style.\n     * @member {PIXI.LINE_JOIN}\n     * @default PIXI.LINE_JOIN.MITER\n     */\n    public join = LINE_JOIN.MITER;\n\n    /** Miter limit. */\n    public miterLimit = 10;\n\n    /** Clones the object. */\n    public clone(): LineStyle\n    {\n        const obj = new LineStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.native = this.native;\n        obj.cap = this.cap;\n        obj.join = this.join;\n        obj.miterLimit = this.miterLimit;\n\n        return obj;\n    }\n\n    /** Reset the line style to default. */\n    public reset(): void\n    {\n        super.reset();\n\n        // Override default line style color\n        this.color = 0x0;\n\n        this.alignment = 0.5;\n        this.width = 0;\n        this.native = false;\n    }\n}\n", "import {\n    BLEND_MODES,\n    Circle,\n    Color,\n    Ellipse,\n    Matrix,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Shader,\n    SHAPES,\n    State,\n    Texture,\n    UniformGroup,\n} from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { curves, LINE_CAP, LINE_JOIN } from './const';\nimport { GraphicsGeometry } from './GraphicsGeometry';\nimport { FillStyle } from './styles/FillStyle';\nimport { LineStyle } from './styles/LineStyle';\nimport { ArcUtils, BezierUtils, QuadraticUtils } from './utils';\n\nimport type { BatchDrawCall, ColorSource, IPointData, IShape, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\n/**\n * Batch element computed from Graphics geometry.\n * @memberof PIXI\n */\nexport interface IGraphicsBatchElement\n{\n    vertexData: Float32Array;\n    blendMode: BLEND_MODES;\n    indices: Uint16Array | Uint32Array;\n    uvs: Float32Array;\n    alpha: number;\n    worldAlpha: number;\n    _batchRGB: number[];\n    _tintRGB: number;\n    _texture: Texture;\n}\n\nexport interface IFillStyleOptions\n{\n    color?: ColorSource;\n    alpha?: number;\n    texture?: Texture;\n    matrix?: Matrix;\n}\n\nexport interface ILineStyleOptions extends IFillStyleOptions\n{\n    width?: number;\n    alignment?: number;\n    native?: boolean;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n}\n\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS: {[key: string]: Shader} = {};\n\nexport interface Graphics extends GlobalMixins.Graphics, Container {}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n *\n * Please note that due to legacy naming conventions, the behavior of some functions in this class\n * can be confusing.  Each call to `drawRect()`, `drawPolygon()`, etc. actually stores that primitive\n * in the Geometry class's GraphicsGeometry object for later use in rendering or hit testing - the\n * functions do not directly draw anything to the screen.  Similarly, the `clear()` function doesn't\n * change the screen, it simply resets the list of primitives, which can be useful if you want to\n * rebuild the contents of an existing Graphics object.\n *\n * Once a GraphicsGeometry list is built, you can re-use it in other Geometry objects as\n * an optimization, by passing it into a new Geometry object's constructor.  Because of this\n * ability, it's important to call `destroy()` on Geometry objects once you are done with them, to\n * properly dereference each GraphicsGeometry and prevent memory leaks.\n * @memberof PIXI\n */\nexport class Graphics extends Container\n{\n    /**\n     * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n     * the resolution is calculated based on the curve's length to ensure better visual quality.\n     * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n     * @static\n     * @property {boolean} [adaptive=true] - flag indicating if the resolution should be adaptive\n     * @property {number} [maxLength=10] - maximal length of a single segment of the curve (if adaptive = false, ignored)\n     * @property {number} [minSegments=8] - minimal number of segments in the curve (if adaptive = false, ignored)\n     * @property {number} [maxSegments=2048] - maximal number of segments in the curve (if adaptive = false, ignored)\n     * @property {number} [epsilon=0.0001] - precision of the curve fitting\n     */\n    public static readonly curves = curves;\n\n    /**\n     * Temporary point to use for containsPoint.\n     * @private\n     */\n    static _TEMP_POINT = new Point();\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Graphics objects.\n     */\n    public shader: Shader = null;\n\n    /** Renderer plugin for batching */\n    public pluginName = 'batch';\n\n    /**\n     * Current path\n     * @readonly\n     */\n    public currentPath: Polygon = null;\n\n    /** A collections of batches! These can be drawn by the renderer batch system. */\n    protected batches: Array<IGraphicsBatchElement> = [];\n\n    /** Update dirty for limiting calculating tints for batches. */\n    protected batchTint = -1;\n\n    /** Update dirty for limiting calculating batches.*/\n    protected batchDirty = -1;\n\n    /** Copy of the object vertex data. */\n    protected vertexData: Float32Array = null;\n\n    /** Current fill style. */\n    protected _fillStyle: FillStyle = new FillStyle();\n\n    /** Current line style. */\n    protected _lineStyle: LineStyle = new LineStyle();\n\n    /** Current shape transform matrix. */\n    protected _matrix: Matrix = null;\n\n    /** Current hole mode is enabled. */\n    protected _holeMode = false;\n    protected _transformID: number;\n    protected _tintColor: Color;\n\n    /**\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    private state: State = State.for2d();\n    private _geometry: GraphicsGeometry;\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     * @readonly\n     */\n    public get geometry(): GraphicsGeometry\n    {\n        return this._geometry;\n    }\n\n    /**\n     * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.\n     */\n    constructor(geometry: GraphicsGeometry = null)\n    {\n        super();\n\n        this._geometry = geometry || new GraphicsGeometry();\n        this._geometry.refCount++;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n\n        this._transformID = -1;\n\n        // Set default\n        this._tintColor = new Color(0xFFFFFF);\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n     * @returns - A clone of the graphics object\n     */\n    public clone(): Graphics\n    {\n        this.finishPoly();\n\n        return new Graphics(this._geometry);\n    }\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n     * primitive in the GraphicsGeometry list is rendered sequentially, modes\n     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n     * be applied per-primitive.\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    public set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    public get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * The tint applied to each graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    public get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    public set tint(value: ColorSource)\n    {\n        this._tintColor.setValue(value);\n    }\n\n    /**\n     * The current fill style.\n     * @readonly\n     */\n    public get fill(): FillStyle\n    {\n        return this._fillStyle;\n    }\n\n    /**\n     * The current line style.\n     * @readonly\n     */\n    public get line(): LineStyle\n    {\n        return this._lineStyle;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     * @param [width=0] - width of the line to draw, will update the objects stored style\n     * @param [color=0x0] - color of the line to draw, will update the objects stored style\n     * @param [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(width: number, color?: ColorSource, alpha?: number, alignment?: number, native?: boolean): this;\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     * @param options - Line style options\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.ColorSource} [options.color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [options.alpha] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(options?: ILineStyleOptions): this;\n\n    public lineStyle(options: ILineStyleOptions | number = null,\n        color: ColorSource = 0x0, alpha?: number, alignment = 0.5, native = false): this\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            options = { width: options, color, alpha, alignment, native } as ILineStyleOptions;\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    /**\n     * Like line style but support texture for line fill.\n     * @param [options] - Collection of options for setting line style.\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n     * @param {PIXI.ColorSource} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n     *  Default 0xFFFFFF if texture present.\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineTextureStyle(options?: ILineStyleOptions): this\n    {\n        // Apply defaults\n        const defaultLineStyleOptions: ILineStyleOptions = {\n            width: 0,\n            texture: Texture.WHITE,\n            color: options?.texture ? 0xFFFFFF : 0x0,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n            cap: LINE_CAP.BUTT,\n            join: LINE_JOIN.MITER,\n            miterLimit: 10,\n        };\n\n        options = Object.assign(defaultLineStyleOptions, options);\n\n        this.normalizeColor(options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Start a polygon object internally.\n     * @protected\n     */\n    protected startPoly(): void\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    /**\n     * Finish the polygon object.\n     * @protected\n     */\n    finishPoly(): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     * @param x - the X coordinate to move to\n     * @param y - the Y coordinate to move to\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     * @param x - the X coordinate to draw to\n     * @param y - the Y coordinate to draw to\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public lineTo(x: number, y: number): this\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Initialize the curve\n     * @param x\n     * @param y\n     */\n    protected _initCurve(x = 0, y = 0): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns This Graphics object. Good for chaining method calls\n     */\n    public bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    /**\n     * The `arcTo` method creates an arc/curve between two tangents on the canvas.\n     * The first tangent is from the start point to the first control point,\n     * and the second tangent is from the first control point to the second control point.\n     * Note that the second control point is not necessarily the end point of the arc.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     * @param x1 - The x-coordinate of the first control point of the arc\n     * @param y1 - The y-coordinate of the first control point of the arc\n     * @param x2 - The x-coordinate of the second control point of the arc\n     * @param y2 - The y-coordinate of the second control point of the arc\n     * @param radius - The radius of the arc\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     * @param cx - The x-coordinate of the center of the circle\n     * @param cy - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param endAngle - The ending angle, in radians\n     * @param anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise = false): this\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this._geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     * @param {PIXI.ColorSource} color - the color of the fill\n     * @param alpha - the alpha of the fill, will override the color's alpha\n     * @returns - This Graphics object. Suitable for chaining method calls\n     */\n    public beginFill(color: ColorSource = 0, alpha?: number): this\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });\n    }\n\n    /**\n     * Normalize the color input from options for line style or fill\n     * @param {PIXI.IFillStyleOptions} options - Fill style object.\n     */\n    private normalizeColor(options: Pick<IFillStyleOptions, 'color' | 'alpha'>): void\n    {\n        const temp = Color.shared.setValue(options.color ?? 0);\n\n        options.color = temp.toNumber();\n        options.alpha ??= temp.alpha;\n    }\n\n    /**\n     * Begin the texture fill.\n     * Note: The wrap mode of the texture is forced to REPEAT on render.\n     * @param options - Fill style object.\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n     * @param {PIXI.ColorSource} [options.color=0xffffff] - Background to fill behind texture\n     * @param {number} [options.alpha] - Alpha of fill, overrides the color's alpha\n     * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginTextureFill(options?: IFillStyleOptions): this\n    {\n        // Apply defaults\n        const defaultOptions: IFillStyleOptions = {\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            matrix: null,\n        };\n\n        options = Object.assign(defaultOptions, options);\n\n        this.normalizeColor(options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public endFill(): this\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape.\n     * @param x - The X coord of the top-left of the rectangle\n     * @param y - The Y coord of the top-left of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawRect(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    /**\n     * Draw a rectangle shape with rounded/beveled corners.\n     * @param x - The X coord of the top-left of the rectangle\n     * @param y - The Y coord of the top-left of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param radius - Radius of the rectangle corners\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    /**\n     * Draws a circle.\n     * @param x - The X coordinate of the center of the circle\n     * @param y - The Y coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawCircle(x: number, y: number, radius: number): this\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    /**\n     * Draws an ellipse.\n     * @param x - The X coordinate of the center of the ellipse\n     * @param y - The Y coordinate of the center of the ellipse\n     * @param width - The half width of the ellipse\n     * @param height - The half height of the ellipse\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawEllipse(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    public drawPolygon(...path: Array<number> | Array<IPointData>): this;\n    public drawPolygon(path: Array<number> | Array<IPointData> | Polygon): this;\n\n    /**\n     * Draws a polygon using the given path.\n     * @param {number[]|PIXI.IPointData[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawPolygon(...path: any[]): this\n    {\n        let points: Array<number> | Array<IPointData>;\n        let closeStroke = true;// !!this._fillStyle;\n\n        const poly = path[0] as Polygon;\n\n        // check if data has points..\n        if (poly.points)\n        {\n            closeStroke = poly.closeStroke;\n            points = poly.points;\n        }\n        else\n        if (Array.isArray(path[0]))\n        {\n            points = path[0];\n        }\n        else\n        {\n            points = path;\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw any shape.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawShape(shape: IShape): this\n    {\n        if (!this._holeMode)\n        {\n            this._geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this._geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public clear(): this\n    {\n        this._geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._boundsID++;\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     * @returns - True if only 1 rect.\n     */\n    public isFastRect(): boolean\n    {\n        const data = this._geometry.graphicsData;\n\n        return data.length === 1\n            && data[0].shape.type === SHAPES.RECT\n            && !data[0].matrix\n            && !data[0].holes.length\n            && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n        // batch part..\n        // batch it!\n\n        geometry.updateBatches();\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    /** Populating batches for rendering. */\n    protected _populateBatches(): void\n    {\n        const geometry = this._geometry;\n        const blendMode = this.blendMode;\n        const len = geometry.batches.length;\n\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n        this.batches.length = len;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0; i < len; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const indices = new Uint16Array(geometry.indicesUint16.buffer,\n                gI.start * 2,\n                gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                indices,\n                uvs,\n                _batchRGB: Color.shared.setValue(color).toRgbArray(),\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1\n            };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    /**\n     * Renders the batches using the BathedRenderer plugin\n     * @param renderer - The renderer\n     */\n    protected _renderBatched(renderer: Renderer): void\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    /**\n     * Renders the graphics direct\n     * @param renderer - The renderer\n     */\n    protected _renderDirect(renderer: Renderer): void\n    {\n        const shader = this._resolveDirectShader(renderer);\n\n        const geometry = this._geometry;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        Color.shared.setValue(this._tintColor)\n            .premultiply(worldAlpha)\n            .toArray(uniforms.tint);\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n        }\n    }\n\n    /**\n     * Renders specific DrawCall\n     * @param renderer\n     * @param drawCall\n     */\n    protected _renderDrawCallDirect(renderer: Renderer, drawCall: BatchDrawCall): void\n    {\n        const { texArray, type, size, start } = drawCall;\n        const groupTextureCount = texArray.count;\n\n        for (let j = 0; j < groupTextureCount; j++)\n        {\n            renderer.texture.bind(texArray.elements[j], j);\n        }\n\n        renderer.geometry.draw(type, size, start);\n    }\n\n    /**\n     * Resolves shader for direct rendering\n     * @param renderer - The renderer\n     */\n    protected _resolveDirectShader(renderer: Renderer): Shader\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            // if there is no shader here, we can use the default shader.\n            // and that only gets created if we actually need it..\n            // but may be more than one plugins for graphics\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                const { maxTextures } = renderer.plugins[pluginName];\n                const sampleValues = new Int32Array(maxTextures);\n\n                for (let i = 0; i < maxTextures; i++)\n                {\n                    sampleValues[i] = i;\n                }\n\n                const uniforms = {\n                    tint: new Float32Array([1, 1, 1, 1]),\n                    translationMatrix: new Matrix(),\n                    default: UniformGroup.from({ uSamplers: sampleValues }, true),\n                };\n\n                const program = renderer.plugins[pluginName]._shader.program;\n\n                DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n            }\n\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    /**\n     * Retrieves the bounds of the graphic shape as a rectangle object.\n     * @see PIXI.GraphicsGeometry#bounds\n     */\n    protected _calculateBounds(): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     * @param point - the point to test\n     * @returns - the result of the test\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n\n        return this._geometry.containsPoint(Graphics._TEMP_POINT);\n    }\n\n    /** Recalculate the tint by applying tint to batches using Graphics tint. */\n    protected calculateTints(): void\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this._tintColor.toNumber();\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                batch._tintRGB = Color.shared\n                    .setValue(this._tintColor)\n                    .multiply(batch._batchRGB)\n                    .toLittleEndianNumber();\n            }\n        }\n    }\n\n    /** If there's a transform update or a change to the shape of the geometry, recalculate the vertices. */\n    protected calculateVertices(): void\n    {\n        const wtID = this.transform._worldID;\n\n        if (this._transformID === wtID)\n        {\n            return;\n        }\n\n        this._transformID = wtID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this._geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    /**\n     * Closes the current path.\n     * @returns - Returns itself.\n     */\n    public closePath(): this\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n            // ensure that the polygon is completed, and is available for hit detection\n            // (even if the graphics is not rendered yet)\n            this.finishPoly();\n        }\n\n        return this;\n    }\n\n    /**\n     * Apply a matrix to the positional data.\n     * @param matrix - Matrix to use for transform current shape.\n     * @returns - Returns itself.\n     */\n    public setMatrix(matrix: Matrix): this\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    /**\n     * Begin adding holes to the last draw shape\n     * IMPORTANT: holes must be fully inside a shape to work\n     * Also weirdness ensues if holes overlap!\n     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n     * @returns - Returns itself.\n     */\n    public beginHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    /**\n     * End adding holes to the last draw shape.\n     * @returns - Returns itself.\n     */\n    public endHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     * @param options - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0)\n        {\n            this._geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this._geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n}\n", "/// <reference path=\"../global.d.ts\" />\nimport {\n    ArcUtils,\n    BATCH_POOL,\n    BatchPart,\n    BezierUtils,\n    buildCircle,\n    buildLine,\n    buildPoly,\n    buildRectangle,\n    buildRoundedRectangle,\n    DRAW_CALL_POOL,\n    FILL_COMMANDS,\n    QuadraticUtils,\n} from './utils';\n\nimport type { SHAPES } from '@pixi/core';\nimport type { BatchDrawCall } from '@pixi/core/';\nimport type { IShapeBuildCommand } from './utils/IShapeBuildCommand';\n\nexport * from './const';\nexport * from './Graphics';\nexport * from './GraphicsData';\nexport * from './GraphicsGeometry';\nexport * from './styles/FillStyle';\nexport * from './styles/LineStyle';\n\nexport const graphicsUtils = {\n    buildPoly: buildPoly as IShapeBuildCommand,\n    buildCircle: buildCircle as IShapeBuildCommand,\n    buildRectangle: buildRectangle as IShapeBuildCommand,\n    buildRoundedRectangle: buildRoundedRectangle as IShapeBuildCommand,\n    buildLine,\n    ArcUtils,\n    BezierUtils,\n    QuadraticUtils,\n    BatchPart,\n    FILL_COMMANDS: FILL_COMMANDS as Record<SHAPES, IShapeBuildCommand>,\n    BATCH_POOL: BATCH_POOL as Array<BatchPart>,\n    DRAW_CALL_POOL: DRAW_CALL_POOL as Array<BatchDrawCall>\n};\n", "import { MeshGeometry } from '@pixi/mesh';\n\n/**\n * @memberof PIXI\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public segWidth: number;\n    public segHeight: number;\n    public width: number;\n    public height: number;\n\n    /**\n     * @param width - The width of the plane.\n     * @param height - The height of the plane.\n     * @param segWidth - Number of horizontal segments.\n     * @param segHeight - Number of vertical segments.\n     */\n    constructor(width = 100, height = 100, segWidth = 10, segHeight = 10)\n    {\n        super();\n\n        this.segWidth = segWidth;\n        this.segHeight = segHeight;\n\n        this.width = width;\n        this.height = height;\n\n        this.build();\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @private\n     */\n    build(): void\n    {\n        const total = this.segWidth * this.segHeight;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const segmentsX = this.segWidth - 1;\n        const segmentsY = this.segHeight - 1;\n\n        const sizeX = (this.width) / segmentsX;\n        const sizeY = (this.height) / segmentsY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.segWidth);\n            const y = ((i / this.segWidth) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / segmentsX, y / segmentsY);\n        }\n\n        const totalSub = segmentsX * segmentsY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % segmentsX;\n            const ypos = (i / segmentsX) | 0;\n\n            const value = (ypos * this.segWidth) + xpos;\n            const value2 = (ypos * this.segWidth) + xpos + 1;\n            const value3 = ((ypos + 1) * this.segWidth) + xpos;\n            const value4 = ((ypos + 1) * this.segWidth) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint16Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n", "import { MeshGeometry } from '@pixi/mesh';\n\nimport type { IPoint } from '@pixi/core';\n\n/**\n * RopeGeometry allows you to draw a geometry across several points and then manipulate these points.\n * @example\n * import { Point, RopeGeometry } from 'pixi.js';\n *\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * };\n * const rope = new RopeGeometry(100, points);\n * @memberof PIXI\n */\nexport class RopeGeometry extends MeshGeometry\n{\n    /** An array of points that determine the rope. */\n    public points: IPoint[];\n\n    /** Rope texture scale, if zero then the rope texture is stretched. */\n    public readonly textureScale: number;\n\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @readonly\n     */\n    _width: number;\n\n    /**\n     * @param width - The width (i.e., thickness) of the rope.\n     * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n     * @param textureScale - By default the rope texture will be stretched to match\n     *     rope length. If textureScale is positive this value will be treated as a scaling\n     *     factor and the texture will preserve its aspect ratio instead. To create a tiling rope\n     *     set baseTexture.wrapMode to {@link PIXI.WRAP_MODES.REPEAT} and use a power of two texture,\n     *     then set textureScale=1 to keep the original texture pixel size.\n     *     In order to reduce alpha channel artifacts provide a larger texture and downsample -\n     *     i.e. set textureScale=0.5 to scale it down twice.\n     */\n    constructor(width = 200, points: IPoint[], textureScale = 0)\n    {\n        super(new Float32Array(points.length * 4),\n            new Float32Array(points.length * 4),\n            new Uint16Array((points.length - 1) * 6));\n\n        this.points = points;\n        this._width = width;\n        this.textureScale = textureScale;\n\n        this.build();\n    }\n\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @readonly\n     */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    /** Refreshes Rope indices and uvs */\n    private build(): void\n    {\n        const points = this.points;\n\n        if (!points) return;\n\n        const vertexBuffer = this.getBuffer('aVertexPosition');\n        const uvBuffer = this.getBuffer('aTextureCoord');\n        const indexBuffer = this.getIndex();\n\n        // if too little points, or texture hasn't got UVs set yet just move on.\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        // if the number of points has changed we will need to recreate the arraybuffers\n        if (vertexBuffer.data.length / 4 !== points.length)\n        {\n            vertexBuffer.data = new Float32Array(points.length * 4);\n            uvBuffer.data = new Float32Array(points.length * 4);\n            indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n        }\n\n        const uvs = uvBuffer.data;\n        const indices = indexBuffer.data;\n\n        uvs[0] = 0;\n        uvs[1] = 0;\n        uvs[2] = 0;\n        uvs[3] = 1;\n\n        let amount = 0;\n        let prev = points[0];\n        const textureWidth = this._width * this.textureScale;\n        const total = points.length; // - 1;\n\n        for (let i = 0; i < total; i++)\n        {\n            // time to do some smart drawing!\n            const index = i * 4;\n\n            if (this.textureScale > 0)\n            {\n                // calculate pixel distance from previous point\n                const dx = prev.x - points[i].x;\n                const dy = prev.y - points[i].y;\n                const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n                prev = points[i];\n                amount += distance / textureWidth;\n            }\n            else\n            {\n                // stretch texture\n                amount = i / (total - 1);\n            }\n\n            uvs[index] = amount;\n            uvs[index + 1] = 0;\n\n            uvs[index + 2] = amount;\n            uvs[index + 3] = 1;\n        }\n\n        let indexCount = 0;\n\n        for (let i = 0; i < total - 1; i++)\n        {\n            const index = i * 2;\n\n            indices[indexCount++] = index;\n            indices[indexCount++] = index + 1;\n            indices[indexCount++] = index + 2;\n\n            indices[indexCount++] = index + 2;\n            indices[indexCount++] = index + 1;\n            indices[indexCount++] = index + 3;\n        }\n\n        // ensure that the changes are uploaded\n        uvBuffer.update();\n        indexBuffer.update();\n\n        this.updateVertices();\n    }\n\n    /** refreshes vertices of Rope mesh */\n    public updateVertices(): void\n    {\n        const points = this.points;\n\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        let lastPoint = points[0];\n        let nextPoint;\n        let perpX = 0;\n        let perpY = 0;\n\n        const vertices = this.buffers[0].data;\n        const total = points.length;\n        const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n\n        for (let i = 0; i < total; i++)\n        {\n            const point = points[i];\n            const index = i * 4;\n\n            if (i < points.length - 1)\n            {\n                nextPoint = points[i + 1];\n            }\n            else\n            {\n                nextPoint = point;\n            }\n\n            perpY = -(nextPoint.x - lastPoint.x);\n            perpX = nextPoint.y - lastPoint.y;\n\n            let ratio = (1 - (i / (total - 1))) * 10;\n\n            if (ratio > 1)\n            {\n                ratio = 1;\n            }\n\n            const perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n            if (perpLength < 1e-6)\n            {\n                perpX = 0;\n                perpY = 0;\n            }\n            else\n            {\n                perpX /= perpLength;\n                perpY /= perpLength;\n\n                perpX *= halfWidth;\n                perpY *= halfWidth;\n            }\n\n            vertices[index] = point.x + perpX;\n            vertices[index + 1] = point.y + perpY;\n            vertices[index + 2] = point.x - perpX;\n            vertices[index + 3] = point.y - perpY;\n\n            lastPoint = point;\n        }\n\n        this.buffers[0].update();\n    }\n\n    public update(): void\n    {\n        if (this.textureScale > 0)\n        {\n            this.build(); // we need to update UVs\n        }\n        else\n        {\n            this.updateVertices();\n        }\n    }\n}\n", "import { Texture } from '@pixi/core';\nimport { Mesh, MeshMaterial } from '@pixi/mesh';\nimport { PlaneGeometry } from './geometry/PlaneGeometry';\n\nimport type{ Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\n/**\n * The SimplePlane allows you to draw a texture across several points and then manipulate these points\n * @example\n * import { Point, SimplePlane, Texture } from 'pixi.js';\n *\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * }\n * const SimplePlane = new SimplePlane(Texture.from('snake.png'), points);\n * @memberof PIXI\n */\nexport class SimplePlane extends Mesh\n{\n    /** The geometry is automatically updated when the texture size changes. */\n    public autoResize: boolean;\n\n    protected _textureID: number;\n\n    /**\n     * @param texture - The texture to use on the SimplePlane.\n     * @param verticesX - The number of vertices in the x-axis\n     * @param verticesY - The number of vertices in the y-axis\n     */\n    constructor(texture: Texture, verticesX?: number, verticesY?: number)\n    {\n        const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);\n        const meshMaterial = new MeshMaterial(Texture.WHITE);\n\n        super(planeGeometry, meshMaterial);\n\n        // lets call the setter to ensure all necessary updates are performed\n        this.texture = texture;\n        this.autoResize = true;\n    }\n\n    /**\n     * Method used for overrides, to do something in case texture frame was changed.\n     * Meshes based on plane can override it and change more details based on texture.\n     */\n    public textureUpdated(): void\n    {\n        this._textureID = this.shader.texture._updateID;\n\n        const geometry: PlaneGeometry = this.geometry as any;\n        const { width, height } = this.shader.texture;\n\n        if (this.autoResize && (geometry.width !== width || geometry.height !== height))\n        {\n            geometry.width = this.shader.texture.width;\n            geometry.height = this.shader.texture.height;\n            geometry.build();\n        }\n    }\n\n    set texture(value: Texture)\n    {\n        // Track texture same way sprite does.\n        // For generated meshes like NineSlicePlane it can change the geometry.\n        // Unfortunately, this method might not work if you directly change texture in material.\n\n        if (this.shader.texture === value)\n        {\n            return;\n        }\n\n        this.shader.texture = value;\n        this._textureID = -1;\n\n        if (value.baseTexture.valid)\n        {\n            this.textureUpdated();\n        }\n        else\n        {\n            value.once('update', this.textureUpdated, this);\n        }\n    }\n\n    get texture(): Texture\n    {\n        return this.shader.texture;\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this._textureID !== this.shader.texture._updateID)\n        {\n            this.textureUpdated();\n        }\n\n        super._render(renderer);\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this.shader.texture.off('update', this.textureUpdated, this);\n        super.destroy(options);\n    }\n}\n", "import { Texture } from '@pixi/core';\nimport { SimplePlane } from './SimplePlane';\n\nimport type { ITypedArray } from '@pixi/core';\n\nconst DEFAULT_BORDER_SIZE = 10;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface NineSlicePlane extends GlobalMixins.NineSlicePlane {}\n\n/**\n * The NineSlicePlane allows you to stretch a texture using 9-slice scaling. The corners will remain unscaled (useful\n * for buttons with rounded corners for example) and the other areas will be scaled horizontally and or vertically\n *\n * <pre>\n *      A                          B\n *    +---+----------------------+---+\n *  C | 1 |          2           | 3 |\n *    +---+----------------------+---+\n *    |   |                      |   |\n *    | 4 |          5           | 6 |\n *    |   |                      |   |\n *    +---+----------------------+---+\n *  D | 7 |          8           | 9 |\n *    +---+----------------------+---+\n *  When changing this objects width and/or height:\n *     areas 1 3 7 and 9 will remain unscaled.\n *     areas 2 and 8 will be stretched horizontally\n *     areas 4 and 6 will be stretched vertically\n *     area 5 will be stretched both horizontally and vertically\n * </pre>\n * @example\n * import { NineSlicePlane, Texture } from 'pixi.js';\n *\n * const plane9 = new NineSlicePlane(Texture.from('BoxWithRoundedCorners.png'), 15, 15, 15, 15);\n * @memberof PIXI\n */\nexport class NineSlicePlane extends SimplePlane\n{\n    private _origWidth: number;\n    private _origHeight: number;\n\n    /**\n     * The width of the left column (a).\n     * @private\n     */\n    _leftWidth: number;\n\n    /**\n     * The width of the right column (b)\n     * @private\n     */\n    _rightWidth: number;\n\n    /**\n     * The height of the top row (c)\n     * @private\n     */\n    _topHeight: number;\n\n    /**\n     * The height of the bottom row (d)\n     * @private\n     */\n    _bottomHeight: number;\n\n    /**\n     * @param texture - The texture to use on the NineSlicePlane.\n     * @param {number} [leftWidth=10] - size of the left vertical bar (A)\n     * @param {number} [topHeight=10] - size of the top horizontal bar (C)\n     * @param {number} [rightWidth=10] - size of the right vertical bar (B)\n     * @param {number} [bottomHeight=10] - size of the bottom horizontal bar (D)\n     */\n    constructor(\n        texture: Texture,\n        leftWidth?: number,\n        topHeight?: number,\n        rightWidth?: number,\n        bottomHeight?: number\n    )\n    {\n        super(Texture.WHITE, 4, 4);\n\n        this._origWidth = texture.orig.width;\n        this._origHeight = texture.orig.height;\n\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        this._width = this._origWidth;\n\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        this._height = this._origHeight;\n\n        this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE;\n        this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE;\n        this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE;\n        this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE;\n\n        // lets call the setter to ensure all necessary updates are performed\n        this.texture = texture;\n    }\n\n    public textureUpdated(): void\n    {\n        this._textureID = this.shader.texture._updateID;\n        this._refresh();\n    }\n\n    get vertices(): ITypedArray\n    {\n        return this.geometry.getBuffer('aVertexPosition').data;\n    }\n\n    set vertices(value: ITypedArray)\n    {\n        this.geometry.getBuffer('aVertexPosition').data = value;\n    }\n\n    /** Updates the horizontal vertices. */\n    public updateHorizontalVertices(): void\n    {\n        const vertices = this.vertices;\n\n        const scale = this._getMinScale();\n\n        vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;\n        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - (this._bottomHeight * scale);\n        vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;\n    }\n\n    /** Updates the vertical vertices. */\n    public updateVerticalVertices(): void\n    {\n        const vertices = this.vertices;\n\n        const scale = this._getMinScale();\n\n        vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;\n        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - (this._rightWidth * scale);\n        vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;\n    }\n\n    /**\n     * Returns the smaller of a set of vertical and horizontal scale of nine slice corners.\n     * @returns Smaller number of vertical and horizontal scale.\n     */\n    private _getMinScale(): number\n    {\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this._width > w ? 1.0 : this._width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this._height > h ? 1.0 : this._height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        return scale;\n    }\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    set width(value: number)\n    {\n        this._width = value;\n        this._refresh();\n    }\n\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get height(): number\n    {\n        return this._height;\n    }\n\n    set height(value: number)\n    {\n        this._height = value;\n        this._refresh();\n    }\n\n    /** The width of the left column. */\n    get leftWidth(): number\n    {\n        return this._leftWidth;\n    }\n\n    set leftWidth(value: number)\n    {\n        this._leftWidth = value;\n        this._refresh();\n    }\n\n    /** The width of the right column. */\n    get rightWidth(): number\n    {\n        return this._rightWidth;\n    }\n\n    set rightWidth(value: number)\n    {\n        this._rightWidth = value;\n        this._refresh();\n    }\n\n    /** The height of the top row. */\n    get topHeight(): number\n    {\n        return this._topHeight;\n    }\n\n    set topHeight(value: number)\n    {\n        this._topHeight = value;\n        this._refresh();\n    }\n\n    /** The height of the bottom row. */\n    get bottomHeight(): number\n    {\n        return this._bottomHeight;\n    }\n\n    set bottomHeight(value: number)\n    {\n        this._bottomHeight = value;\n        this._refresh();\n    }\n\n    /** Refreshes NineSlicePlane coords. All of them. */\n    private _refresh(): void\n    {\n        const texture = this.texture;\n\n        const uvs = this.geometry.buffers[1].data;\n\n        this._origWidth = texture.orig.width;\n        this._origHeight = texture.orig.height;\n\n        const _uvw = 1.0 / this._origWidth;\n        const _uvh = 1.0 / this._origHeight;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.updateHorizontalVertices();\n        this.updateVerticalVertices();\n\n        this.geometry.buffers[0].update();\n        this.geometry.buffers[1].update();\n    }\n}\n", "import { Texture } from '@pixi/core';\nimport { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\n\nimport type { DRAW_MODES, IArrayBuffer, ITypedArray, Renderer } from '@pixi/core';\n\n/**\n * The Simple Mesh class mimics Mesh in PixiJS v4, providing easy-to-use constructor arguments.\n * For more robust customization, use {@link PIXI.Mesh}.\n * @memberof PIXI\n */\nexport class SimpleMesh extends Mesh\n{\n    /** Upload vertices buffer each frame. */\n    public autoUpdate: boolean;\n\n    /**\n     * @param texture - The texture to use\n     * @param {Float32Array} [vertices] - if you want to specify the vertices\n     * @param {Float32Array} [uvs] - if you want to specify the uvs\n     * @param {Uint16Array} [indices] - if you want to specify the indices\n     * @param drawMode - the drawMode, can be any of the Mesh.DRAW_MODES consts\n     */\n    constructor(\n        texture: Texture = Texture.EMPTY,\n        vertices?: IArrayBuffer,\n        uvs?: IArrayBuffer,\n        indices?: IArrayBuffer,\n        drawMode?: DRAW_MODES\n    )\n    {\n        const geometry = new MeshGeometry(vertices, uvs, indices);\n\n        geometry.getBuffer('aVertexPosition').static = false;\n\n        const meshMaterial = new MeshMaterial(texture);\n\n        super(geometry, meshMaterial, null, drawMode);\n\n        this.autoUpdate = true;\n    }\n\n    /**\n     * Collection of vertices data.\n     * @type {Float32Array}\n     */\n    get vertices(): ITypedArray\n    {\n        return this.geometry.getBuffer('aVertexPosition').data;\n    }\n    set vertices(value: ITypedArray)\n    {\n        this.geometry.getBuffer('aVertexPosition').data = value;\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this.autoUpdate)\n        {\n            this.geometry.getBuffer('aVertexPosition').update();\n        }\n\n        super._render(renderer);\n    }\n}\n", "import { WRAP_MODES } from '@pixi/core';\nimport { Mesh, MeshMaterial } from '@pixi/mesh';\nimport { RopeGeometry } from './geometry/RopeGeometry';\n\nimport type { IPoint, Renderer, Texture } from '@pixi/core';\n\n/**\n * The rope allows you to draw a texture across several points and then manipulate these points\n * @example\n * import { Point, SimpleRope, Texture } from 'pixi.js';\n *\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * };\n * const rope = new SimpleRope(Texture.from('snake.png'), points);\n * @memberof PIXI\n */\nexport class SimpleRope extends Mesh\n{\n    public autoUpdate: boolean;\n\n    /**\n     * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.\n     * @param texture - The texture to use on the rope.\n     * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n     * @param {number} textureScale - Optional. Positive values scale rope texture\n     * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture\n     * and downsampling here. If set to zero, texture will be stretched instead.\n     */\n    constructor(texture: Texture, points: IPoint[], textureScale = 0)\n    {\n        const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);\n        const meshMaterial = new MeshMaterial(texture);\n\n        if (textureScale > 0)\n        {\n            // attempt to set UV wrapping, will fail on non-power of two textures\n            texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;\n        }\n        super(ropeGeometry, meshMaterial);\n\n        /**\n         * re-calculate vertices by rope points each frame\n         * @member {boolean}\n         */\n        this.autoUpdate = true;\n    }\n\n    _render(renderer: Renderer): void\n    {\n        const geometry: RopeGeometry = this.geometry as any;\n\n        if (this.autoUpdate || geometry._width !== this.shader.texture.height)\n        {\n            geometry._width = this.shader.texture.height;\n            geometry.update();\n        }\n\n        super._render(renderer);\n    }\n}\n", "export { PlaneGeometry } from './geometry/PlaneGeometry.mjs';\nexport { RopeGeometry } from './geometry/RopeGeometry.mjs';\nexport { NineSlicePlane } from './NineSlicePlane.mjs';\nexport { SimpleMesh } from './SimpleMesh.mjs';\nexport { SimplePlane } from './SimplePlane.mjs';\nexport { SimpleRope } from './SimpleRope.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { BLEND_MODES, Color } from '@pixi/core';\nimport { Container } from '@pixi/display';\n\nimport type { BaseTexture, ColorSource, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { Sprite } from '@pixi/sprite';\nimport type { ParticleBuffer } from './ParticleBuffer';\n\nexport interface IParticleProperties\n{\n    vertices?: boolean;\n    position?: boolean;\n    rotation?: boolean;\n    uvs?: boolean;\n    tint?: boolean;\n    alpha?: boolean;\n    scale?: boolean;\n}\n\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles.\n *\n * The tradeoff of the ParticleContainer is that most advanced functionality will not work.\n * ParticleContainer implements the basic object transform (position, scale, rotation)\n * and some advanced functionality like tint (as of v4.5.6).\n *\n * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use. And here you have a hundred sprites that will be rendered at the speed of light.\n * @example\n * import { ParticleContainer, Sprite } from 'pixi.js';\n *\n * const container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let sprite = Sprite.from('myImage.png');\n *     container.addChild(sprite);\n * }\n * @memberof PIXI\n */\nexport class ParticleContainer extends Container<Sprite>\n{\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`\n     * to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    public blendMode: BLEND_MODES;\n\n    /**\n     * If true, container allocates more batches in case there are more than `maxSize` particles.\n     * @default false\n     */\n    public autoResize: boolean;\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * Default to true here as performance is usually the priority for particles.\n     * @default true\n     */\n    public roundPixels: boolean;\n\n    /**\n     * The texture used to render the children.\n     * @readonly\n     */\n    public baseTexture: BaseTexture;\n    public tintRgb: Float32Array;\n\n    /** @private */\n    _maxSize: number;\n\n    /** @private */\n    _buffers: ParticleBuffer[];\n\n    /** @private */\n    _batchSize: number;\n\n    /**\n     * Set properties to be dynamic (true) / static (false).\n     * @private\n     */\n    _properties: boolean[];\n\n    /**\n     * For every batch, stores _updateID corresponding to the last change in that batch.\n     * @private\n     */\n    _bufferUpdateIDs: number[];\n\n    /**\n     * When child inserted, removed or changes position this number goes up.\n     * @private\n     */\n    _updateID: number;\n\n    /**\n     * The tint applied to the container.\n     * This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    private _tintColor: Color;\n\n    /**\n     * @param maxSize - The maximum number of particles that can be rendered by the container.\n     *  Affects size of allocated buffers.\n     * @param properties - The properties of children that should be uploaded to the gpu and applied.\n     * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.\n     *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.\n     * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.\n     * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.\n     * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.\n     * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.\n     * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.\n     * @param {boolean} [autoResize=false] - If true, container allocates more batches in case\n     *  there are more than `maxSize` particles.\n     */\n    constructor(maxSize = 1500, properties?: IParticleProperties, batchSize = 16384, autoResize = false)\n    {\n        super();\n\n        // Making sure the batch size is valid\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        const maxBatchSize = 16384;\n\n        if (batchSize > maxBatchSize)\n        {\n            batchSize = maxBatchSize;\n        }\n\n        this._properties = [false, true, false, false, false];\n        this._maxSize = maxSize;\n        this._batchSize = batchSize;\n        this._buffers = null;\n        this._bufferUpdateIDs = [];\n        this._updateID = 0;\n\n        this.interactiveChildren = false;\n        this.blendMode = BLEND_MODES.NORMAL;\n        this.autoResize = autoResize;\n        this.roundPixels = true;\n        this.baseTexture = null;\n\n        this.setProperties(properties);\n\n        this._tintColor = new Color(0);\n        this.tintRgb = new Float32Array(3);\n        this.tint = 0xFFFFFF;\n    }\n\n    /**\n     * Sets the private properties array to dynamic / static based on the passed properties object\n     * @param properties - The properties to be uploaded\n     */\n    public setProperties(properties: IParticleProperties): void\n    {\n        if (properties)\n        {\n            this._properties[0] = 'vertices' in properties || 'scale' in properties\n                ? !!properties.vertices || !!properties.scale : this._properties[0];\n            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n            this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n            this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n            this._properties[4] = 'tint' in properties || 'alpha' in properties\n                ? !!properties.tint || !!properties.alpha : this._properties[4];\n        }\n    }\n\n    updateTransform(): void\n    {\n        // TODO don't need to!\n        this.displayObjectUpdateTransform();\n    }\n\n    /**\n     * The tint applied to the container. This is a hex value.\n     * A value of 0xFFFFFF will remove any tint effect.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * @default 0xFFFFFF\n     */\n    get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    set tint(value: ColorSource)\n    {\n        this._tintColor.setValue(value);\n        this._tintColor.toRgbArray(this.tintRgb);\n    }\n\n    /**\n     * Renders the container using the WebGL renderer.\n     * @param renderer - The WebGL renderer.\n     */\n    public render(renderer: Renderer): void\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n        {\n            return;\n        }\n\n        if (!this.baseTexture)\n        {\n            this.baseTexture = this.children[0]._texture.baseTexture;\n            if (!this.baseTexture.valid)\n            {\n                this.baseTexture.once('update', () => this.onChildrenChange(0));\n            }\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins.particle);\n        renderer.plugins.particle.render(this);\n    }\n\n    /**\n     * Set the flag that static data should be updated to true\n     * @param smallestChildIndex - The smallest child index.\n     */\n    protected onChildrenChange(smallestChildIndex: number): void\n    {\n        const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n\n        while (this._bufferUpdateIDs.length < bufferIndex)\n        {\n            this._bufferUpdateIDs.push(0);\n        }\n        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n    }\n\n    public dispose(): void\n    {\n        if (this._buffers)\n        {\n            for (let i = 0; i < this._buffers.length; ++i)\n            {\n                this._buffers[i].destroy();\n            }\n\n            this._buffers = null;\n        }\n    }\n\n    /**\n     * Destroys the container\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        this.dispose();\n\n        this._properties = null;\n        this._buffers = null;\n        this._bufferUpdateIDs = null;\n    }\n}\n", "import { Buffer, Geometry, TYPES, utils } from '@pixi/core';\n\nimport type { Sprite } from '@pixi/sprite';\nimport type { IParticleRendererProperty } from './ParticleRenderer';\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that\n * they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleBuffer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java\n */\n\n/**\n * The particle buffer manages the static and dynamic buffers for a particle container.\n * @private\n * @memberof PIXI\n */\nexport class ParticleBuffer\n{\n    public geometry: Geometry;\n    public staticStride: number;\n    public staticBuffer: Buffer;\n    public staticData: Float32Array;\n    public staticDataUint32: Uint32Array;\n    public dynamicStride: number;\n    public dynamicBuffer: Buffer;\n    public dynamicData: Float32Array;\n    public dynamicDataUint32: Uint32Array;\n    public _updateID: number;\n\n    /** Holds the indices of the geometry (quads) to draw. */\n    indexBuffer: Buffer;\n\n    /** The number of particles the buffer can hold. */\n    private size: number;\n\n    /** A list of the properties that are dynamic. */\n    private dynamicProperties: IParticleRendererProperty[];\n\n    /** A list of the properties that are static. */\n    private staticProperties: IParticleRendererProperty[];\n\n    /**\n     * @param {object} properties - The properties to upload.\n     * @param {boolean[]} dynamicPropertyFlags - Flags for which properties are dynamic.\n     * @param {number} size - The size of the batch.\n     */\n    constructor(properties: IParticleRendererProperty[], dynamicPropertyFlags: boolean[], size: number)\n    {\n        this.geometry = new Geometry();\n\n        this.indexBuffer = null;\n\n        this.size = size;\n        this.dynamicProperties = [];\n        this.staticProperties = [];\n\n        for (let i = 0; i < properties.length; ++i)\n        {\n            let property = properties[i];\n\n            // Make copy of properties object so that when we edit the offset it doesn't\n            // change all other instances of the object literal\n            property = {\n                attributeName: property.attributeName,\n                size: property.size,\n                uploadFunction: property.uploadFunction,\n                type: property.type || TYPES.FLOAT,\n                offset: property.offset,\n            };\n\n            if (dynamicPropertyFlags[i])\n            {\n                this.dynamicProperties.push(property);\n            }\n            else\n            {\n                this.staticProperties.push(property);\n            }\n        }\n\n        this.staticStride = 0;\n        this.staticBuffer = null;\n        this.staticData = null;\n        this.staticDataUint32 = null;\n\n        this.dynamicStride = 0;\n        this.dynamicBuffer = null;\n        this.dynamicData = null;\n        this.dynamicDataUint32 = null;\n\n        this._updateID = 0;\n\n        this.initBuffers();\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    private initBuffers(): void\n    {\n        const geometry = this.geometry;\n\n        let dynamicOffset = 0;\n\n        this.indexBuffer = new Buffer(utils.createIndicesForQuads(this.size), true, true);\n        geometry.addIndex(this.indexBuffer);\n\n        this.dynamicStride = 0;\n\n        for (let i = 0; i < this.dynamicProperties.length; ++i)\n        {\n            const property = this.dynamicProperties[i];\n\n            property.offset = dynamicOffset;\n            dynamicOffset += property.size;\n            this.dynamicStride += property.size;\n        }\n\n        const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n\n        this.dynamicData = new Float32Array(dynBuffer);\n        this.dynamicDataUint32 = new Uint32Array(dynBuffer);\n        this.dynamicBuffer = new Buffer(this.dynamicData, false, false);\n\n        // static //\n        let staticOffset = 0;\n\n        this.staticStride = 0;\n\n        for (let i = 0; i < this.staticProperties.length; ++i)\n        {\n            const property = this.staticProperties[i];\n\n            property.offset = staticOffset;\n            staticOffset += property.size;\n            this.staticStride += property.size;\n        }\n\n        const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n\n        this.staticData = new Float32Array(statBuffer);\n        this.staticDataUint32 = new Uint32Array(statBuffer);\n        this.staticBuffer = new Buffer(this.staticData, true, false);\n\n        for (let i = 0; i < this.dynamicProperties.length; ++i)\n        {\n            const property = this.dynamicProperties[i];\n\n            geometry.addAttribute(\n                property.attributeName,\n                this.dynamicBuffer,\n                0,\n                property.type === TYPES.UNSIGNED_BYTE,\n                property.type,\n                this.dynamicStride * 4,\n                property.offset * 4\n            );\n        }\n\n        for (let i = 0; i < this.staticProperties.length; ++i)\n        {\n            const property = this.staticProperties[i];\n\n            geometry.addAttribute(\n                property.attributeName,\n                this.staticBuffer,\n                0,\n                property.type === TYPES.UNSIGNED_BYTE,\n                property.type,\n                this.staticStride * 4,\n                property.offset * 4\n            );\n        }\n    }\n\n    /**\n     * Uploads the dynamic properties.\n     * @param children - The children to upload.\n     * @param startIndex - The index to start at.\n     * @param amount - The number to upload.\n     */\n    uploadDynamic(children: Sprite[], startIndex: number, amount: number): void\n    {\n        for (let i = 0; i < this.dynamicProperties.length; i++)\n        {\n            const property = this.dynamicProperties[i];\n\n            property.uploadFunction(children, startIndex, amount,\n                property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData,\n                this.dynamicStride, property.offset);\n        }\n\n        this.dynamicBuffer._updateID++;\n    }\n\n    /**\n     * Uploads the static properties.\n     * @param children - The children to upload.\n     * @param startIndex - The index to start at.\n     * @param amount - The number to upload.\n     */\n    uploadStatic(children: Sprite[], startIndex: number, amount: number): void\n    {\n        for (let i = 0; i < this.staticProperties.length; i++)\n        {\n            const property = this.staticProperties[i];\n\n            property.uploadFunction(children, startIndex, amount,\n                property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData,\n                this.staticStride, property.offset);\n        }\n\n        this.staticBuffer._updateID++;\n    }\n\n    /** Destroys the ParticleBuffer. */\n    destroy(): void\n    {\n        this.indexBuffer = null;\n\n        this.dynamicProperties = null;\n        this.dynamicBuffer = null;\n        this.dynamicData = null;\n        this.dynamicDataUint32 = null;\n\n        this.staticProperties = null;\n        this.staticBuffer = null;\n        this.staticData = null;\n        this.staticDataUint32 = null;\n        // all buffers are destroyed inside geometry\n        this.geometry.destroy();\n    }\n}\n", "var fragment = \"varying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\\n    gl_FragColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=particles.mjs.map\n", "var vertex = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPositionCoord;\\nattribute float aRotation;\\n\\nuniform mat3 translationMatrix;\\nuniform vec4 uColor;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nvoid main(void){\\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPositionCoord;\\n\\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vColor = aColor * uColor;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=particles2.mjs.map\n", "import { Color, extensions, ExtensionType, Matrix, ObjectRenderer, Shader, State, TYPES, utils } from '@pixi/core';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\n\nimport type { ExtensionMetadata, Renderer } from '@pixi/core';\nimport type { Sprite } from '@pixi/sprite';\nimport type { ParticleContainer } from './ParticleContainer';\n\nexport interface IParticleRendererProperty\n{\n    attributeName: string;\n    size: number;\n    type?: TYPES;\n    uploadFunction: (...params: any[]) => any;\n    offset: number;\n}\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @memberof PIXI\n */\nexport class ParticleRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'particle',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    /** The WebGL state in which this renderer will work. */\n    public readonly state: State;\n\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public shader: Shader;\n    public tempMatrix: Matrix;\n    public properties: IParticleRendererProperty[];\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        // and max number of element in the index buffer is 16384 * 6 = 98304\n        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n        // let numIndices = 98304;\n\n        this.shader = null;\n\n        this.properties = null;\n\n        this.tempMatrix = new Matrix();\n\n        this.properties = [\n            // verticesData\n            {\n                attributeName: 'aVertexPosition',\n                size: 2,\n                uploadFunction: this.uploadVertices,\n                offset: 0,\n            },\n            // positionData\n            {\n                attributeName: 'aPositionCoord',\n                size: 2,\n                uploadFunction: this.uploadPosition,\n                offset: 0,\n            },\n            // rotationData\n            {\n                attributeName: 'aRotation',\n                size: 1,\n                uploadFunction: this.uploadRotation,\n                offset: 0,\n            },\n            // uvsData\n            {\n                attributeName: 'aTextureCoord',\n                size: 2,\n                uploadFunction: this.uploadUvs,\n                offset: 0,\n            },\n            // tintData\n            {\n                attributeName: 'aColor',\n                size: 1,\n                type: TYPES.UNSIGNED_BYTE,\n                uploadFunction: this.uploadTint,\n                offset: 0,\n            },\n        ];\n\n        this.shader = Shader.from(vertex, fragment, {});\n        this.state = State.for2d();\n    }\n\n    /**\n     * Renders the particle container object.\n     * @param container - The container to render using this ParticleRenderer.\n     */\n    public render(container: ParticleContainer): void\n    {\n        const children = container.children;\n        const maxSize = container._maxSize;\n        const batchSize = container._batchSize;\n        const renderer = this.renderer;\n        let totalChildren = children.length;\n\n        if (totalChildren === 0)\n        {\n            return;\n        }\n        else if (totalChildren > maxSize && !container.autoResize)\n        {\n            totalChildren = maxSize;\n        }\n\n        let buffers = container._buffers;\n\n        if (!buffers)\n        {\n            buffers = container._buffers = this.generateBuffers(container);\n        }\n\n        const baseTexture = children[0]._texture.baseTexture;\n        const premultiplied = baseTexture.alphaMode > 0;\n\n        // if the uvs have not updated then no point rendering just yet!\n        this.state.blendMode = utils.correctBlendMode(container.blendMode, premultiplied);\n        renderer.state.set(this.state);\n\n        const gl = renderer.gl;\n\n        const m = container.worldTransform.copyTo(this.tempMatrix);\n\n        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n\n        this.shader.uniforms.translationMatrix = m.toArray(true);\n\n        this.shader.uniforms.uColor = Color.shared\n            .setValue(container.tintRgb)\n            .premultiply(container.worldAlpha, premultiplied)\n            .toArray(this.shader.uniforms.uColor);\n\n        this.shader.uniforms.uSampler = baseTexture;\n\n        this.renderer.shader.bind(this.shader);\n\n        let updateStatic = false;\n\n        // now lets upload and render the buffers..\n        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)\n        {\n            let amount = (totalChildren - i);\n\n            if (amount > batchSize)\n            {\n                amount = batchSize;\n            }\n\n            if (j >= buffers.length)\n            {\n                buffers.push(this._generateOneMoreBuffer(container));\n            }\n\n            const buffer = buffers[j];\n\n            // we always upload the dynamic\n            buffer.uploadDynamic(children, i, amount);\n\n            const bid = container._bufferUpdateIDs[j] || 0;\n\n            updateStatic = updateStatic || (buffer._updateID < bid);\n            // we only upload the static content when we have to!\n            if (updateStatic)\n            {\n                buffer._updateID = container._updateID;\n                buffer.uploadStatic(children, i, amount);\n            }\n\n            // bind the buffer\n            renderer.geometry.bind(buffer.geometry);\n            gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n        }\n    }\n\n    /**\n     * Creates one particle buffer for each child in the container we want to render and updates internal properties.\n     * @param container - The container to render using this ParticleRenderer\n     * @returns - The buffers\n     */\n    private generateBuffers(container: ParticleContainer): ParticleBuffer[]\n    {\n        const buffers = [];\n        const size = container._maxSize;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        for (let i = 0; i < size; i += batchSize)\n        {\n            buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n        }\n\n        return buffers;\n    }\n\n    /**\n     * Creates one more particle buffer, because container has autoResize feature.\n     * @param container - The container to render using this ParticleRenderer\n     * @returns - The generated buffer\n     */\n    private _generateOneMoreBuffer(container: ParticleContainer): ParticleBuffer\n    {\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n    }\n\n    /**\n     * Uploads the vertices.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their vertices uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadVertices(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const texture = sprite._texture;\n            const sx = sprite.scale.x;\n            const sy = sprite.scale.y;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                // if the sprite is trimmed and is not a tilingsprite then we need to add the\n                // extra space before transforming the sprite coords..\n                w1 = trim.x - (sprite.anchor.x * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (sprite.anchor.y * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w0 = (orig.width) * (1 - sprite.anchor.x);\n                w1 = (orig.width) * -sprite.anchor.x;\n\n                h0 = orig.height * (1 - sprite.anchor.y);\n                h1 = orig.height * -sprite.anchor.y;\n            }\n\n            array[offset] = w1 * sx;\n            array[offset + 1] = h1 * sy;\n\n            array[offset + stride] = w0 * sx;\n            array[offset + stride + 1] = h1 * sy;\n\n            array[offset + (stride * 2)] = w0 * sx;\n            array[offset + (stride * 2) + 1] = h0 * sy;\n\n            array[offset + (stride * 3)] = w1 * sx;\n            array[offset + (stride * 3) + 1] = h0 * sy;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the position.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their positions uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadPosition(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spritePosition = children[startIndex + i].position;\n\n            array[offset] = spritePosition.x;\n            array[offset + 1] = spritePosition.y;\n\n            array[offset + stride] = spritePosition.x;\n            array[offset + stride + 1] = spritePosition.y;\n\n            array[offset + (stride * 2)] = spritePosition.x;\n            array[offset + (stride * 2) + 1] = spritePosition.y;\n\n            array[offset + (stride * 3)] = spritePosition.x;\n            array[offset + (stride * 3) + 1] = spritePosition.y;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the rotation.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadRotation(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteRotation = children[startIndex + i].rotation;\n\n            array[offset] = spriteRotation;\n            array[offset + stride] = spriteRotation;\n            array[offset + (stride * 2)] = spriteRotation;\n            array[offset + (stride * 3)] = spriteRotation;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the UVs.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadUvs(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const textureUvs = children[startIndex + i]._texture._uvs;\n\n            if (textureUvs)\n            {\n                array[offset] = textureUvs.x0;\n                array[offset + 1] = textureUvs.y0;\n\n                array[offset + stride] = textureUvs.x1;\n                array[offset + stride + 1] = textureUvs.y1;\n\n                array[offset + (stride * 2)] = textureUvs.x2;\n                array[offset + (stride * 2) + 1] = textureUvs.y2;\n\n                array[offset + (stride * 3)] = textureUvs.x3;\n                array[offset + (stride * 3) + 1] = textureUvs.y3;\n\n                offset += stride * 4;\n            }\n            else\n            {\n                // TODO you know this can be easier!\n                array[offset] = 0;\n                array[offset + 1] = 0;\n\n                array[offset + stride] = 0;\n                array[offset + stride + 1] = 0;\n\n                array[offset + (stride * 2)] = 0;\n                array[offset + (stride * 2) + 1] = 0;\n\n                array[offset + (stride * 3)] = 0;\n                array[offset + (stride * 3) + 1] = 0;\n\n                offset += stride * 4;\n            }\n        }\n    }\n\n    /**\n     * Uploads the tint.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadTint(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const result = Color.shared\n                .setValue(sprite._tintRGB)\n                .toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);\n\n            array[offset] = result;\n            array[offset + stride] = result;\n            array[offset + (stride * 2)] = result;\n            array[offset + (stride * 3)] = result;\n\n            offset += stride * 4;\n        }\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        if (this.shader)\n        {\n            this.shader.destroy();\n            this.shader = null;\n        }\n\n        this.tempMatrix = null;\n    }\n}\n\nextensions.add(ParticleRenderer);\n", "export { ParticleContainer } from './ParticleContainer.mjs';\nexport { ParticleRenderer } from './ParticleRenderer.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { Texture, Ticker, UPDATE_PRIORITY } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\n\nimport type { IDestroyOptions } from '@pixi/display';\n\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n *\n * ```js\n * import { AnimatedSprite, Texture } from 'pixi.js';\n *\n * const alienImages = [\n *     'image_sequence_01.png',\n *     'image_sequence_02.png',\n *     'image_sequence_03.png',\n *     'image_sequence_04.png',\n * ];\n * const textureArray = [];\n *\n * for (let i = 0; i < 4; i++)\n * {\n *     const texture = Texture.from(alienImages[i]);\n *     textureArray.push(texture);\n * }\n *\n * const animatedSprite = new AnimatedSprite(textureArray);\n * ```\n *\n * The more efficient and simpler way to create an animated sprite is using a {@link PIXI.Spritesheet}\n * containing the animation definitions:\n * @example\n * import { AnimatedSprite, Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * animatedSprite = new AnimatedSprite(sheet.animations['image_sequence']);\n * @memberof PIXI\n */\nexport class AnimatedSprite extends Sprite\n{\n    /**\n     * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n     * @default 1\n     */\n    public animationSpeed: number;\n\n    /**\n     * Whether or not the animate sprite repeats after playing.\n     * @default true\n     */\n    public loop: boolean;\n\n    /**\n     * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.\n     *\n     * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.\n     * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n     * of the frame (e.g. left foot).\n     *\n     * Note: Enabling this will override any previously set `anchor` on each frame change.\n     * @default false\n     */\n    public updateAnchor: boolean;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite finishes playing.\n     * @example\n     * animation.onComplete = () => {\n     *     // Finished!\n     * };\n     */\n    public onComplete?: () => void;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n     * @example\n     * animation.onFrameChange = () => {\n     *     // Updated!\n     * };\n     */\n    public onFrameChange?: (currentFrame: number) => void;\n\n    /**\n     * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and\n     * loops around to start again.\n     * @example\n     * animation.onLoop = () => {\n     *     // Looped!\n     * };\n     */\n    public onLoop?: () => void;\n\n    private _playing: boolean;\n    private _textures: Texture[];\n    private _durations: number[];\n\n    /**\n     * `true` uses PIXI.Ticker.shared to auto update animation time.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to PIXI.Ticker.shared to auto update animation time.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /** Elapsed time since animation has been started, used internally to display current texture. */\n    private _currentTime: number;\n\n    /** The texture index that was displayed last time. */\n    private _previousFrame: number;\n\n    /**\n     * @param textures - An array of {@link PIXI.Texture} or frame\n     *  objects that make up the animation.\n     * @param {boolean} [autoUpdate=true] - Whether to use Ticker.shared to auto update animation time.\n     */\n    constructor(textures: Texture[] | FrameObject[], autoUpdate = true)\n    {\n        super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);\n\n        this._textures = null;\n        this._durations = null;\n        this._autoUpdate = autoUpdate;\n        this._isConnectedToTicker = false;\n\n        this.animationSpeed = 1;\n        this.loop = true;\n        this.updateAnchor = false;\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n\n        this._currentTime = 0;\n\n        this._playing = false;\n        this._previousFrame = null;\n\n        this.textures = textures;\n    }\n\n    /** Stops the AnimatedSprite. */\n    public stop(): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Plays the AnimatedSprite. */\n    public play(): void\n    {\n        if (this._playing)\n        {\n            return;\n        }\n\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n    }\n\n    /**\n     * Stops the AnimatedSprite and goes to a specific frame.\n     * @param frameNumber - Frame index to stop at.\n     */\n    public gotoAndStop(frameNumber: number): void\n    {\n        this.stop();\n        this.currentFrame = frameNumber;\n    }\n\n    /**\n     * Goes to a specific frame and begins playing the AnimatedSprite.\n     * @param frameNumber - Frame index to start at.\n     */\n    public gotoAndPlay(frameNumber: number): void\n    {\n        this.currentFrame = frameNumber;\n        this.play();\n    }\n\n    /**\n     * Updates the object transform for rendering.\n     * @param deltaTime - Time since last tick.\n     */\n    update(deltaTime: number): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        const elapsed = this.animationSpeed * deltaTime;\n        const previousFrame = this.currentFrame;\n\n        if (this._durations !== null)\n        {\n            let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n\n            lag += elapsed / 60 * 1000;\n\n            while (lag < 0)\n            {\n                this._currentTime--;\n                lag += this._durations[this.currentFrame];\n            }\n\n            const sign = Math.sign(this.animationSpeed * deltaTime);\n\n            this._currentTime = Math.floor(this._currentTime);\n\n            while (lag >= this._durations[this.currentFrame])\n            {\n                lag -= this._durations[this.currentFrame] * sign;\n                this._currentTime += sign;\n            }\n\n            this._currentTime += lag / this._durations[this.currentFrame];\n        }\n        else\n        {\n            this._currentTime += elapsed;\n        }\n\n        if (this._currentTime < 0 && !this.loop)\n        {\n            this.gotoAndStop(0);\n\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (this._currentTime >= this._textures.length && !this.loop)\n        {\n            this.gotoAndStop(this._textures.length - 1);\n\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (previousFrame !== this.currentFrame)\n        {\n            if (this.loop && this.onLoop)\n            {\n                if ((this.animationSpeed > 0 && this.currentFrame < previousFrame)\n                    || (this.animationSpeed < 0 && this.currentFrame > previousFrame))\n                {\n                    this.onLoop();\n                }\n            }\n\n            this.updateTexture();\n        }\n    }\n\n    /** Updates the displayed texture to match the current frame index. */\n    private updateTexture(): void\n    {\n        const currentFrame = this.currentFrame;\n\n        if (this._previousFrame === currentFrame)\n        {\n            return;\n        }\n\n        this._previousFrame = currentFrame;\n\n        this._texture = this._textures[currentFrame];\n        this._textureID = -1;\n        this._textureTrimmedID = -1;\n        this._cachedTint = 0xFFFFFF;\n        this.uvs = this._texture._uvs.uvsFloat32;\n\n        if (this.updateAnchor)\n        {\n            this._anchor.copyFrom(this._texture.defaultAnchor);\n        }\n\n        if (this.onFrameChange)\n        {\n            this.onFrameChange(this.currentFrame);\n        }\n    }\n\n    /**\n     * Stops the AnimatedSprite and destroys it.\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value.\n     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this.stop();\n        super.destroy(options);\n\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of frame ids.\n     * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n     * @returns - The new animated sprite with the specified frames.\n     */\n    public static fromFrames(frames: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < frames.length; ++i)\n        {\n            textures.push(Texture.from(frames[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of image ids.\n     * @param images - The array of image urls the AnimatedSprite will use as its texture frames.\n     * @returns The new animate sprite with the specified images as frames.\n     */\n    public static fromImages(images: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < images.length; ++i)\n        {\n            textures.push(Texture.from(images[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * The total number of frames in the AnimatedSprite. This is the same as number of textures\n     * assigned to the AnimatedSprite.\n     * @readonly\n     * @default 0\n     */\n    get totalFrames(): number\n    {\n        return this._textures.length;\n    }\n\n    /** The array of textures used for this AnimatedSprite. */\n    get textures(): Texture[] | FrameObject[]\n    {\n        return this._textures;\n    }\n\n    set textures(value: Texture[] | FrameObject[])\n    {\n        if (value[0] instanceof Texture)\n        {\n            this._textures = value as Texture[];\n            this._durations = null;\n        }\n        else\n        {\n            this._textures = [];\n            this._durations = [];\n\n            for (let i = 0; i < value.length; i++)\n            {\n                this._textures.push((value[i] as FrameObject).texture);\n                this._durations.push((value[i] as FrameObject).time);\n            }\n        }\n        this._previousFrame = null;\n        this.gotoAndStop(0);\n        this.updateTexture();\n    }\n\n    /** The AnimatedSprite's current frame index. */\n    get currentFrame(): number\n    {\n        let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n\n        if (currentFrame < 0)\n        {\n            currentFrame += this._textures.length;\n        }\n\n        return currentFrame;\n    }\n\n    set currentFrame(value: number)\n    {\n        if (value < 0 || value > this.totalFrames - 1)\n        {\n            throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, `\n                + `expected to be between 0 and totalFrames ${this.totalFrames}.`);\n        }\n\n        const previousFrame = this.currentFrame;\n\n        this._currentTime = value;\n\n        if (previousFrame !== this.currentFrame)\n        {\n            this.updateTexture();\n        }\n    }\n\n    /**\n     * Indicates if the AnimatedSprite is currently playing.\n     * @readonly\n     */\n    get playing(): boolean\n    {\n        return this._playing;\n    }\n\n    /** Whether to use Ticker.shared to auto update animation time. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._playing)\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n}\n\n/** @memberof PIXI.AnimatedSprite */\nexport interface FrameObject\n{\n    /** The {@link PIXI.Texture} of the frame. */\n    texture: Texture;\n\n    /** The duration of the frame, in milliseconds. */\n    time: number;\n}\n", "export { AnimatedSprite } from './AnimatedSprite.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { Point, Rectangle, Texture, TextureMatrix, Transform } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\n\nimport type { IBaseTextureOptions, IPoint, IPointData, ISize, ObservablePoint, Renderer, TextureSource } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\nconst tempPoint = new Point();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface TilingSprite extends GlobalMixins.TilingSprite {}\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @memberof PIXI\n */\nexport class TilingSprite extends Sprite\n{\n    /** Tile transform */\n    public tileTransform: Transform;\n\n    /** Matrix that is applied to UV to get the coords in Texture normalized space to coords in BaseTexture space. */\n    public uvMatrix: TextureMatrix;\n\n    /**\n     * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n     * local space.\n     *\n     * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n     * this, the top-left corner always gets the (0, 0) texture coordinate.\n     * @default false\n     */\n    public uvRespectAnchor: boolean;\n\n    /**\n     * Note: The wrap mode of the texture is forced to REPEAT on render if the size of the texture\n     * is a power of two, the texture's wrap mode is CLAMP, and the texture hasn't been bound yet.\n     * @param texture - The texture of the tiling sprite.\n     * @param width - The width of the tiling sprite.\n     * @param height - The height of the tiling sprite.\n     */\n    constructor(texture: Texture, width = 100, height = 100)\n    {\n        super(texture);\n\n        this.tileTransform = new Transform();\n\n        // The width of the tiling sprite\n        this._width = width;\n\n        // The height of the tiling sprite\n        this._height = height;\n\n        this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture);\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_render' method.\n         * @default 'tilingSprite'\n         */\n        this.pluginName = 'tilingSprite';\n\n        this.uvRespectAnchor = false;\n    }\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin(): number\n    {\n        return this.uvMatrix.clampMargin;\n    }\n\n    set clampMargin(value: number)\n    {\n        this.uvMatrix.clampMargin = value;\n        this.uvMatrix.update(true);\n    }\n\n    /** The scaling of the image that is being tiled. */\n    get tileScale(): ObservablePoint\n    {\n        return this.tileTransform.scale;\n    }\n\n    set tileScale(value: IPointData)\n    {\n        this.tileTransform.scale.copyFrom(value as IPoint);\n    }\n\n    /** The offset of the image that is being tiled. */\n    get tilePosition(): ObservablePoint\n    {\n        return this.tileTransform.position;\n    }\n\n    set tilePosition(value: ObservablePoint)\n    {\n        this.tileTransform.position.copyFrom(value as IPoint);\n    }\n\n    /**\n     * @protected\n     */\n    protected _onTextureUpdate(): void\n    {\n        if (this.uvMatrix)\n        {\n            this.uvMatrix.texture = this._texture;\n        }\n        this._cachedTint = 0xFFFFFF;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        this.tileTransform.updateLocalTransform();\n        this.uvMatrix.update();\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /** Updates the bounds of the tiling sprite. */\n    protected _calculateBounds(): void\n    {\n        const minX = this._width * -this._anchor._x;\n        const minY = this._height * -this._anchor._y;\n        const maxX = this._width * (1 - this._anchor._x);\n        const maxY = this._height * (1 - this._anchor._y);\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     * @param rect - Optional output rectangle.\n     * @returns The bounds.\n     */\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._y);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._bounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Checks if a point is inside this tiling sprite.\n     * @param point - The point to check.\n     * @returns Whether or not the sprite contains the point.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this.anchor._x;\n\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width)\n        {\n            const y1 = -height * this.anchor._y;\n\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite and optionally its texture and children\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        this.tileTransform = null;\n        this.uvMatrix = null;\n    }\n\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     * @static\n     * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {object} options - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @param {number} options.width - required width of the tiling sprite\n     * @param {number} options.height - required height of the tiling sprite\n     * @returns {PIXI.TilingSprite} The newly created texture\n     */\n    static from(source: TextureSource | Texture, options: ISize & IBaseTextureOptions): TilingSprite\n    {\n        const texture = (source instanceof Texture)\n            ? source\n            : Texture.from(source, options);\n\n        return new TilingSprite(\n            texture,\n            options.width,\n            options.height\n        );\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    set width(value: number)\n    {\n        this._width = value;\n    }\n\n    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        return this._height;\n    }\n\n    set height(value: number)\n    {\n        this._height = value;\n    }\n}\n", "var gl2FragmentSrc = \"#version 300 es\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nin vec2 vTextureCoord;\\n\\nout vec4 fragmentColor;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\\n\\n    fragmentColor = texSample * uColor;\\n}\\n\";\n\nexport { gl2FragmentSrc as default };\n//# sourceMappingURL=sprite-tiling.mjs.map\n", "var gl2VertexSrc = \"#version 300 es\\n#define SHADER_NAME Tiling-Sprite-300\\n\\nprecision lowp float;\\n\\nin vec2 aVertexPosition;\\nin vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nout vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\n\nexport { gl2VertexSrc as default };\n//# sourceMappingURL=sprite-tiling2.mjs.map\n", "var gl1FragmentSrc = \"#version 100\\n#ifdef GL_EXT_shader_texture_lod\\n    #extension GL_EXT_shader_texture_lod : enable\\n#endif\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    #ifdef GL_EXT_shader_texture_lod\\n        vec4 texSample = unclamped == coord\\n            ? texture2D(uSampler, coord) \\n            : texture2DLodEXT(uSampler, coord, 0);\\n    #else\\n        vec4 texSample = texture2D(uSampler, coord);\\n    #endif\\n\\n    gl_FragColor = texSample * uColor;\\n}\\n\";\n\nexport { gl1FragmentSrc as default };\n//# sourceMappingURL=sprite-tiling-fallback.mjs.map\n", "var gl1VertexSrc = \"#version 100\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\n\nexport { gl1VertexSrc as default };\n//# sourceMappingURL=sprite-tiling-fallback2.mjs.map\n", "var fragmentSimpleSrc = \"#version 100\\n#define SHADER_NAME Tiling-Sprite-Simple-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\\n    gl_FragColor = texSample * uColor;\\n}\\n\";\n\nexport { fragmentSimpleSrc as default };\n//# sourceMappingURL=sprite-tiling-simple.mjs.map\n", "import {\n    Color,\n    extensions,\n    ExtensionType,\n    Matrix,\n    ObjectRenderer,\n    QuadUv,\n    Shader,\n    State,\n    utils,\n    WRAP_MODES\n} from '@pixi/core';\nimport gl2FragmentSrc from './sprite-tiling.frag';\nimport gl2VertexSrc from './sprite-tiling.vert';\nimport gl1FragmentSrc from './sprite-tiling-fallback.frag';\nimport gl1VertexSrc from './sprite-tiling-fallback.vert';\nimport fragmentSimpleSrc from './sprite-tiling-simple.frag';\n\nimport type { ExtensionMetadata, Renderer } from '@pixi/core';\nimport type { TilingSprite } from './TilingSprite';\n\nconst tempMat = new Matrix();\n\n/**\n * WebGL renderer plugin for tiling sprites\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport class TilingSpriteRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'tilingSprite',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    public shader: Shader;\n    public simpleShader: Shader;\n    public quad: QuadUv;\n    public readonly state: State;\n\n    /**\n     * constructor for renderer\n     * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        // WebGL version is not available during initialization!\n        renderer.runners.contextChange.add(this);\n\n        this.quad = new QuadUv();\n\n        /**\n         * The WebGL state in which this renderer will work.\n         * @member {PIXI.State}\n         * @readonly\n         */\n        this.state = State.for2d();\n    }\n\n    /** Creates shaders when context is initialized. */\n    contextChange(): void\n    {\n        const renderer = this.renderer;\n        const uniforms = { globals: renderer.globalUniforms };\n\n        this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n        this.shader = renderer.context.webGLVersion > 1\n            ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms)\n            : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n    }\n\n    /**\n     * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n     */\n    public render(ts: TilingSprite): void\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n        const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n\n        vertices = quad.uvs;\n\n        vertices[0] = vertices[6] = -anchorX;\n        vertices[1] = vertices[3] = -anchorY;\n\n        vertices[2] = vertices[4] = 1.0 - anchorX;\n        vertices[5] = vertices[7] = 1.0 - anchorY;\n\n        quad.invalidate();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const premultiplied = baseTex.alphaMode > 0;\n        const lt = ts.tileTransform.localTransform;\n        const uv = ts.uvMatrix;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[renderer.CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        const w = tex.width;\n        const h = tex.height;\n        const W = ts._width;\n        const H = ts._height;\n\n        tempMat.set(lt.a * w / W,\n            lt.b * w / H,\n            lt.c * h / W,\n            lt.d * h / H,\n            lt.tx / W,\n            lt.ty / H);\n\n        // that part is the same as above:\n        // tempMat.identity();\n        // tempMat.scale(tex.width, tex.height);\n        // tempMat.prepend(lt);\n        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = Color.shared\n            .setValue(ts.tint)\n            .premultiply(ts.worldAlpha, premultiplied)\n            .toArray(shader.uniforms.uColor);\n\n        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n        shader.uniforms.uSampler = tex;\n\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(quad);\n\n        this.state.blendMode = utils.correctBlendMode(ts.blendMode, premultiplied);\n        renderer.state.set(this.state);\n        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n}\n\nextensions.add(TilingSpriteRenderer);\n", "export { TilingSprite } from './TilingSprite.mjs';\nexport { TilingSpriteRenderer } from './TilingSpriteRenderer.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { autoDetectRenderer, extensions, ExtensionType } from '@pixi/core';\nimport { Container } from '@pixi/display';\n\nimport type { ICanvas, IRenderer, IRendererOptionsAuto, Rectangle } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\n/**\n * Any plugin that's usable for Application should contain these methods.\n * @memberof PIXI\n */\nexport interface IApplicationPlugin\n{\n    /**\n     * Called when Application is constructed, scoped to Application instance.\n     * Passes in `options` as the only argument, which are Application constructor options.\n     * @param {object} options - Application options.\n     */\n    init(options: Partial<IApplicationOptions>): void;\n    /** Called when destroying Application, scoped to Application instance. */\n    destroy(): void;\n}\n\n/**\n * Application options supplied to constructor.\n * @memberof PIXI\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IApplicationOptions extends IRendererOptionsAuto, GlobalMixins.IApplicationOptions {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Application extends GlobalMixins.Application {}\n\n/**\n * Convenience class to create a new PixiJS application.\n *\n * This class automatically creates the renderer, ticker and root container.\n * @example\n * import { Application, Sprite } from 'pixi.js';\n *\n * // Create the application\n * const app = new Application();\n *\n * // Add the view to the DOM\n * document.body.appendChild(app.view);\n *\n * // ex, add display objects\n * app.stage.addChild(Sprite.from('something.png'));\n * @class\n * @memberof PIXI\n */\nexport class Application<VIEW extends ICanvas = ICanvas>\n{\n    /** Collection of installed plugins. */\n    static _plugins: IApplicationPlugin[] = [];\n\n    /**\n     * The root display container that's rendered.\n     * @member {PIXI.Container}\n     */\n    public stage: Container = new Container();\n\n    /**\n     * WebGL renderer if available, otherwise CanvasRenderer.\n     * @member {PIXI.Renderer|PIXI.CanvasRenderer}\n     */\n    public renderer: IRenderer<VIEW>;\n\n    /**\n     * @param options - The optional application and renderer parameters.\n     */\n    constructor(options?: Partial<IApplicationOptions>)\n    {\n        // The default options\n        options = Object.assign({\n            forceCanvas: false,\n        }, options);\n\n        this.renderer = autoDetectRenderer<VIEW>(options);\n\n        // install plugins here\n        Application._plugins.forEach((plugin) =>\n        {\n            plugin.init.call(this, options);\n        });\n    }\n\n    /** Render the current stage. */\n    public render(): void\n    {\n        this.renderer.render(this.stage);\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @member {PIXI.ICanvas}\n     * @readonly\n     */\n    get view(): VIEW\n    {\n        return this.renderer.view;\n    }\n\n    /**\n     * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n     * @member {PIXI.Rectangle}\n     * @readonly\n     */\n    get screen(): Rectangle\n    {\n        return this.renderer.screen;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param {boolean} [removeView=false] - Automatically remove canvas from DOM.\n     * @param {object|boolean} [stageOptions] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [stageOptions.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'stageOptions' will be passed on to those calls.\n     * @param {boolean} [stageOptions.texture=false] - Only used for child Sprites if stageOptions.children is set\n     *  to true. Should it destroy the texture of the child sprite\n     * @param {boolean} [stageOptions.baseTexture=false] - Only used for child Sprites if stageOptions.children is set\n     *  to true. Should it destroy the base texture of the child sprite\n     */\n    public destroy(removeView?: boolean, stageOptions?: IDestroyOptions | boolean): void\n    {\n        // Destroy plugins in the opposite order\n        // which they were constructed\n        const plugins = Application._plugins.slice(0);\n\n        plugins.reverse();\n        plugins.forEach((plugin) =>\n        {\n            plugin.destroy.call(this);\n        });\n\n        this.stage.destroy(stageOptions);\n        this.stage = null;\n\n        this.renderer.destroy(removeView);\n        this.renderer = null;\n    }\n}\n\nextensions.handleByList(ExtensionType.Application, Application._plugins);\n", "import { extensions, ExtensionType } from '@pixi/core';\n\nimport type { ExtensionMetadata, Renderer } from '@pixi/core';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize stage to.\n     * @memberof PIXI.IApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for for Application's resize functionality\n * @private\n * @class\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof PIXI.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof PIXI.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this.cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof PIXI.Application#\n         * @method cancelResize\n         * @private\n         */\n        this.cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof PIXI.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this.cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this.cancelResize();\n        this.cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n\nextensions.add(ResizePlugin);\n", "export { Application } from './Application.mjs';\nexport { ResizePlugin } from './ResizePlugin.mjs';\n//# sourceMappingURL=index.mjs.map\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMY,IAAA;AAAA;;IAAA,iBAAA,CAAA,mBAAL;AAOH,qBAAA,eAAA,iBAAA,IAAkB,CAAlB,IAAA;AAKA,qBAAA,eAAA,mBAAA,IAAoB,CAApB,IAAA;AAZQ,aAAA;IAAA,GAAA,iBAAA,CAAA,CAAA;;;;;ICAN,WACA,SA4BO;;;;;AA7Bb,IAAM,YAAY,IAAI,MAAM;AAC5B,IAAM,UAAU,IAAI,YAAY,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;AA4B3C,IAAM,SAAN,MAAM,gBAAe,UAC5B;MAsGI,YAAY,SACZ;AACU,cAAA;AAEN,aAAK,UAAU,IAAI,gBACf,KAAK,iBACL,MACC,UAAU,QAAQ,cAAc,IAAI,GACpC,UAAU,QAAQ,cAAc,IAAI,CACzC;AAEA,aAAK,WAAW;AAEhB,aAAK,SAAS;AACd,aAAK,UAAU;AACV,aAAA,aAAa,IAAI,MAAM,QAAQ;AACpC,aAAK,WAAW;AAEhB,aAAK,OAAO;AACZ,aAAK,YAAY,YAAY;AAC7B,aAAK,cAAc;AACnB,aAAK,MAAM;AAGN,aAAA,UAAU,WAAW,QAAQ;AAC7B,aAAA,aAAa,IAAI,aAAa,CAAC;AACpC,aAAK,oBAAoB;AAEzB,aAAK,eAAe;AACpB,aAAK,aAAa;AAElB,aAAK,sBAAsB;AAC3B,aAAK,oBAAoB;AAIzB,aAAK,UAAU;AAEf,aAAK,aAAa;AAMlB,aAAK,WAAW;AAChB,aAAK,eAAe,SAAS;MAAA;MAIjC,mBACA;AACI,aAAK,aAAa;AAClB,aAAK,oBAAoB;AACzB,aAAK,cAAc;AAGnB,YAAI,KAAK,QACT;AACI,eAAK,MAAM,IAAI,YAAM,KAAK,KAAK,MAAM,CAAC,IAAI,KAAK,SAAS,KAAK,SAAS,KAAK;QAAA;AAG/E,YAAI,KAAK,SACT;AACI,eAAK,MAAM,IAAI,YAAM,KAAK,KAAK,MAAM,CAAC,IAAI,KAAK,UAAU,KAAK,SAAS,KAAK;QAAA;MAChF;MAIJ,kBACA;AACI,aAAK,eAAe;AACpB,aAAK,sBAAsB;MAAA;MAI/B,oBACA;AACI,cAAM,UAAU,KAAK;AAEjB,YAAA,KAAK,iBAAiB,KAAK,UAAU,YAAY,KAAK,eAAe,QAAQ,WACjF;AACI;QAAA;AAIA,YAAA,KAAK,eAAe,QAAQ,WAChC;AACS,eAAA,MAAM,KAAK,SAAS,KAAK;QAAA;AAG7B,aAAA,eAAe,KAAK,UAAU;AACnC,aAAK,aAAa,QAAQ;AAIpB,cAAA,KAAK,KAAK,UAAU;AAC1B,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,KAAK,GAAG;AACd,cAAM,KAAK,GAAG;AACd,cAAM,aAAa,KAAK;AACxB,cAAM,OAAO,QAAQ;AACrB,cAAM,OAAO,QAAQ;AACrB,cAAM,SAAS,KAAK;AAEpB,YAAI,KAAK;AACT,YAAI,KAAK;AACT,YAAI,KAAK;AACT,YAAI,KAAK;AAET,YAAI,MACJ;AAGI,eAAK,KAAK,IAAK,OAAO,KAAK,KAAK;AAChC,eAAK,KAAK,KAAK;AAEf,eAAK,KAAK,IAAK,OAAO,KAAK,KAAK;AAChC,eAAK,KAAK,KAAK;QAAA,OAGnB;AACS,eAAA,CAAC,OAAO,KAAK,KAAK;AACvB,eAAK,KAAK,KAAK;AAEV,eAAA,CAAC,OAAO,KAAK,KAAK;AACvB,eAAK,KAAK,KAAK;QAAA;AAInB,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AACtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AAGtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AACtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AAGtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AACtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AAGtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AACtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AAEtC,YAAI,KAAK,cACT;AACI,gBAAM,aAAa,SAAS;AAE5B,mBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,EAAE,GACzC;AACI,uBAAW,CAAA,IAAK,KAAK,MAAM,WAAW,CAAA,IAAK,UAAU,IAAI;UAAA;QAC7D;MACJ;MAQJ,2BACA;AACQ,YAAA,CAAC,KAAK,mBACV;AACS,eAAA,oBAAoB,IAAI,aAAa,CAAC;QAAA,WAEtC,KAAK,wBAAwB,KAAK,UAAU,YAAY,KAAK,sBAAsB,KAAK,SAAS,WAC1G;AACI;QAAA;AAGC,aAAA,sBAAsB,KAAK,UAAU;AACrC,aAAA,oBAAoB,KAAK,SAAS;AAGvC,cAAM,UAAU,KAAK;AACrB,cAAM,aAAa,KAAK;AACxB,cAAM,OAAO,QAAQ;AACrB,cAAM,SAAS,KAAK;AAGd,cAAA,KAAK,KAAK,UAAU;AAC1B,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,KAAK,GAAG;AACd,cAAM,KAAK,GAAG;AAEd,cAAM,KAAK,CAAC,OAAO,KAAK,KAAK;AACvB,cAAA,KAAK,KAAK,KAAK;AAErB,cAAM,KAAK,CAAC,OAAO,KAAK,KAAK;AACvB,cAAA,KAAK,KAAK,KAAK;AAGrB,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AACtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AAGtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AACtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AAGtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AACtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AAGtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;AACtC,mBAAW,CAAM,IAAA,IAAI,KAAO,IAAI,KAAM;MAAA;MAQhC,QAAQ,UAClB;AACI,aAAK,kBAAkB;AAEvB,iBAAS,MAAM,kBAAkB,SAAS,QAAQ,KAAK,UAAW,CAAA;AAClE,iBAAS,QAAQ,KAAK,UAAY,EAAA,OAAO,IAAI;MAAA;MAIjD,mBACA;AACU,cAAA,OAAO,KAAK,SAAS;AACrB,cAAA,OAAO,KAAK,SAAS;AAGvB,YAAA,CAAC,QAAS,KAAK,UAAU,KAAK,SAAS,KAAK,WAAW,KAAK,QAChE;AAEI,eAAK,kBAAkB;AAClB,eAAA,QAAQ,QAAQ,KAAK,UAAU;QAAA,OAGxC;AAEI,eAAK,yBAAyB;AACzB,eAAA,QAAQ,QAAQ,KAAK,iBAAiB;QAAA;MAC/C;MAQG,eAAe,MACtB;AAEQ,YAAA,KAAK,SAAS,WAAW,GAC7B;AACQ,cAAA,CAAC,KAAK,cACV;AACS,iBAAA,eAAe,IAAI,OAAO;UAAA;AAG9B,eAAA,aAAa,OAAO,KAAK,SAAS,KAAK,QAAQ,CAAC,KAAK,QAAQ;AAC7D,eAAA,aAAa,OAAO,KAAK,SAAS,KAAK,SAAS,CAAC,KAAK,QAAQ;AAC9D,eAAA,aAAa,OAAO,KAAK,SAAS,KAAK,SAAS,IAAI,KAAK,QAAQ;AACjE,eAAA,aAAa,OAAO,KAAK,SAAS,KAAK,UAAU,IAAI,KAAK,QAAQ;AAEvE,cAAI,CAAC,MACL;AACQ,gBAAA,CAAC,KAAK,kBACV;AACS,mBAAA,mBAAmB,IAAI,UAAU;YAAA;AAG1C,mBAAO,KAAK;UAAA;AAGT,iBAAA,KAAK,aAAa,aAAa,IAAI;QAAA;AAG9C,eAAO,MAAM,eAAe,KAAK,MAAM,IAAI;MAAA;MAQxC,cAAc,OACrB;AACS,aAAA,eAAe,aAAa,OAAO,SAAS;AAE3C,cAAA,QAAQ,KAAK,SAAS,KAAK;AAC3B,cAAA,SAAS,KAAK,SAAS,KAAK;AAClC,cAAM,KAAK,CAAC,QAAQ,KAAK,OAAO;AAChC,YAAI,KAAK;AAET,YAAI,UAAU,KAAK,MAAM,UAAU,IAAI,KAAK,OAC5C;AACS,eAAA,CAAC,SAAS,KAAK,OAAO;AAE3B,cAAI,UAAU,KAAK,MAAM,UAAU,IAAI,KAAK,QAC5C;AACW,mBAAA;UAAA;QACX;AAGG,eAAA;MAAA;MAYJ,QAAQ,SACf;AACI,cAAM,QAAQ,OAAO;AAErB,aAAK,SAAS,IAAI,UAAU,KAAK,kBAAkB,IAAI;AAEvD,aAAK,UAAU;AAEf,cAAM,iBAAiB,OAAO,YAAY,YAAY,UAAU,mCAAS;AAEzE,YAAI,gBACJ;AACI,gBAAM,qBAAqB,OAAO,YAAY,YAAY,UAAU,mCAAS;AAE7E,eAAK,SAAS,QAAQ,CAAC,CAAC,kBAAkB;QAAA;AAG9C,aAAK,WAAW;MAAA;MAapB,OAAO,KAAK,QAAsB,SAClC;AACI,cAAM,UAAW,kBAAkB,UAC7B,SACA,QAAQ,KAAK,QAAQ,OAAO;AAE3B,eAAA,IAAI,QAAO,OAAO;MAAA;MAY7B,IAAI,YAAY,OAChB;AACQ,YAAA,KAAK,iBAAiB,OAC1B;AACI,eAAK,eAAe;QAAA;AAExB,aAAK,eAAe;MAAA;MAGxB,IAAI,cACJ;AACI,eAAO,KAAK;MAAA;MAIhB,IAAI,QACJ;AACW,eAAA,KAAK,IAAI,KAAK,MAAM,CAAC,IAAI,KAAK,SAAS,KAAK;MAAA;MAGvD,IAAI,MAAM,OACV;AACI,cAAM,IAAI,YAAM,KAAK,KAAK,MAAM,CAAC,KAAK;AAEtC,aAAK,MAAM,IAAI,IAAI,QAAQ,KAAK,SAAS,KAAK;AAC9C,aAAK,SAAS;MAAA;MAIlB,IAAI,SACJ;AACW,eAAA,KAAK,IAAI,KAAK,MAAM,CAAC,IAAI,KAAK,SAAS,KAAK;MAAA;MAGvD,IAAI,OAAO,OACX;AACI,cAAM,IAAI,YAAM,KAAK,KAAK,MAAM,CAAC,KAAK;AAEtC,aAAK,MAAM,IAAI,IAAI,QAAQ,KAAK,SAAS,KAAK;AAC9C,aAAK,UAAU;MAAA;MAoBnB,IAAI,SACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,OAAO,OACX;AACS,aAAA,QAAQ,SAAS,KAAK;MAAA;MAS/B,IAAI,OACJ;AACI,eAAO,KAAK,WAAW;MAAA;MAG3B,IAAI,KAAK,OACT;AACS,aAAA,WAAW,SAAS,KAAK;AACzB,aAAA,WAAW,KAAK,WAAW,qBAAqB;MAAA;MAOzD,IAAI,YACJ;AACW,eAAA,KAAK,WAAW,SAAS;MAAA;MAIpC,IAAI,UACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,QAAQ,OACZ;AACQ,YAAA,KAAK,aAAa,OACtB;AACI;QAAA;AAGJ,YAAI,KAAK,UACT;AACI,eAAK,SAAS,IAAI,UAAU,KAAK,kBAAkB,IAAI;QAAA;AAGtD,aAAA,WAAW,SAAS,QAAQ;AACjC,aAAK,cAAc;AAEnB,aAAK,aAAa;AAClB,aAAK,oBAAoB;AAEzB,YAAI,OACJ;AAEQ,cAAA,MAAM,YAAY,OACtB;AACI,iBAAK,iBAAiB;UAAA,OAG1B;AACI,kBAAM,KAAK,UAAU,KAAK,kBAAkB,IAAI;UAAA;QACpD;MACJ;IAER;;;;;AC/nBA,IAAAA,YAAA;AAAA;AAAA;AAAA;AAAA;;;ICsDM,iBAmBO,cAAA;;;;AAnBb,IAAM,kBAAqD;MAEvD,oBAAoB;IACxB;AAgBO,IAAM,eAAN,MACP;MA4EI,WAAkB,qCAClB;AACI,YAAI,SAAS,aAAY;AAEzB,YAAI,WAAW,QACf;AACI,gBAAM,QAAQ,SAAS,QAAQ,4BAAA,EAA8B;AAE7D,mBACM,aAAY,sCACZ,mBAAmB,SAAS,uBAAuB;QAAA;AAGtD,eAAA;MAAA;MAoDX,YAAY,MAAc,OAAkB,OAAe,QAAgB,OAAiB,YACxF,YAAoB,cAAsB,gBAC9C;AACI,aAAK,OAAO;AACZ,aAAK,QAAQ;AACb,aAAK,QAAQ;AACb,aAAK,SAAS;AACd,aAAK,QAAQ;AACb,aAAK,aAAa;AAClB,aAAK,aAAa;AAClB,aAAK,eAAe;AACpB,aAAK,iBAAiB;MAAA;MAW1B,OAAc,YACV,MACA,OACA,UACA,SAAkB,aAAY,SAElC;AACI,mBAAY,aAAa,UAAa,aAAa,OAAQ,MAAM,WAAW;AACtE,cAAA,OAAO,MAAM,aAAa;AAC1B,cAAA,iBAAiB,aAAY,YAAY,IAAI;AAI/C,YAAA,eAAe,aAAa,GAChC;AACI,yBAAe,WAAW,MAAM;AAChC,yBAAe,SAAS,MAAM;QAAA;AAGlC,cAAM,UAAU,OAAO,WAAW,MAAM,eAAe;AAEvD,gBAAQ,OAAO;AAEf,cAAM,aAAa,WAAW,aAAY,SAAS,MAAM,OAAO,MAAM,IAAI;AACpE,cAAA,QAAQ,WAAW,MAAM,gBAAgB;AAC/C,cAAM,aAAa,IAAI,MAAc,MAAM,MAAM;AACjD,YAAI,eAAe;AAEnB,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAClC;AACI,gBAAM,YAAY,aAAY,aAAa,MAAM,CAAI,GAAA,MAAM,eAAe,OAAO;AAEjF,qBAAW,CAAK,IAAA;AACD,yBAAA,KAAK,IAAI,cAAc,SAAS;QAAA;AAE/C,YAAA,QAAQ,eAAe,MAAM;AAEjC,YAAI,MAAM,YACV;AACI,mBAAS,MAAM;QAAA;AAGnB,cAAM,aAAa,MAAM,cAAc,eAAe,WAAW,MAAM;AACvE,YAAI,SAAS,KAAK,IAAI,YAAY,eAAe,WAAY,MAAM,kBAAkB,CAAE,KAC/E,MAAM,SAAS,MAAA,aAAmB,MAAM;AAEhD,YAAI,MAAM,YACV;AACI,oBAAU,MAAM;QAAA;AAGpB,eAAO,IAAI,aACP,MACA,OACA,OACA,QACA,OACA,YACA,aAAa,MAAM,SACnB,cACA,cACJ;MAAA;MAGJ,OAAe,aACX,MACA,eACA,SAEJ;AACI,YAAI,+BAA+B;AAEnC,YAAI,aAAY,oCAChB;AACI,cAAI,aAAY,2BAChB;AACI,oBAAQ,gBAAgB,GAAG,aAAA;AAC3B,oBAAQ,oBAAoB,GAAG,aAAA;AACA,2CAAA;UAAA,OAGnC;AACI,oBAAQ,gBAAgB;AACxB,oBAAQ,oBAAoB;UAAA;QAChC;AAGJ,YAAI,QAAQ,QAAQ,YAAY,IAAI,EAAE;AAEtC,YAAI,QAAQ,GACZ;AACI,cAAI,8BACJ;AACa,qBAAA;UAAA,OAGb;AACI,sBAAsB,aAAA,kBAAkB,IAAI,EAAE,SAAS,KAAK;UAAA;QAChE;AAGG,eAAA;MAAA;MAWX,OAAe,SACX,MACA,OACA,SAAkB,aAAY,SAElC;AACI,cAAM,UAAU,OAAO,WAAW,MAAM,eAAe;AAEvD,YAAI,QAAQ;AACZ,YAAI,OAAO;AACX,YAAI,QAAQ;AAEN,cAAA,QAAoC,uBAAA,OAAO,IAAI;AAC/C,cAAA,EAAE,eAAe,WAAe,IAAA;AAGhC,cAAA,iBAAiB,aAAY,eAAe,UAAU;AACtD,cAAA,mBAAmB,aAAY,iBAAiB,UAAU;AAGhE,YAAI,mBAAmB,CAAC;AAQlB,cAAA,gBAAgB,MAAM,gBAAgB;AAGtC,cAAA,SAAS,aAAY,SAAS,IAAI;AAExC,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KACnC;AAEI,cAAI,QAAQ,OAAO,CAAA;AAGf,cAAA,aAAY,UAAU,KAAK,GAC/B;AAEI,gBAAI,CAAC,kBACL;AACa,uBAAA,aAAY,QAAQ,IAAI;AACjC,iCAAmB,CAAC;AACb,qBAAA;AACC,sBAAA;AACR;YAAA;AAKI,oBAAA;UAAA;AAIZ,cAAI,gBACJ;AAEU,kBAAA,sBAAsB,aAAY,gBAAgB,KAAK;AAC7D,kBAAM,sBAAsB,aAAY,gBAAgB,KAAK,KAAK,SAAS,CAAE,CAAA;AAE7E,gBAAI,uBAAuB,qBAC3B;AACI;YAAA;UACJ;AAIJ,gBAAM,aAAa,aAAY,aAAa,OAAO,eAAe,OAAO,OAAO;AAGhF,cAAI,aAAa,eACjB;AAEI,gBAAI,SAAS,IACb;AAEa,uBAAA,aAAY,QAAQ,IAAI;AAC1B,qBAAA;AACC,sBAAA;YAAA;AAIZ,gBAAI,aAAY,cAAc,OAAO,MAAM,UAAU,GACrD;AAEU,oBAAA,aAAa,aAAY,cAAc,KAAK;AAGlD,uBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KACvC;AACI,oBAAI,OAAO,WAAW,CAAA;AACtB,oBAAI,WAAW;AAEf,oBAAI,IAAI;AAGD,uBAAA,WAAW,IAAI,CACtB,GAAA;AACU,wBAAA,WAAW,WAAW,IAAI,CAAA;AAG5B,sBAAA,CAAC,aAAY,cAAc,UAAU,UAAU,OAAO,GAAG,MAAM,UAAU,GAC7E;AAEY,4BAAA;kBAAA,OAGZ;AACI;kBAAA;AAGO,6BAAA;AACX;gBAAA;AAGJ,qBAAK,IAAI;AAET,sBAAM,iBAAiB,aAAY,aAAa,MAAM,eAAe,OAAO,OAAO;AAE/E,oBAAA,iBAAiB,QAAQ,eAC7B;AACa,2BAAA,aAAY,QAAQ,IAAI;AACd,qCAAA;AACZ,yBAAA;AACC,0BAAA;gBAAA;AAGJ,wBAAA;AACC,yBAAA;cAAA;YACb,OAKJ;AAGQ,kBAAA,KAAK,SAAS,GAClB;AACa,yBAAA,aAAY,QAAQ,IAAI;AAC1B,uBAAA;AACC,wBAAA;cAAA;AAGN,oBAAA,cAAc,MAAM,OAAO,SAAS;AAG1C,uBAAS,aAAY,QAAQ,OAAO,CAAC,WAAW;AAC7B,iCAAA;AACZ,qBAAA;AACC,sBAAA;YAAA;UACZ,OAKJ;AAGQ,gBAAA,aAAa,QAAQ,eACzB;AAEuB,iCAAA;AAGV,uBAAA,aAAY,QAAQ,IAAI;AAG1B,qBAAA;AACC,sBAAA;YAAA;AAIR,gBAAA,KAAK,SAAS,KAAK,CAAC,aAAY,gBAAgB,KAAK,KAAK,kBAC9D;AAEY,sBAAA;AAGC,uBAAA;YAAA;UACb;QACJ;AAGK,iBAAA,aAAY,QAAQ,MAAM,KAAK;AAEjC,eAAA;MAAA;MASX,OAAe,QAAQ,MAAc,UAAU,MAC/C;AACW,eAAA,aAAY,UAAU,IAAI;AAEjC,eAAQ,UAAW,GAAG,IAAA;IAAW;AAE1B,eAAA;MAAA;MAWX,OAAe,aAAa,KAAa,eAAuB,OAC5D,SACJ;AACI,YAAI,QAAQ,MAAM,GAAA;AAEd,YAAA,OAAO,UAAU,UACrB;AACI,kBAAQ,aAAY,aAAa,KAAK,eAAe,OAAO,IAAI;AAChE,gBAAM,GAAO,IAAA;QAAA;AAGV,eAAA;MAAA;MAQX,OAAe,eAAe,YAC9B;AACY,eAAA,eAAe,YAAY,eAAe;MAAA;MAQtD,OAAe,iBAAiB,YAChC;AACI,eAAQ,eAAe;MAAA;MAQ3B,OAAe,UAAU,MACzB;AACQ,YAAA,OAAO,SAAS,UACpB;AACW,iBAAA;QAAA;AAGX,iBAAS,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,KACtC;AACI,gBAAM,OAAO,KAAK,CAAA;AAElB,cAAI,CAAC,aAAY,gBAAgB,IAAI,GACrC;AACI;UAAA;AAGG,iBAAA,KAAK,MAAM,GAAG,EAAE;QAAA;AAGpB,eAAA;MAAA;MAQX,OAAe,UAAU,MACzB;AACQ,YAAA,OAAO,SAAS,UACpB;AACW,iBAAA;QAAA;AAGX,eAAO,aAAY,UAAU,SAAS,KAAK,WAAW,CAAC,CAAC;MAAA;MAa5D,OAAO,gBAAgB,MAAc,WACrC;AACQ,YAAA,OAAO,SAAS,UACpB;AACW,iBAAA;QAAA;AAGX,eAAO,aAAY,gBAAgB,SAAS,KAAK,WAAW,CAAC,CAAC;MAAA;MAQlE,OAAe,SAAS,MACxB;AACI,cAAM,SAAmB,CAAA;AACzB,YAAI,QAAQ;AAER,YAAA,OAAO,SAAS,UACpB;AACW,iBAAA;QAAA;AAGX,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KACjC;AACI,gBAAM,OAAO,KAAK,CAAA;AACZ,gBAAA,WAAW,KAAK,IAAI,CAAA;AAEtB,cAAA,aAAY,gBAAgB,MAAM,QAAQ,KAAK,aAAY,UAAU,IAAI,GAC7E;AACI,gBAAI,UAAU,IACd;AACI,qBAAO,KAAK,KAAK;AACT,sBAAA;YAAA;AAGZ,mBAAO,KAAK,IAAI;AAEhB;UAAA;AAGK,mBAAA;QAAA;AAGb,YAAI,UAAU,IACd;AACI,iBAAO,KAAK,KAAK;QAAA;AAGd,eAAA;MAAA;MAaX,OAAO,cAAc,QAAgB,YACrC;AACW,eAAA;MAAA;MAiBX,OAAO,cAAc,OAAe,WAAmB,QAAgB,QACnE,aACJ;AACW,eAAA;MAAA;MAaX,OAAO,cAAc,OACrB;AACW,eAAA,aAAY,kBAAkB,KAAK;MAAA;MAQ9C,OAAc,YAAY,MAC1B;AAEQ,YAAA,aAAY,OAAO,IACvB,GAAA;AACI,iBAAO,aAAY,OAAO,IAAA;QAAA;AAG9B,cAAM,aAA2B;UAC7B,QAAQ;UACR,SAAS;UACT,UAAU;QAAA;AAGd,cAAM,SAAS,aAAY;AAC3B,cAAM,UAAU,aAAY;AAE5B,gBAAQ,OAAO;AAET,cAAA,gBAAgB,aAAY,iBAAiB,aAAY;AAC/D,cAAM,QAAQ,KAAK,KAAK,QAAQ,YAAY,aAAa,EAAE,KAAK;AAC5D,YAAA,WAAW,KAAK,KAAK,QAAQ,YAAY,aAAY,eAAe,EAAE,KAAK;AAC/E,cAAM,SAAS,KAAK,KAAK,aAAY,oBAAoB,QAAQ;AAEtD,mBAAA,WAAW,aAAY,sBAAsB;AAEpD,YAAA,UAAU,KAAK,WAAW,GAC9B;AACI,uBAAY,OAAO,IAAQ,IAAA;AAEpB,iBAAA;QAAA;AAGX,eAAO,QAAQ;AACf,eAAO,SAAS;AAEhB,gBAAQ,YAAY;AACpB,gBAAQ,SAAS,GAAG,GAAG,OAAO,MAAM;AAEpC,gBAAQ,OAAO;AAEf,gBAAQ,eAAe;AACvB,gBAAQ,YAAY;AACZ,gBAAA,SAAS,eAAe,GAAG,QAAQ;AAE3C,cAAM,YAAY,QAAQ,aAAa,GAAG,GAAG,OAAO,MAAM,EAAE;AAC5D,cAAM,SAAS,UAAU;AACzB,cAAM,OAAO,QAAQ;AAErB,YAAI,IAAI;AACR,YAAI,MAAM;AACV,YAAI,OAAO;AAGX,aAAK,IAAI,GAAG,IAAI,UAAU,EAAE,GAC5B;AACI,mBAAS,IAAI,GAAG,IAAI,MAAM,KAAK,GAC/B;AACQ,gBAAA,UAAU,MAAM,CAAA,MAAO,KAC3B;AACW,qBAAA;AACP;YAAA;UACJ;AAEJ,cAAI,CAAC,MACL;AACW,mBAAA;UAAA,OAGX;AACI;UAAA;QACJ;AAGJ,mBAAW,SAAS,WAAW;AAE/B,cAAM,SAAS;AACR,eAAA;AAGP,aAAK,IAAI,QAAQ,IAAI,UAAU,EAAE,GACjC;AACI,mBAAS,IAAI,GAAG,IAAI,MAAM,KAAK,GAC/B;AACQ,gBAAA,UAAU,MAAM,CAAA,MAAO,KAC3B;AACW,qBAAA;AACP;YAAA;UACJ;AAGJ,cAAI,CAAC,MACL;AACW,mBAAA;UAAA,OAGX;AACI;UAAA;QACJ;AAGJ,mBAAW,UAAU,IAAI;AACd,mBAAA,WAAW,WAAW,SAAS,WAAW;AAErD,qBAAY,OAAO,IAAQ,IAAA;AAEpB,eAAA;MAAA;MAOX,OAAc,aAAa,OAAO,IAClC;AACI,YAAI,MACJ;AACI,iBAAO,aAAY,OAAO,IAAA;QAAA,OAG9B;AACI,uBAAY,SAAS,CAAA;QAAC;MAC1B;MAQJ,WAAkB,UAClB;AACQ,YAAA,CAAC,aAAY,UACjB;AACQ,cAAA;AAGJ,cAAA;AAEI,kBAAM,IAAI,IAAI,gBAAgB,GAAG,CAAC;AAClC,kBAAM,UAAU,EAAE,WAAW,MAAM,eAAe;AAElD,gBAAI,mCAAS,aACb;AACI,2BAAY,WAAW;AAEhB,qBAAA;YAAA;AAGF,qBAAA,SAAS,QAAQ,aAAa;UAAA,SAEpC,IAAP;AAEa,qBAAA,SAAS,QAAQ,aAAa;UAAA;AAEpC,iBAAA,QAAQ,OAAO,SAAS;AAC/B,uBAAY,WAAW;QAAA;AAG3B,eAAO,aAAY;MAAA;MAOvB,WAAkB,WAClB;AACQ,YAAA,CAAC,aAAY,WACjB;AACI,uBAAY,YAAY,aAAY,QAAQ,WAAW,MAAM,eAAe;QAAA;AAGhF,eAAO,aAAY;MAAA;IAE3B;AA71BO,IAAM,cAAN;AAAM,gBAiCK,iBAAiB;AAjCtB,gBAoCK,kBAAkB;AApCvB,gBAuCK,sBAAsB;AAvC3B,gBA0CK,oBAAoB;AAalC,gBAAc,qBACd,MAAA;AACQ,UAAA,QAAQ,6BAAgB,eAAc,YAC1C;AACU,cAAA,YAAY,IAAK,KAAe,UAAU;AAEhD,eAAO,CAAC,MAAc,CAAC,GAAG,UAAU,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,OAAO;MAAA;AAGxE,aAAO,CAAC,MAAc,CAAC,GAAG,CAAC;IAC/B,GAAG;AAjEM,gBAmGK,4BAA4B;AAG1C,gBAAe,SAAuC,CAAA;AAtG7C,gBAyGM,YAAsB;MACjC;MACA;IACJ;AA5GS,gBA+GM,kBAA4B;MACvC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACJ;;;;;AC2pBJ,SAAA,SAAkB,OAClB;AACI,QAAM,OAAO,MAAM;AAEnB,MAAI,CAAC,MAAM,QAAQ,KAAK,GACxB;AACI,WAAO,KAAK,SAAS,KAAK,EAAE,MAAM;EAAA,OAGtC;AACW,WAAA,MAAM,IAAI,CAAK,MAAA,KAAK,SAAS,CAAC,EAAE,MAAA,CAAO;EAAA;AAEtD;AAUA,SAAA,eAA2B,QAAa,QACxC;AACQ,MAAA,CAAC,MAAM,QAAQ,MAAM,KAAK,CAAC,MAAM,QAAQ,MAAM,GACnD;AACW,WAAA;EAAA;AAGP,MAAA,OAAO,WAAW,OAAO,QAC7B;AACW,WAAA;EAAA;AAGX,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GACrC;AACQ,QAAA,OAAO,CAAO,MAAA,OAAO,CACzB,GAAA;AACW,aAAA;IAAA;EACX;AAGG,SAAA;AACX;AASA,SAA4B,mBAAA,QAA6B,QAA6B,aAAwC;AAC1H,aAAW,QAAQ,aAAa;AAC5B,QAAI,MAAM,QAAQ,OAAO,IAAA,CAAK,GAAG;AACtB,aAAA,IAAA,IAAQ,OAAO,IAAA,EAAM,MAAM;IAAA,OAC/B;AACH,aAAO,IAAA,IAAQ,OAAO,IAAA;IAAA;EAC1B;AAER;IA5xBM,qBAwBO,YAAA;;;;;AAxBb,IAAM,sBAAsB;MACxB;MACA;MACA;MACA;MACA;MACA;IACJ;AAiBO,IAAM,aAAN,MACP;MAsJI,YAAY,OACZ;AACI,aAAK,UAAU;AAEf,aAAK,MAAM;AAEQ,2BAAA,MAAM,OAAO,KAAK;MAAA;MASzC,QACA;AACI,cAAM,mBAAwC,CAAA;AAE3B,2BAAA,kBAAkB,MAAM,WAAU,YAAY;AAE1D,eAAA,IAAI,WAAU,gBAAgB;MAAA;MAIzC,QACA;AACI,2BAAmB,MAAM,WAAU,cAAc,WAAU,YAAY;MAAA;MAQ3E,IAAI,QACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,MAAM,OACV;AACQ,YAAA,KAAK,WAAW,OACpB;AACI,eAAK,SAAS;AACT,eAAA;QAAA;MACT;MAIJ,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,WAAW,YACf;AACQ,YAAA,KAAK,gBAAgB,YACzB;AACI,eAAK,cAAc;AACd,eAAA;QAAA;MACT;MAIJ,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,WAAW,YACf;AACQ,YAAA,KAAK,gBAAgB,YACzB;AACI,eAAK,cAAc;AACd,eAAA;QAAA;MACT;MAIJ,IAAI,kBACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,gBAAgB,iBACpB;AACQ,YAAA,KAAK,qBAAqB,iBAC9B;AACI,eAAK,mBAAmB;AACnB,eAAA;QAAA;MACT;MAIJ,IAAI,kBACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,gBAAgB,iBACpB;AACQ,YAAA,KAAK,qBAAqB,iBAC9B;AACI,eAAK,mBAAmB;AACnB,eAAA;QAAA;MACT;MAIJ,IAAI,iBACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,eAAe,gBACnB;AACQ,YAAA,KAAK,oBAAoB,gBAC7B;AACI,eAAK,kBAAkB;AAClB,eAAA;QAAA;MACT;MAIJ,IAAI,kBACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,gBAAgB,iBACpB;AACU,cAAA,cAAc,SAAS,eAAe;AACxC,YAAA,KAAK,qBAAqB,aAC9B;AACI,eAAK,mBAAmB;AACnB,eAAA;QAAA;MACT;MAIJ,IAAI,qBACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,mBAAmB,oBACvB;AACQ,YAAA,KAAK,wBAAwB,oBACjC;AACI,eAAK,sBAAsB;AACtB,eAAA;QAAA;MACT;MAWJ,IAAI,OACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,KAAK,MACT;AAMU,cAAA,cAAc,SAAS,IAAW;AACpC,YAAA,KAAK,UAAU,aACnB;AACI,eAAK,QAAQ;AACR,eAAA;QAAA;MACT;MAQJ,IAAI,mBACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,iBAAiB,kBACrB;AACQ,YAAA,KAAK,sBAAsB,kBAC/B;AACI,eAAK,oBAAoB;AACpB,eAAA;QAAA;MACT;MAOJ,IAAI,oBACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,kBAAkB,mBACtB;AACI,YAAI,CAAC,eAAe,KAAK,oBAAmB,iBAAiB,GAC7D;AACI,eAAK,qBAAqB;AACrB,eAAA;QAAA;MACT;MAOJ,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,WAAW,YACf;AACQ,YAAA,KAAK,eAAe,YACxB;AACI,eAAK,cAAc;AACd,eAAA;QAAA;MACT;MAOJ,IAAI,WACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,SAAS,UACb;AACQ,YAAA,KAAK,cAAc,UACvB;AACI,eAAK,YAAY;AACZ,eAAA;QAAA;MACT;MAQJ,IAAI,YACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,UAAU,WACd;AACQ,YAAA,KAAK,eAAe,WACxB;AACI,eAAK,aAAa;AACb,eAAA;QAAA;MACT;MAQJ,IAAI,cACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,YAAY,aAChB;AACQ,YAAA,KAAK,iBAAiB,aAC1B;AACI,eAAK,eAAe;AACf,eAAA;QAAA;MACT;MAQJ,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,WAAW,YACf;AACQ,YAAA,KAAK,gBAAgB,YACzB;AACI,eAAK,cAAc;AACd,eAAA;QAAA;MACT;MAIJ,IAAI,gBACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,cAAc,eAClB;AACQ,YAAA,KAAK,mBAAmB,eAC5B;AACI,eAAK,iBAAiB;AACjB,eAAA;QAAA;MACT;MAIJ,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,WAAW,YACf;AACQ,YAAA,KAAK,gBAAgB,YACzB;AACI,eAAK,cAAc;AACd,eAAA;QAAA;MACT;MAIJ,IAAI,UACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,QAAQ,SACZ;AACQ,YAAA,KAAK,aAAa,SACtB;AACI,eAAK,WAAW;AACX,eAAA;QAAA;MACT;MASJ,IAAI,WACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,SAAS,UACb;AACQ,YAAA,KAAK,cAAc,UACvB;AACI,eAAK,YAAY;AACZ,eAAA;QAAA;MACT;MAQJ,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,WAAW,YACf;AACQ,YAAA,KAAK,gBAAgB,YACzB;AACI,eAAK,cAAc;AACd,eAAA;QAAA;MACT;MAOJ,IAAI,UACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,QAAQ,SACZ;AACQ,YAAA,KAAK,aAAa,SACtB;AACI,eAAK,WAAW;AACX,eAAA;QAAA;MACT;MAMJ,IAAI,SACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,OAAO,QACX;AAIU,cAAA,cAAc,SAAS,MAAM;AAC/B,YAAA,KAAK,YAAY,aACrB;AACI,eAAK,UAAU;AACV,eAAA;QAAA;MACT;MAQJ,IAAI,kBACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,gBAAgB,iBACpB;AACQ,YAAA,KAAK,qBAAqB,iBAC9B;AACI,eAAK,mBAAmB;AACnB,eAAA;QAAA;MACT;MAQJ,IAAI,eACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,aAAa,cACjB;AACQ,YAAA,KAAK,kBAAkB,cAC3B;AACI,eAAK,gBAAgB;AAChB,eAAA;QAAA;MACT;MAIJ,IAAI,OACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,KAAK,MACT;AACQ,YAAA,KAAK,UAAU,MACnB;AACI,eAAK,QAAQ;AACR,eAAA;QAAA;MACT;MAeJ,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,WAAW,YACf;AACQ,YAAA,KAAK,gBAAgB,YACzB;AACI,eAAK,cAAc;AACd,eAAA;QAAA;MACT;MAIJ,IAAI,WACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,SAAS,UACb;AACQ,YAAA,KAAK,cAAc,UACvB;AACI,eAAK,YAAY;AACZ,eAAA;QAAA;MACT;MAIJ,IAAI,gBACJ;AACI,eAAO,KAAK;MAAA;MAEhB,IAAI,cAAc,eAClB;AACQ,YAAA,KAAK,mBAAmB,eAC5B;AACI,eAAK,iBAAiB;AACjB,eAAA;QAAA;MACT;MAQJ,eACA;AAEU,cAAA,iBAAkB,OAAO,KAAK,aAAa,WAAY,GAAG,KAAK,QAAA,OAAe,KAAK;AAIzF,YAAI,eAAgC,KAAK;AAEzC,YAAI,CAAC,MAAM,QAAQ,KAAK,UAAU,GAClC;AACmB,yBAAA,KAAK,WAAW,MAAM,GAAG;QAAA;AAG5C,iBAAS,IAAI,aAAa,SAAS,GAAG,KAAK,GAAG,KAC9C;AAEQ,cAAA,aAAa,aAAa,CAAA,EAAG,KAAK;AAGlC,cAAA,CAAE,qBAAsB,KAAK,UAAU,KAAK,CAAC,oBAAoB,SAAS,UAAU,GACxF;AACI,yBAAa,IAAI,UAAA;UAAA;AAEpB,uBAA0B,CAAK,IAAA;QAAA;AAG7B,eAAA,GAAG,KAAK,SAAA,IAAa,KAAK,WAAA,IAAe,KAAK,UAAc,IAAA,cAAA,IAAmB,aAA0B,KAAK,GAAG,CAAA;MAAA;IAEhI;AA7rBO,IAAM,YAAN;AAAM,cAMK,eAA2B;MAKrC,OAAO;MAEP,YAAY;MAEZ,YAAY;MAEZ,iBAAiB;MAMjB,iBAAiB,KAAK,KAAK;MAE3B,gBAAgB;MAKhB,iBAAiB;MAEjB,oBAAoB;MAKpB,MAAM;MAMN,kBAAkB,cAAc;MAMhC,mBAAmB,CAAA;MAKnB,YAAY;MAKZ,UAAU;MAKV,WAAW;MAKX,aAAa;MAKb,YAAY;MAEZ,SAAS;MAET,eAAe;MAEf,YAAY;MAKZ,UAAU;MAEV,YAAY;MAEZ,SAAS;MAKT,QAAQ;MAER,iBAAiB;MAKjB,cAAc;MAEd,MAAM;MAKN,YAAY;MAEZ,UAAU;MAEV,eAAe;IACnB;;;;;IChQE,uBAiCO,OAAA;;;;;;;;AAjCb,IAAM,wBAAyC;MAC3C,SAAS;MACT,UAAU;MACV,aAAa;IACjB;AA6BO,IAAM,QAAN,cAAmB,OAC1B;MAkGI,YAAY,MAAwB,OAAyC,QAC7E;AACI,YAAI,YAAY;AAEhB,YAAI,CAAC,QACL;AACa,mBAAA,SAAS,QAAQ,aAAa;AAC3B,sBAAA;QAAA;AAGhB,eAAO,QAAQ;AACf,eAAO,SAAS;AAEV,cAAA,UAAU,QAAQ,KAAK,MAAM;AAE3B,gBAAA,OAAO,IAAI,UAAU;AACrB,gBAAA,OAAO,IAAI,UAAU;AAE7B,cAAM,OAAO;AAEb,aAAK,aAAa;AAClB,aAAK,SAAS;AACT,aAAA,UAAU,OAAO,WAAW,MAAM;UAEnC,oBAAoB;QAAA,CACvB;AAEI,aAAA,cAAc,MAAK,qBAAqB,SAAS;AACtD,aAAK,kBAAkB,MAAK;AAC5B,aAAK,QAAQ;AACb,aAAK,SAAS;AACd,aAAK,iBAAiB;AACtB,aAAK,QAAQ;AAEb,aAAK,OAAO;AACZ,aAAK,QAAQ;AAEb,aAAK,eAAe;MAAA;MAxGxB,WAAkB,4BAClB;AACI,eAAO,YAAY;MAAA;MAEvB,WAAkB,0BAA0B,OAC5C;AAEU,oBAAA,YAAY,SACd,yFAAyF;AAG7F,oBAAY,4BAA4B;MAAA;MAwGrC,WAAW,cAClB;AACI,cAAM,QAAQ,KAAK;AAGf,YAAA,KAAK,iBAAiB,MAAM,SAChC;AACI,eAAK,QAAQ;AACb,eAAK,eAAe,MAAM;QAAA;AAG1B,YAAA,CAAC,KAAK,SAAS,cACnB;AACI;QAAA;AAGC,aAAA,QAAQ,KAAK,OAAO,aAAa;AAEtC,cAAM,UAAU,KAAK;AACrB,cAAM,WAAW,YAAY,YAAY,KAAK,SAAS,KAAK,KAAK,QAAQ,KAAK,OAAO,UAAU,KAAK,MAAM;AAC1G,cAAM,QAAQ,SAAS;AACvB,cAAM,SAAS,SAAS;AACxB,cAAM,QAAQ,SAAS;AACvB,cAAM,aAAa,SAAS;AAC5B,cAAM,aAAa,SAAS;AAC5B,cAAM,eAAe,SAAS;AAC9B,cAAM,iBAAiB,SAAS;AAEhC,aAAK,OAAO,QAAQ,KAAK,KAAK,KAAK,KAAM,KAAK,IAAI,GAAG,KAAK,IAAK,MAAM,UAAU,CAAG,IAAI,KAAK,WAAW;AACtG,aAAK,OAAO,SAAS,KAAK,KAAK,KAAK,KAAM,KAAK,IAAI,GAAG,MAAM,IAAK,MAAM,UAAU,CAAG,IAAI,KAAK,WAAW;AAExG,gBAAQ,MAAM,KAAK,aAAa,KAAK,WAAW;AAExC,gBAAA,UAAU,GAAG,GAAG,KAAK,OAAO,OAAO,KAAK,OAAO,MAAM;AAE7D,gBAAQ,OAAO,KAAK;AACpB,gBAAQ,YAAY,MAAM;AAC1B,gBAAQ,eAAe,MAAM;AAC7B,gBAAQ,WAAW,MAAM;AACzB,gBAAQ,aAAa,MAAM;AAEvB,YAAA;AACA,YAAA;AAGE,cAAA,cAAc,MAAM,aAAa,IAAI;AAa3C,iBAAS,IAAI,GAAG,IAAI,aAAa,EAAE,GACnC;AACU,gBAAA,eAAe,MAAM,cAAc,MAAM;AAE/C,gBAAM,eAAe,eAAe,KAAK,KAAK,KAAK,IAAI,GAAG,MAAM,IAAK,MAAM,UAAU,CAAE,IAAI;AACrF,gBAAA,iBAAiB,eAAe,KAAK;AAE3C,cAAI,cACJ;AAII,oBAAQ,YAAY;AACpB,oBAAQ,cAAc;AAEtB,kBAAM,kBAAkB,MAAM;AACxB,kBAAA,iBAAiB,MAAM,iBAAiB,KAAK;AAC7C,kBAAA,qBAAqB,MAAM,qBAAqB,KAAK;AAEnD,oBAAA,cAAc,MAAM,OACvB,SAAS,eAAe,EACxB,SAAS,MAAM,eAAe,EAC9B,aAAa;AAClB,oBAAQ,aAAa;AACrB,oBAAQ,gBAAgB,KAAK,IAAI,MAAM,eAAe,IAAI;AAC1D,oBAAQ,gBAAiB,KAAK,IAAI,MAAM,eAAe,IAAI,qBAAsB;UAAA,OAGrF;AAEI,oBAAQ,YAAY,KAAK,mBAAmB,OAAO,OAAO,QAAQ;AAIlE,oBAAQ,cAAc,MAAM;AAE5B,oBAAQ,cAAc;AACtB,oBAAQ,aAAa;AACrB,oBAAQ,gBAAgB;AACxB,oBAAQ,gBAAgB;UAAA;AAGxB,cAAA,sBAAmC,aAAA,eAAe,YAAY;AAE9D,cAAA,aAAa,eAAe,WAAW,GAC3C;AACyB,iCAAA;UAAA;AAIzB,mBAAS,KAAI,GAAG,KAAI,MAAM,QAAQ,MAClC;AACI,4BAAgB,MAAM,kBAAkB;AACxC,4BAAkB,MAAM,kBAAkB,IAAM,KAAI,aAAe,eAAe,SAC5E;AAEF,gBAAA,MAAM,UAAU,SACpB;AACI,+BAAiB,eAAe,WAAW,EAAA;YAAA,WAEtC,MAAM,UAAU,UACzB;AACsB,gCAAA,eAAe,WAAW,EAAM,KAAA;YAAA;AAGlD,gBAAA,MAAM,UAAU,MAAM,iBAC1B;AACS,mBAAA,kBACD,MAAM,EAAA,GACN,gBAAgB,MAAM,SACtB,gBAAgB,MAAM,UAAU,cAChC,IACJ;YAAA;AAGJ,gBAAI,MAAM,MACV;AACS,mBAAA,kBACD,MAAM,EACN,GAAA,gBAAgB,MAAM,SACtB,gBAAgB,MAAM,UAAU,YACpC;YAAA;UACJ;QACJ;AAGJ,aAAK,cAAc;MAAA;MAWvB,kBAA0B,MAAc,GAAW,GAAW,WAAW,OACzE;AACI,cAAM,QAAQ,KAAK;AAGnB,cAAM,gBAAgB,MAAM;AAE5B,YAAI,+BAA+B;AAEnC,YAAI,YAAY,oCAChB;AACI,cAAI,YAAY,2BAChB;AACS,iBAAA,QAAQ,gBAAgB,GAAG,aAAA;AAC3B,iBAAA,QAAQ,oBAAoB,GAAG,aAAA;AACL,2CAAA;UAAA,OAGnC;AACI,iBAAK,QAAQ,gBAAgB;AAC7B,iBAAK,QAAQ,oBAAoB;UAAA;QACrC;AAGA,YAAA,kBAAkB,KAAK,8BAC3B;AACI,cAAI,UACJ;AACI,iBAAK,QAAQ,WAAW,MAAM,GAAG,CAAC;UAAA,OAGtC;AACI,iBAAK,QAAQ,SAAS,MAAM,GAAG,CAAC;UAAA;AAGpC;QAAA;AAGJ,YAAI,kBAAkB;AAEhB,cAAA,cAAc,YAAY,kBAAkB,IAAI;AACtD,YAAI,gBAAgB,KAAK,QAAQ,YAAY,IAAI,EAAE;AACnD,YAAI,eAAe;AAEnB,iBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,EAAE,GAC1C;AACI,gBAAM,cAAc,YAAY,CAAA;AAEhC,cAAI,UACJ;AACI,iBAAK,QAAQ,WAAW,aAAa,iBAAiB,CAAC;UAAA,OAG3D;AACI,iBAAK,QAAQ,SAAS,aAAa,iBAAiB,CAAC;UAAA;AAEzD,cAAI,UAAU;AAEd,mBAAS,IAAI,IAAI,GAAG,IAAI,YAAY,QAAQ,EAAE,GAC9C;AACI,uBAAW,YAAY,CAAA;UAAA;AAE3B,yBAAe,KAAK,QAAQ,YAAY,OAAO,EAAE;AACjD,6BAAmB,gBAAgB,eAAe;AAClC,0BAAA;QAAA;MACpB;MAIJ,gBACA;AACI,cAAM,SAAS,KAAK;AAEhB,YAAA,KAAK,OAAO,MAChB;AACU,gBAAA,UAAU,YAAM,WAAW,MAAM;AAEvC,cAAI,QAAQ,MACZ;AACI,mBAAO,QAAQ,QAAQ;AACvB,mBAAO,SAAS,QAAQ;AACxB,iBAAK,QAAQ,aAAa,QAAQ,MAAM,GAAG,CAAC;UAAA;QAChD;AAGJ,cAAM,UAAU,KAAK;AACrB,cAAM,QAAQ,KAAK;AACnB,cAAM,UAAU,MAAM,OAAO,IAAI,MAAM;AACvC,cAAM,cAAc,QAAQ;AAE5B,gBAAQ,KAAK,QAAQ,QAAQ,OAAO,QAAQ,OAAO,QAAQ,KAAK;AAChE,gBAAQ,KAAK,SAAS,QAAQ,OAAO,SAAS,OAAO,SAAS,KAAK;AAC3D,gBAAA,KAAK,IAAI,CAAC;AACV,gBAAA,KAAK,IAAI,CAAC;AAElB,gBAAQ,KAAK,QAAQ,QAAQ,OAAO,QAAS,UAAU;AACvD,gBAAQ,KAAK,SAAS,QAAQ,OAAO,SAAU,UAAU;AAGzD,aAAK,iBAAiB;AAEtB,oBAAY,YAAY,OAAO,OAAO,OAAO,QAAQ,KAAK,WAAW;AAErE,gBAAQ,UAAU;AAElB,aAAK,QAAQ;MAAA;MAOP,QAAQ,UAClB;AACI,YAAI,KAAK,mBAAmB,KAAK,gBAAgB,SAAS,YAC1D;AACI,eAAK,cAAc,SAAS;AAC5B,eAAK,QAAQ;QAAA;AAGjB,aAAK,WAAW,IAAI;AAEpB,cAAM,QAAQ,QAAQ;MAAA;MAI1B,kBACA;AACI,aAAK,WAAW,IAAI;AAEpB,cAAM,gBAAgB;MAAA;MAGnB,UAAU,YAAsB,MACvC;AACI,aAAK,WAAW,IAAI;AAEhB,YAAA,KAAK,eAAe,IACxB;AAEiB,uBAAA;QAAA;AAGV,eAAA,MAAM,UAAU,YAAY,IAAI;MAAA;MAQpC,eAAe,MACtB;AACI,aAAK,WAAW,IAAI;AAEpB,eAAO,MAAM,eAAe,KAAK,MAAM,IAAI;MAAA;MAI/C,mBACA;AACI,aAAK,kBAAkB;AAElB,aAAA,QAAQ,QAAQ,KAAK,UAAU;MAAA;MAUxC,mBACI,OAAkB,OAAiB,SAEvC;AAII,cAAM,YAAgE,MAAM;AAE5E,YAAI,CAAC,MAAM,QAAQ,SAAS,GAC5B;AACW,iBAAA;QAAA,WAEF,UAAU,WAAW,GAC9B;AACI,iBAAO,UAAU,CAAA;QAAA;AAKjB,YAAA;AAIJ,cAAM,uBAAwB,MAAM,aAAc,MAAM,qBAAqB;AAGvE,cAAA,UAAU,MAAM,WAAW;AAEjC,cAAM,QAAS,KAAK,OAAO,QAAQ,KAAK,cAAe,uBAAwB,UAAU;AACzF,cAAM,SAAU,KAAK,OAAO,SAAS,KAAK,cAAe,uBAAwB,UAAU;AAGrF,cAAA,OAAO,UAAU,MAAM;AACvB,cAAA,oBAAoB,MAAM,kBAAkB,MAAM;AAGpD,YAAA,CAAC,kBAAkB,QACvB;AACU,gBAAA,cAAc,KAAK,SAAS;AAElC,mBAAS,IAAI,GAAG,IAAI,aAAa,EAAE,GACnC;AACsB,8BAAA,KAAK,IAAI,WAAW;UAAA;QAC1C;AAKC,aAAA,QAAQ,UAAU,CAAE,CAAA;AACzB,0BAAkB,QAAQ,CAAC;AAE3B,aAAK,KAAK,UAAU,UAAU,SAAS,CAAE,CAAA;AACzC,0BAAkB,KAAK,CAAC;AAEpB,YAAA,MAAM,qBAAqB,cAAc,iBAC7C;AAEe,qBAAA,KAAK,QAAQ,qBAAqB,QAAQ,GAAG,SAAS,QAAQ,GAAG,SAAS,OAAO;AAM5F,gBAAM,aAAa,QAAQ,eAAe,WAAW,MAAM;AAE3D,mBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAClC;AACI,kBAAM,iBAAkB,QAAQ,cAAc,IAAI,KAAM;AAClD,kBAAA,cAAc,QAAQ,aAAa;AACzC,gBAAI,wBAAwB;AAGxB,gBAAA,IAAI,KAAK,iBAAiB,aAC9B;AACI,uCAAyB,cAAc,kBAAkB;YAAA;AAG7D,kBAAM,iBAAiB,cAAc;AAC/B,kBAAA,cAAc,QAAQ,cAAkB,IAAA;AAC9C,gBAAI,sBAAsB;AAG1B,gBAAI,IAAI,IAAI,MAAM,UAAU,cAAc,gBAC1C;AACI,qCAAuB,iBAAiB,eAAe;YAAA;AAIrD,kBAAA,sBAAsB,sBAAsB,yBAAyB;AAE3E,qBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KACjC;AAEI,kBAAI,WAAW;AAEX,kBAAA,OAAO,kBAAkB,CAAA,MAAO,UACpC;AACI,2BAAW,kBAAkB,CAAA;cAAA,OAGjC;AACI,2BAAW,IAAI,KAAK;cAAA;AAGpB,kBAAA,aAAa,KAAK,IAAI,GAAG,KAAK,IAAI,GACjC,wBAAwB,SAAW,WAAW,kBAAmB,CAAC;AAGvE,2BAAa,OAAO,WAAW,QAAQ,CAAC,CAAC;AAChC,uBAAA,aAAa,YAAY,KAAK,CAAE,CAAA;YAAA;UAC7C;QACJ,OAGJ;AAEe,qBAAA,KAAK,QAAQ,qBAAqB,SAAS,SAAS,GAAG,QAAQ,SAAS,SAAS,CAAC;AAIvF,gBAAA,kBAAkB,KAAK,SAAS;AACtC,cAAI,mBAAmB;AAEvB,mBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KACjC;AACQ,gBAAA;AAEA,gBAAA,OAAO,kBAAkB,CAAA,MAAO,UACpC;AACI,qBAAO,kBAAkB,CAAA;YAAA,OAG7B;AACI,qBAAO,mBAAmB;YAAA;AAErB,qBAAA,aAAa,MAAM,KAAK,CAAE,CAAA;AACnC;UAAA;QACJ;AAGG,eAAA;MAAA;MAeJ,QAAQ,SACf;AACQ,YAAA,OAAO,YAAY,WACvB;AACc,oBAAA,EAAE,UAAU,QAAQ;QAAA;AAGlC,kBAAU,OAAO,OAAO,CAAA,GAAI,uBAAuB,OAAO;AAE1D,cAAM,QAAQ,OAAO;AAIrB,YAAI,KAAK,YACT;AACI,eAAK,OAAO,SAAS,KAAK,OAAO,QAAQ;QAAA;AAI7C,aAAK,UAAU;AACf,aAAK,SAAS;AAEd,aAAK,SAAS;MAAA;MAIlB,IAAI,QACJ;AACI,aAAK,WAAW,IAAI;AAEb,eAAA,KAAK,IAAI,KAAK,MAAM,CAAC,IAAI,KAAK,SAAS,KAAK;MAAA;MAGvD,IAAI,MAAM,OACV;AACI,aAAK,WAAW,IAAI;AAEpB,cAAM,IAAI,YAAM,KAAK,KAAK,MAAM,CAAC,KAAK;AAEtC,aAAK,MAAM,IAAI,IAAI,QAAQ,KAAK,SAAS,KAAK;AAC9C,aAAK,SAAS;MAAA;MAIlB,IAAI,SACJ;AACI,aAAK,WAAW,IAAI;AAEb,eAAA,KAAK,IAAI,KAAK,MAAM,CAAC,IAAI,KAAK,SAAS,KAAK;MAAA;MAGvD,IAAI,OAAO,OACX;AACI,aAAK,WAAW,IAAI;AAEpB,cAAM,IAAI,YAAM,KAAK,KAAK,MAAM,CAAC,KAAK;AAEtC,aAAK,MAAM,IAAI,IAAI,QAAQ,KAAK,SAAS,KAAK;AAC9C,aAAK,UAAU;MAAA;MAUnB,IAAI,QACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,MAAM,OACV;AACI,gBAAQ,SAAS,CAAA;AAEjB,YAAI,iBAAiB,WACrB;AACI,eAAK,SAAS;QAAA,OAGlB;AACS,eAAA,SAAS,IAAI,UAAU,KAAK;QAAA;AAGrC,aAAK,eAAe;AACpB,aAAK,QAAQ;MAAA;MAIjB,IAAI,OACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,KAAK,MACT;AACI,eAAO,OAAO,SAAS,QAAQ,SAAS,SAAY,KAAK,IAAI;AAEzD,YAAA,KAAK,UAAU,MACnB;AACI;QAAA;AAEJ,aAAK,QAAQ;AACb,aAAK,QAAQ;MAAA;MASjB,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,WAAW,OACf;AACI,aAAK,kBAAkB;AAEnB,YAAA,KAAK,gBAAgB,OACzB;AACI;QAAA;AAGJ,aAAK,cAAc;AACnB,aAAK,QAAQ;MAAA;IAErB;AA1vBO,IAAM,OAAN;AAAM,SAcK,wBAAwB;;;;;AC1D1C,IAAAC,YAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;;;ACGO,IAAM;AAAN;;IAAM,iBAAN,MACP;MAmBI,cACA;AACI,aAAK,OAAO,CAAA;AACZ,aAAK,SAAS,CAAA;AACd,aAAK,OAAO,CAAA;AACZ,aAAK,OAAO,CAAA;AACZ,aAAK,UAAU,CAAA;AACf,aAAK,gBAAgB,CAAA;MAAC;IAE9B;;;;;ICca;;;;AAAN,IAAM,aAAN,MACP;MAMI,OAAO,KAAK,MACZ;AACI,eAAO,OAAO,SAAS,YAAY,KAAK,WAAW,YAAY;MAAA;MAQnE,OAAO,MAAM,KACb;AAEU,cAAA,QAAQ,IAAI,MAAM,iBAAiB;AACzC,cAAM,UAA8B;UAChC,MAAM,CAAA;UACN,QAAQ,CAAA;UACR,MAAM,CAAA;UACN,MAAM,CAAA;UACN,OAAO,CAAA;UACP,SAAS,CAAA;UACT,UAAU,CAAA;UACV,eAAe,CAAA;QAAC;AAGpB,mBAAW,KAAK,OAChB;AAEI,gBAAM,OAAO,MAAM,CAAG,EAAA,MAAM,WAAW,EAAE,CAAA;AAGzC,gBAAM,gBAAgB,MAAM,CAAG,EAAA,MAAM,kCAAkC;AAGvE,gBAAM,WAAgB,CAAA;AAEtB,qBAAW,MAAK,eAChB;AAEI,kBAAM,QAAQ,cAAc,EAAG,EAAA,MAAM,GAAG;AACxC,kBAAM,MAAM,MAAM,CAAA;AAGlB,kBAAM,WAAW,MAAM,CAAG,EAAA,QAAQ,OAAO,EAAE;AAGrC,kBAAA,aAAa,WAAW,QAAQ;AAGtC,kBAAM,QAAQ,MAAM,UAAU,IAAI,WAAW;AAE7C,qBAAS,GAAO,IAAA;UAAA;AAIZ,kBAAA,IAAA,EAAM,KAAK,QAAQ;QAAA;AAGzB,cAAA,OAAO,IAAI,eAAe;AAEhC,gBAAQ,KAAK,QAAQ,CAAC,SAAS,KAAK,KAAK,KAAK;UAC1C,MAAM,KAAK;UACX,MAAM,SAAS,KAAK,MAAM,EAAE;QAAA,CAC/B,CAAC;AAEF,gBAAQ,OAAO,QAAQ,CAAC,WAAW,KAAK,OAAO,KAAK;UAChD,YAAY,SAAS,OAAO,YAAY,EAAE;QAAA,CAC7C,CAAC;AAEF,gBAAQ,KAAK,QAAQ,CAAC,SAAS,KAAK,KAAK,KAAK;UAC1C,IAAI,SAAS,KAAK,IAAI,EAAE;UACxB,MAAM,KAAK;QAAA,CACd,CAAC;AAEF,gBAAQ,KAAK,QAAQ,CAAC,SAAS,KAAK,KAAK,KAAK;UAC1C,IAAI,SAAS,KAAK,IAAI,EAAE;UACxB,MAAM,SAAS,KAAK,MAAM,EAAE;UAC5B,GAAG,SAAS,KAAK,GAAG,EAAE;UACtB,GAAG,SAAS,KAAK,GAAG,EAAE;UACtB,OAAO,SAAS,KAAK,OAAO,EAAE;UAC9B,QAAQ,SAAS,KAAK,QAAQ,EAAE;UAChC,SAAS,SAAS,KAAK,SAAS,EAAE;UAClC,SAAS,SAAS,KAAK,SAAS,EAAE;UAClC,UAAU,SAAS,KAAK,UAAU,EAAE;QAAA,CACvC,CAAC;AAEF,gBAAQ,QAAQ,QAAQ,CAAC,YAAY,KAAK,QAAQ,KAAK;UACnD,OAAO,SAAS,QAAQ,OAAO,EAAE;UACjC,QAAQ,SAAS,QAAQ,QAAQ,EAAE;UACnC,QAAQ,SAAS,QAAQ,QAAQ,EAAE;QAAA,CACtC,CAAC;AAEF,gBAAQ,cAAc,QAAQ,CAAC,OAAO,KAAK,cAAc,KAAK;UAC1D,eAAe,SAAS,GAAG,eAAe,EAAE;UAC5C,WAAW,GAAG;QAAA,CACjB,CAAC;AAEK,eAAA;MAAA;IAEf;;;;;ICrJa;;;;AAAN,IAAM,YAAN,MACP;MAMI,OAAO,KAAK,MACZ;AACI,cAAM,MAAM;AAEZ,eAAO,0BAA0B,OAC1B,IAAI,qBAAqB,MAAM,EAAE,UACjC,IAAI,qBAAqB,MAAM,EAAE,CAAG,EAAA,aAAa,MAAM,MAAM;MAAA;MAQxE,OAAO,MAAM,KACb;AACU,cAAA,OAAO,IAAI,eAAe;AAC1B,cAAA,OAAO,IAAI,qBAAqB,MAAM;AACtC,cAAA,SAAS,IAAI,qBAAqB,QAAQ;AAC1C,cAAA,OAAO,IAAI,qBAAqB,MAAM;AACtC,cAAA,OAAO,IAAI,qBAAqB,MAAM;AACtC,cAAA,UAAU,IAAI,qBAAqB,SAAS;AAC5C,cAAA,gBAAgB,IAAI,qBAAqB,eAAe;AAE9D,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KACjC;AACI,eAAK,KAAK,KAAK;YACX,MAAM,KAAK,CAAG,EAAA,aAAa,MAAM;YACjC,MAAM,SAAS,KAAK,CAAA,EAAG,aAAa,MAAM,GAAG,EAAE;UAAA,CAClD;QAAA;AAGL,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KACnC;AACI,eAAK,OAAO,KAAK;YACb,YAAY,SAAS,OAAO,CAAA,EAAG,aAAa,YAAY,GAAG,EAAE;UAAA,CAChE;QAAA;AAGL,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KACjC;AACI,eAAK,KAAK,KAAK;YACX,IAAI,SAAS,KAAK,CAAA,EAAG,aAAa,IAAI,GAAG,EAAE,KAAK;YAChD,MAAM,KAAK,CAAG,EAAA,aAAa,MAAM;UAAA,CACpC;QAAA;AAGL,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KACjC;AACI,gBAAM,SAAS,KAAK,CAAA;AAEpB,eAAK,KAAK,KAAK;YACX,IAAI,SAAS,OAAO,aAAa,IAAI,GAAG,EAAE;YAC1C,MAAM,SAAS,OAAO,aAAa,MAAM,GAAG,EAAE,KAAK;YACnD,GAAG,SAAS,OAAO,aAAa,GAAG,GAAG,EAAE;YACxC,GAAG,SAAS,OAAO,aAAa,GAAG,GAAG,EAAE;YACxC,OAAO,SAAS,OAAO,aAAa,OAAO,GAAG,EAAE;YAChD,QAAQ,SAAS,OAAO,aAAa,QAAQ,GAAG,EAAE;YAClD,SAAS,SAAS,OAAO,aAAa,SAAS,GAAG,EAAE;YACpD,SAAS,SAAS,OAAO,aAAa,SAAS,GAAG,EAAE;YACpD,UAAU,SAAS,OAAO,aAAa,UAAU,GAAG,EAAE;UAAA,CACzD;QAAA;AAGL,iBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KACpC;AACI,eAAK,QAAQ,KAAK;YACd,OAAO,SAAS,QAAQ,CAAA,EAAG,aAAa,OAAO,GAAG,EAAE;YACpD,QAAQ,SAAS,QAAQ,CAAA,EAAG,aAAa,QAAQ,GAAG,EAAE;YACtD,QAAQ,SAAS,QAAQ,CAAA,EAAG,aAAa,QAAQ,GAAG,EAAE;UAAA,CACzD;QAAA;AAGL,iBAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAC1C;AACI,eAAK,cAAc,KAAK;YACpB,WAAW,cAAc,CAAG,EAAA,aAAa,WAAW;YACpD,eAAe,SAAS,cAAc,CAAA,EAAG,aAAa,eAAe,GAAG,EAAE;UAAA,CAC7E;QAAA;AAGE,eAAA;MAAA;IAEf;;;;;ICvFa;;;;;AAAN,IAAM,kBAAN,MACP;MAMI,OAAO,KAAK,MACZ;AACI,YAAI,OAAO,SAAS,YAAY,KAAK,SAAS,QAAQ,GACtD;AACI,iBAAO,UAAU,KAAK,SAAS,QAAQ,SAAS,IAAI,CAAC;QAAA;AAGlD,eAAA;MAAA;MAQX,OAAO,MAAM,QACb;AACI,eAAO,UAAU,MAAM,SAAS,QAAQ,SAAS,MAAM,CAAC;MAAA;IAEhE;;;;;AClBO,SAAA,iBAA0B,MACjC;AACI,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KACpC;AACI,QAAI,QAAQ,CAAA,EAAG,KAAK,IAAI,GACxB;AACI,aAAO,QAAQ,CAAA;IAAA;EACnB;AAGG,SAAA;AACX;IAvBM;;;;;;;;;AAAN,IAAM,UAAU;MACZ;MACA;MACA;IACJ;;;;;ACSO,SAAA,kBACH,QACA,SACA,OACA,YACA,OACA,SAEJ;AAII,QAAM,YAAgE,MAAM;AAE5E,MAAI,CAAC,MAAM,QAAQ,SAAS,GAC5B;AACW,WAAA;EAAA,WAEF,UAAU,WAAW,GAC9B;AACI,WAAO,UAAU,CAAA;EAAA;AAKjB,MAAA;AAIJ,QAAM,uBAAwB,MAAM,aAAc,MAAM,qBAAqB;AAGvE,QAAA,UAAU,MAAM,WAAW;AAEjC,QAAM,QAAS,OAAO,QAAQ,aAAc,uBAAwB,UAAU;AAC9E,QAAM,SAAU,OAAO,SAAS,aAAc,uBAAwB,UAAU;AAG1E,QAAA,OAAO,UAAU,MAAM;AACvB,QAAA,oBAAoB,MAAM,kBAAkB,MAAM;AAGpD,MAAA,CAAC,kBAAkB,QACvB;AACU,UAAA,cAAc,KAAK,SAAS;AAElC,aAAS,IAAI,GAAG,IAAI,aAAa,EAAE,GACnC;AACsB,wBAAA,KAAK,IAAI,WAAW;IAAA;EAC1C;AAKC,OAAA,QAAQ,UAAU,CAAE,CAAA;AACzB,oBAAkB,QAAQ,CAAC;AAE3B,OAAK,KAAK,UAAU,UAAU,SAAS,CAAE,CAAA;AACzC,oBAAkB,KAAK,CAAC;AAEpB,MAAA,MAAM,qBAAqB,cAAc,iBAC7C;AAEe,eAAA,QAAQ,qBAAqB,QAAQ,GAAG,SAAS,QAAQ,GAAG,SAAS,OAAO;AASvF,QAAI,oBAAoB;AAGxB,UAAM,aAAa,QAAQ,eAAe,WAAW,MAAM;AAG3D,UAAM,qBAAqB,aAAa;AAExC,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAClC;AACU,YAAA,cAAc,QAAQ,aAAa;AAEzC,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KACjC;AAEI,YAAI,WAAW;AAEX,YAAA,OAAO,kBAAkB,CAAA,MAAO,UACpC;AACI,qBAAW,kBAAkB,CAAA;QAAA,OAGjC;AACI,qBAAW,IAAI,KAAK;QAAA;AAGlB,cAAA,aAAc,cAAc,SAAW,WAAW;AAGxD,YAAI,cAAc,KAAK,IAAI,mBAAmB,UAAU;AAE1C,sBAAA,KAAK,IAAI,aAAa,CAAC;AAC5B,iBAAA,aAAa,aAAa,KAAK,CAAE,CAAA;AACtB,4BAAA;MAAA;IACxB;EACJ,OAGJ;AAEe,eAAA,QAAQ,qBAAqB,SAAS,SAAS,GAAG,QAAQ,SAAS,SAAS,CAAC;AAIlF,UAAA,kBAAkB,KAAK,SAAS;AACtC,QAAI,mBAAmB;AAEvB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KACjC;AACQ,UAAA;AAEA,UAAA,OAAO,kBAAkB,CAAA,MAAO,UACpC;AACI,eAAO,kBAAkB,CAAA;MAAA,OAG7B;AACI,eAAO,mBAAmB;MAAA;AAErB,eAAA,aAAa,MAAM,KAAK,CAAE,CAAA;AACnC;IAAA;EACJ;AAGG,SAAA;AACX;;;;;;;;ACtIO,SAAA,UACH,QACA,SACA,SACA,GACA,GACA,YACA,OAEJ;AACI,QAAM,OAAO,QAAQ;AACrB,QAAM,iBAAiB,QAAQ;AAEvB,UAAA,UAAU,GAAG,CAAC;AACd,UAAA,MAAM,YAAY,UAAU;AAE9B,QAAA,KAAK,MAAM,kBAAkB;AAC7B,QAAA,KAAK,EAAE,MAAM,kBAAkB;AAE7B,UAAA,OAAO,MAAM,aAAa;AAClC,UAAQ,YAAY,MAAM;AAC1B,UAAQ,eAAe,MAAM;AAC7B,UAAQ,WAAW,MAAM;AACzB,UAAQ,aAAa,MAAM;AAGnB,UAAA,YAAY,kBAAkB,QAAQ,SAAS,OAAO,YAAY,CAAC,IAAI,GAAG,OAAO;AACzF,UAAQ,cAAc,MAAM;AAE5B,MAAI,MAAM,YACV;AACI,UAAM,kBAAkB,MAAM;AACxB,UAAA,iBAAiB,MAAM,iBAAiB;AACxC,UAAA,qBAAqB,MAAM,qBAAqB;AAE9C,YAAA,cAAc,MAAM,OACvB,SAAS,eAAe,EACxB,SAAS,MAAM,eAAe,EAC9B,aAAa;AAClB,YAAQ,aAAa;AACrB,YAAQ,gBAAgB,KAAK,IAAI,MAAM,eAAe,IAAI;AAC1D,YAAQ,gBAAgB,KAAK,IAAI,MAAM,eAAe,IAAI;EAAA,OAG9D;AACI,YAAQ,cAAc;AACtB,YAAQ,aAAa;AACrB,YAAQ,gBAAgB;AACxB,YAAQ,gBAAgB;EAAA;AAGxB,MAAA,MAAM,UAAU,MAAM,iBAC1B;AACI,YAAQ,WAAW,MAAM,IAAI,KAAK,QAAQ,aAAa,eAAe,OAAO;EAAA;AAEjF,MAAI,MAAM,MACV;AACI,YAAQ,SAAS,MAAM,IAAI,KAAK,QAAQ,aAAa,eAAe,OAAO;EAAA;AAG/E,UAAQ,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAErC,UAAQ,YAAY;AACxB;;;;;;;;;AC/EO,SAAA,gBAAyB,KAChC;AACW,SAAA,IAAI,cAAc,IAAI,YAAY,CAAC,IAAI,IAAI,WAAW,CAAC;AAClE;AAHO;;;;;;ACAA,SAAA,sBAA+B,MACtC;AACW,SAAA,MAAM,OAAO,MAAM,KAAK,IAAI,IAAI,KAAK,MAAM,EAAE;AACxD;AAHO;;;;;;ACKA,SAAA,kBAA2B,OAClC;AAEQ,MAAA,OAAO,UAAU,UACrB;AACI,YAAQ,CAAC,KAAK;EAAA;AAIlB,QAAM,SAAmB,CAAA;AAEzB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,KACzC;AACI,UAAM,OAAO,MAAM,CAAA;AAGf,QAAA,MAAM,QAAQ,IAAI,GACtB;AACQ,UAAA,KAAK,WAAW,GACpB;AACI,cAAM,IAAI,MAAM,iEAAiE,KAAK,MAAS,GAAA;MAAA;AAGnG,YAAM,YAAY,KAAK,CAAG,EAAA,WAAW,CAAC;AACtC,YAAM,UAAU,KAAK,CAAG,EAAA,WAAW,CAAC;AAEpC,UAAI,UAAU,WACd;AACU,cAAA,IAAI,MAAM,wCAAwC;MAAA;AAG5D,eAAS,KAAI,WAAW,KAAI,SAAS,MAAK,IAAG,MAC7C;AACI,eAAO,KAAK,OAAO,aAAa,EAAC,CAAC;MAAA;IACtC,OAIJ;AACI,aAAO,KAAK,GAAG,sBAAsB,IAAI,CAAC;IAAA;EAC9C;AAGA,MAAA,OAAO,WAAW,GACtB;AACU,UAAA,IAAI,MAAM,oDAAoD;EAAA;AAGjE,SAAA;AACX;;;;;;;;AC3DA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;ICsFa,aAAA;;;;;;;;;;;AAAN,IAAM,cAAN,MACP;MA8EI,YAAY,MAAsB,UAA2C,cAC7E;;AACU,cAAA,CAAC,IAAA,IAAQ,KAAK;AACd,cAAA,CAAC,MAAA,IAAU,KAAK;AAChB,cAAA,CAAC,IAAA,IAAQ,KAAK;AACd,cAAA,CAAC,aAAA,IAAiB,KAAK;AAC7B,cAAM,MAAM,YAAM,mBAAmB,KAAK,IAAI;AAC9C,cAAM,eAAoC,CAAA;AAE1C,aAAK,gBAAgB;AACrB,aAAK,OAAO,KAAK;AACjB,aAAK,OAAO,KAAK;AACZ,aAAA,aAAa,OAAO,aAAa;AACtC,aAAK,QAAQ,CAAA;AACb,aAAK,eAAe;AAIpB,iBAAS,IAAI,GAAG,IAAI,KAAK,KAAK,QAAQ,KACtC;AACI,gBAAM,EAAE,IAAI,KAAS,IAAA,KAAK,KAAK,CAAA;AAE/B,uBAAa,EAAM,IAAA,oBAAoB,QACjC,SAAS,CAAA,IAAK,SAAS,IAAA;AAG7B,eAAI,+CAAe,cAAa,cAAc,cAAc,QAC5D;AACiB,yBAAA,EAAA,EAAI,YAAY,YAAY,YAAY;AACxC,yBAAA,EAAA,EAAI,YAAY,SAAS,aAAa;UAAA;QACvD;AAIJ,iBAAS,IAAI,GAAG,IAAI,KAAK,KAAK,QAAQ,KACtC;AACI,gBAAM,EAAE,IAAI,MAAS,MAAA,IAAA,KAAK,KAAK,CAAA;AAC3B,cAAA,EAAE,GAAG,GAAG,OAAO,QAAQ,SAAS,SAAS,SAAa,IAAA,KAAK,KAAK,CAAA;AAE/D,eAAA;AACA,eAAA;AACI,mBAAA;AACC,oBAAA;AACC,qBAAA;AACA,qBAAA;AACC,sBAAA;AAEZ,gBAAM,OAAO,IAAI,UACb,IAAK,aAAa,KAAA,EAAM,MAAM,IAAI,KAClC,IAAK,aAAa,KAAM,EAAA,MAAM,IAAI,KAClC,OACA,MACJ;AAEA,eAAK,MAAM,EAAM,IAAA;YACb,SAAS;YACT,SAAS;YACT,UAAU;YACV,SAAS,CAAA;YACT,SAAS,IAAI,QACT,aAAa,KAAA,EAAM,aACnB,IACJ;YACA,MAAA;UAAA;QACJ;AAIJ,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACI,cAAI,EAAE,OAAO,QAAQ,OAAA,IAAW,KAAK,QAAQ,CAAA;AAEpC,mBAAA;AACC,oBAAA;AACA,oBAAA;AAEN,cAAA,KAAK,MAAM,MACf,GAAA;AACS,iBAAA,MAAM,MAAQ,EAAA,QAAQ,KAAS,IAAA;UAAA;QACxC;AAIJ,aAAK,qBAAqB,+CAAe;AACzC,aAAK,sBAAoB,oDAAe,cAAf,mBAA0B,kBAAiB;MAAA;MAIxE,UACA;AACe,mBAAA,MAAM,KAAK,OACtB;AACS,eAAA,MAAM,EAAI,EAAA,QAAQ,QAAQ;AAC1B,eAAA,MAAM,EAAA,EAAI,UAAU;QAAA;AAGlB,mBAAA,MAAM,KAAK,cACtB;AACI,cAAI,KAAK,eACT;AACS,iBAAA,aAAa,EAAI,EAAA,QAAQ,IAAI;UAAA;AAGtC,eAAK,aAAa,EAAM,IAAA;QAAA;AAI3B,aAAa,QAAQ;AACrB,aAAa,eAAe;MAAA;MAcjC,OAAc,QACV,MACA,UACA,cAEJ;AACQ,YAAA;AAEJ,YAAI,gBAAgB,gBACpB;AACe,qBAAA;QAAA,OAGf;AACU,gBAAA,SAAS,iBAAiB,IAAI;AAEpC,cAAI,CAAC,QACL;AACU,kBAAA,IAAI,MAAM,oCAAoC;UAAA;AAG7C,qBAAA,OAAO,MAAM,IAAW;QAAA;AAIvC,YAAI,oBAAoB,SACxB;AACI,qBAAW,CAAC,QAAQ;QAAA;AAGxB,cAAM,OAAO,IAAI,YAAW,UAAU,UAAU,YAAY;AAEjD,oBAAA,UAAU,KAAK,IAAQ,IAAA;AAE3B,eAAA;MAAA;MAOX,OAAc,UAAU,MACxB;AACU,cAAA,OAAO,YAAW,UAAU,IAAA;AAElC,YAAI,CAAC,MACL;AACU,gBAAA,IAAI,MAAM,wBAAwB,IAAO,GAAA;QAAA;AAGnD,aAAK,QAAQ;AACb,eAAO,YAAW,UAAU,IAAA;MAAA;MAwChC,OAAc,KAAK,MAAc,WAA6C,SAC9E;AACI,YAAI,CAAC,MACL;AACU,gBAAA,IAAI,MAAM,2CAA2C;QAAA;AAGzD,cAAA;UACF;UACA;UACA;UACA;UACA;UACG,GAAA;QAAA,IACH,OAAO,OAAO,CAAA,GAAI,YAAW,gBAAgB,OAAO;AAElD,cAAA,YAAY,kBAAkB,KAAK;AACzC,cAAM,QAAQ,qBAAqB,YAAY,YAAY,IAAI,UAAU,SAAS;AAClF,cAAM,YAAY;AACZ,cAAA,WAAW,IAAI,eAAe;AAEpC,iBAAS,KAAK,CAAK,IAAA;UACf,MAAM,MAAM;UACZ,MAAM,MAAM;QAAA;AAEhB,iBAAS,OAAO,CAAK,IAAA;UACjB,YAAY,MAAM;QAAA;AAGtB,YAAI,YAAY;AAChB,YAAI,YAAY;AAEZ,YAAA;AACA,YAAA;AACA,YAAA;AACJ,YAAI,gBAAgB;AACpB,cAAM,eAA8B,CAAA;AACpC,cAAM,WAAsB,CAAA;AAE5B,iBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KACtC;AACI,cAAI,CAAC,QACL;AACa,qBAAA,SAAS,QAAQ,aAAa;AACvC,mBAAO,QAAQ;AACf,mBAAO,SAAS;AAEN,sBAAA,OAAO,WAAW,IAAI;AAChC,0BAAc,IAAI,YAAY,QAAQ,EAAE,YAAY,GAAG,YAAA,CAAa;AAEpE,yBAAa,KAAK,WAAW;AAC7B,qBAAS,KAAK,IAAI,QAAQ,WAAW,CAAC;AAEtC,qBAAS,KAAK,KAAK;cACf,IAAI,SAAS,SAAS;cACtB,MAAM;YAAA,CACT;UAAA;AAIL,gBAAM,YAAY,UAAU,CAAA;AAC5B,gBAAM,UAAU,YAAY,YAAY,WAAW,OAAO,OAAO,MAAM;AACvE,gBAAM,QAAQ,QAAQ;AACtB,gBAAM,SAAS,KAAK,KAAK,QAAQ,MAAM;AAGjC,gBAAA,oBAAoB,KAAK,MAAM,MAAM,cAAc,WAAW,IAAI,KAAK,KAAK;AAG9E,cAAA,aAAa,gBAAiB,SAAS,YAC3C;AACI,gBAAI,cAAc,GAClB;AAEU,oBAAA,IAAI,MAAM,8BAA8B,aAAA,iCACvB,MAAM,UAA0B,gBAAA,MAAM,QAAA,cAAsB,SAAa,IAAA;YAAA;AAGlG,cAAA;AAGO,qBAAA;AACC,sBAAA;AACI,0BAAA;AACF,wBAAA;AACA,wBAAA;AACI,4BAAA;AAEhB;UAAA;AAGJ,0BAAgB,KAAK,IAAI,SAAS,QAAQ,eAAe,SAAS,aAAa;AAG1E,cAAA,oBAAoB,aAAc,aAAa,WACpD;AACI,gBAAI,cAAc,GAClB;AAEU,oBAAA,IAAI,MAAM,6BAA6B,YAAA,iCACtB,MAAM,UAA0B,gBAAA,MAAM,QAAA,cAAsB,SAAa,IAAA;YAAA;AAGlG,cAAA;AACF,yBAAa,gBAAgB;AACjB,wBAAA,KAAK,KAAK,SAAS;AACnB,wBAAA;AACI,4BAAA;AAEhB;UAAA;AAGJ,oBAAU,QAAQ,SAAS,SAAS,WAAW,WAAW,YAAY,KAAK;AAGrE,gBAAA,KAAK,gBAAgB,QAAQ,IAAI;AAGvC,mBAAS,KAAK,KAAK;YACf;YACA,MAAM,SAAS,SAAS;YACxB,GAAG,YAAY;YACf,GAAG,YAAY;YACf,OAAO;YACP;YACA,SAAS;YACT,SAAS;YACT,UAAU,SACC,MAAM,aAAa,MAAM,qBAAqB,MAC9C,MAAM,SAAS,MAAM,kBAAkB;UAAA,CACrD;AAEa,wBAAA,oBAAqB,IAAI,WAAY;AACvC,sBAAA,KAAK,KAAK,SAAS;QAAA;AAKnC,iBAAS,IAAI,GAAG,MAAM,UAAU,QAAQ,IAAI,KAAK,KACjD;AACI,gBAAM,QAAQ,UAAU,CAAA;AAExB,mBAAS,IAAI,GAAG,IAAI,KAAK,KACzB;AACI,kBAAM,SAAS,UAAU,CAAA;AACzB,kBAAM,KAAK,QAAQ,YAAY,KAAK,EAAE;AACtC,kBAAM,KAAK,QAAQ,YAAY,MAAM,EAAE;AACvC,kBAAM,QAAQ,QAAQ,YAAY,QAAQ,MAAM,EAAE;AAC5C,kBAAA,SAAS,SAAc,KAAA;AAE7B,gBAAI,QACJ;AACI,uBAAS,QAAQ,KAAK;gBAClB,OAAO,gBAAgB,KAAK;gBAC5B,QAAQ,gBAAgB,MAAM;gBAC9B;cAAA,CACH;YAAA;UACL;QACJ;AAGJ,cAAM,OAAO,IAAI,YAAW,UAAU,UAAU,IAAI;AAGhD,YAAA,YAAW,UAAU,IAAA,MAAU,QACnC;AACI,sBAAW,UAAU,IAAI;QAAA;AAG7B,oBAAW,UAAU,IAAQ,IAAA;AAEtB,eAAA;MAAA;IAEf;AAjdO,IAAM,aAAN;AAQH,eAAuB,QAAQ,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,GAAG,GAAG,GAAG;AARlD,eAgBc,UAAU,CAAC,CAAC,KAAK,GAAG,CAAC;AAhBnC,eAsBc,eAAe,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,GAAG,GAAG,GAAG;AAtBrE,eA6Bc,QAAQ,CAAC,CAAC,KAAK,GAAG,CAAC;AA7BjC,eAuCc,iBAAqC;MACxD,YAAY;MACZ,cAAc;MACd,eAAe;MACf,SAAS;MACT,OAAO,YAAW;IACtB;AAGA,eAAuB,YAAoC,CAAA;;;;;ACpIxD,IAAM;AAAN;;IAAM,eAAN,MACP;MAoBI,YAAY,UAAkB,UAC9B;AACI,aAAK,WAAW;AAChB,aAAK,WAAW;AAChB,aAAK,OAAO;AAEZ,aAAK,kBAAkB;AACvB,aAAK,mBAAmB;AACxB,aAAK,YAAY;MAAA;MAOd,OAAO,aACd;AACQ,YAAA,CAAC,eACE,KAAK,oBAAoB,KAAK,SAAS,aACvC,KAAK,qBAAqB,KAAK,SAAS,WAE/C;AACI;QAAA;AAGC,aAAA,kBAAkB,KAAK,SAAS;AAChC,aAAA,mBAAmB,KAAK,SAAS;AAEhC,cAAA,OAAO,KAAK,SAAS;AAE3B,YAAI,CAAC,KAAK,QAAQ,KAAK,KAAK,WAAW,KAAK,QAC5C;AACK,eAAK,OAAe,IAAI,aAAa,KAAK,MAAM;QAAA;AAGrD,aAAK,SAAS,YAAY,MAAM,KAAK,IAAI;AAEpC,aAAA;MAAA;IAEb;;;;;IC1DMC,YACA,aAoBO,OAAA;;;;;;AArBb,IAAMA,aAAY,IAAI,MAAM;AAC5B,IAAM,cAAc,IAAI,QAAQ;AAoBzB,IAAM,QAAN,cAAoD,UAC3D;MAyEI,YAAY,UAAoB,QAAW,OAAe,WAAuB,WAAW,WAC5F;AACU,cAAA;AAEN,aAAK,WAAW;AAChB,aAAK,SAAS;AACT,aAAA,QAAQ,SAAS,MAAM,MAAM;AAClC,aAAK,WAAW;AAChB,aAAK,QAAQ;AACb,aAAK,OAAO;AAEZ,aAAK,MAAM;AACX,aAAK,UAAU;AACV,aAAA,aAAa,IAAI,aAAa,CAAC;AACpC,aAAK,cAAc;AAEnB,aAAK,eAAe;AACpB,aAAK,eAAe,SAAS;AAC7B,aAAK,WAAW;MAAA;MAQpB,IAAI,WACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,SAAS,OACb;AACQ,YAAA,KAAK,cAAc,OACvB;AACI;QAAA;AAGJ,YAAI,KAAK,WACT;AACI,eAAK,UAAU;AAEX,cAAA,KAAK,UAAU,aAAa,GAChC;AACI,iBAAK,UAAU,QAAQ;UAAA;QAC3B;AAGJ,aAAK,YAAY;AAEjB,YAAI,KAAK,WACT;AACI,eAAK,UAAU;QAAA;AAGnB,aAAK,cAAc;MAAA;MAOvB,IAAI,WACJ;AACW,eAAA,KAAK,SAAS,QAAQ,CAAA;MAAA;MAQjC,IAAI,iBACJ;AACW,eAAA,KAAK,SAAS,QAAQ,CAAA;MAAA;MAIjC,IAAI,SAAS,OACb;AACI,aAAK,SAAS;MAAA;MAGlB,IAAI,WACJ;AACI,eAAO,KAAK;MAAA;MAQhB,IAAI,UAAU,OACd;AACI,aAAK,MAAM,YAAY;MAAA;MAG3B,IAAI,YACJ;AACI,eAAO,KAAK,MAAM;MAAA;MAUtB,IAAI,YAAY,OAChB;AACQ,YAAA,KAAK,iBAAiB,OAC1B;AACI,eAAK,eAAe;QAAA;AAExB,aAAK,eAAe;MAAA;MAGxB,IAAI,cACJ;AACI,eAAO,KAAK;MAAA;MAUhB,IAAI,OACJ;AACI,eAAO,UAAU,KAAK,SAAU,KAAK,OAAmC,OAAO;MAAA;MAGnF,IAAI,KAAK,OACT;AACK,aAAK,OAAmC,OAAO;MAAA;MAOpD,IAAI,YACJ;AACI,eAAQ,KAAK,OAAmC;MAAA;MAIpD,IAAI,UACJ;AACI,eAAO,aAAa,KAAK,SAAU,KAAK,OAAmC,UAAU;MAAA;MAGzF,IAAI,QAAQ,OACZ;AACK,aAAK,OAAmC,UAAU;MAAA;MAO7C,QAAQ,UAClB;AAGI,cAAM,WAAW,KAAK,SAAS,QAAQ,CAAG,EAAA;AAC1C,cAAM,SAAS,KAAK;AAIhB,YAAA,OAAO,aACJ,KAAK,aAAa,WAAW,aAC7B,SAAS,SAAS,MAAK,iBAAiB,GAE/C;AACI,eAAK,eAAe,QAAQ;QAAA,OAGhC;AACI,eAAK,eAAe,QAAQ;QAAA;MAChC;MAOM,eAAe,UACzB;AACI,cAAM,SAAS,KAAK;AAEpB,eAAO,QAAQ,KAAK;AACpB,YAAI,OAAO,QACX;AACI,iBAAO,OAAO;QAAA;AAGlB,iBAAS,MAAM,MAAM;AAGrB,eAAO,SAAS,oBAAoB,KAAK,UAAU,eAAe,QAAQ,IAAI;AACrE,iBAAA,OAAO,KAAK,MAAM;AAGlB,iBAAA,MAAM,IAAI,KAAK,KAAK;AAG7B,iBAAS,SAAS,KAAK,KAAK,UAAU,MAAM;AAGnC,iBAAA,SAAS,KAAK,KAAK,UAAU,KAAK,MAAM,KAAK,OAAO,KAAK,SAAS,aAAa;MAAA;MAOlF,eAAe,UACzB;AACI,cAAM,WAAW,KAAK;AACtB,cAAM,SAAS,KAAK;AAEpB,YAAI,OAAO,UACX;AACI,iBAAO,SAAS,OAAO;AACvB,eAAK,aAAa;QAAA;AAItB,aAAK,kBAAkB;AAClB,aAAA,UAAU,SAAS,YAAY;AACpC,aAAK,WAAW,OAAO;AACvB,aAAK,WAAW,OAAO;AAEjB,cAAA,aAAc,KAAK,SAAqC;AAE9D,iBAAS,MAAM,kBAAkB,SAAS,QAAQ,UAAW,CAAA;AACpD,iBAAA,QAAQ,UAAY,EAAA,OAAO,IAAI;MAAA;MAI5C,oBACA;AACI,cAAM,WAAW,KAAK;AAChB,cAAA,iBAAiB,SAAS,QAAQ,CAAA;AACxC,cAAM,WAAW,eAAe;AAChC,cAAM,gBAAgB,eAAe;AAErC,YAAI,kBAAkB,KAAK,eAAe,KAAK,iBAAiB,KAAK,UAAU,UAC/E;AACI;QAAA;AAGC,aAAA,eAAe,KAAK,UAAU;AAEnC,YAAI,KAAK,WAAW,WAAW,SAAS,QACxC;AACI,eAAK,aAAa,IAAI,aAAa,SAAS,MAAM;QAAA;AAGhD,cAAA,KAAK,KAAK,UAAU;AAC1B,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,KAAK,GAAG;AACd,cAAM,KAAK,GAAG;AAEd,cAAM,aAAa,KAAK;AAExB,iBAAS,IAAI,GAAG,IAAI,WAAW,SAAS,GAAG,KAC3C;AACU,gBAAA,IAAI,SAAU,IAAI,CAAA;AAClB,gBAAA,IAAI,SAAU,IAAI,IAAK,CAAA;AAE7B,qBAAY,IAAI,CAAA,IAAO,IAAI,IAAM,IAAI,IAAK;AAC1C,qBAAY,IAAI,IAAK,CAAA,IAAM,IAAI,IAAM,IAAI,IAAK;QAAA;AAGlD,YAAI,KAAK,cACT;AACI,gBAAM,aAAa,SAAS;AAE5B,mBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,EAAE,GACzC;AACI,uBAAW,CAAA,IAAK,KAAK,MAAM,WAAW,CAAA,IAAK,UAAU,IAAI;UAAA;QAC7D;AAGJ,aAAK,cAAc;MAAA;MAIvB,eACA;AACU,cAAA,UAAU,KAAK,SAAS,QAAQ,CAAA;AACtC,cAAM,SAAS,KAAK;AAEhB,YAAA,CAAC,OAAO,SAAS,UACrB;AACQ,cAAA,CAAC,KAAK,UACV;AACI,iBAAK,WAAW,IAAI,aAAa,SAAS,OAAO,QAAQ;UAAA;AAE7D,eAAK,SAAS,OAAO;AAChB,eAAA,MAAM,KAAK,SAAS;QAAA,OAG7B;AACI,eAAK,MAAM,QAAQ;QAAA;MACvB;MAOJ,mBACA;AACI,aAAK,kBAAkB;AAEvB,aAAK,QAAQ,cAAc,KAAK,YAAY,GAAG,KAAK,WAAW,MAAM;MAAA;MAQlE,cAAc,OACrB;AACQ,YAAA,CAAC,KAAK,UAAU,EAAE,SAAS,MAAM,GAAG,MAAM,CAAC,GAC/C;AACW,iBAAA;QAAA;AAGN,aAAA,eAAe,aAAa,OAAOA,UAAS;AAEjD,cAAM,WAAW,KAAK,SAAS,UAAU,iBAAiB,EAAE;AAE5D,cAAM,SAAS,YAAY;AAC3B,cAAMC,WAAU,KAAK,SAAS,SAAA,EAAW;AACzC,cAAM,MAAMA,SAAQ;AACpB,cAAM,OAAO,KAAK,aAAa,IAAI,IAAI;AAEvC,iBAAS,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,MAClC;AACU,gBAAA,OAAOA,SAAQ,CAAK,IAAA;AACpB,gBAAA,OAAOA,SAAQ,IAAI,CAAK,IAAA;AACxB,gBAAA,OAAOA,SAAQ,IAAI,CAAK,IAAA;AAE9B,iBAAO,CAAA,IAAK,SAAS,IAAA;AACd,iBAAA,CAAA,IAAK,SAAS,OAAO,CAAA;AAC5B,iBAAO,CAAA,IAAK,SAAS,IAAA;AACd,iBAAA,CAAA,IAAK,SAAS,OAAO,CAAA;AAC5B,iBAAO,CAAA,IAAK,SAAS,IAAA;AACd,iBAAA,CAAA,IAAK,SAAS,OAAO,CAAA;AAE5B,cAAI,YAAY,SAASD,WAAU,GAAGA,WAAU,CAAC,GACjD;AACW,mBAAA;UAAA;QACX;AAGG,eAAA;MAAA;MAGJ,QAAQ,SACf;AACI,cAAM,QAAQ,OAAO;AAErB,YAAI,KAAK,gBACT;AACI,eAAK,eAAe,QAAQ;AAC5B,eAAK,iBAAiB;QAAA;AAG1B,aAAK,WAAW;AAChB,aAAK,SAAS;AACd,aAAK,QAAQ;AACb,aAAK,MAAM;AACX,aAAK,UAAU;AACf,aAAK,aAAa;MAAA;IAK1B;AAjdO,IAAM,OAAN;AAAM,SAgdK,iBAAiB;;;;;IC3dtB;;;;AAAN,IAAM,eAAN,cAA2B,SAClC;MAgBI,YAAY,UAAyB,KAAoB,OACzD;AACU,cAAA;AAEA,cAAA,iBAAiB,IAAI,OAAO,QAAQ;AAC1C,cAAM,YAAY,IAAI,OAAO,KAAK,IAAI;AACtC,cAAM,cAAc,IAAI,OAAO,OAAO,MAAM,IAAI;AAEhD,aAAK,aAAa,mBAAmB,gBAAgB,GAAG,OAAO,MAAM,KAAK,EACrE,aAAa,iBAAiB,WAAW,GAAG,OAAO,MAAM,KAAK,EAC9D,SAAS,WAAW;AAEzB,aAAK,YAAY;MAAA;MAQrB,IAAI,gBACJ;AACW,eAAA,KAAK,QAAQ,CAAG,EAAA;MAAA;IAE/B;;;;;AC3DA,IAAI;AAAJ;AAAA;AAAA,IAAI,WAAW;AAAA;AAAA;;;ACAf,IAAI;AAAJ;AAAA;AAAA,IAAI,SAAS;AAAA;AAAA;;;ICsBA;;;;;;AAAN,IAAM,eAAN,cAA2B,OAClC;MAwCI,YAAY,UAAmB,SAC/B;AACI,cAAM,WAAW;UACb;UACA,OAAO;UACP,gBAAgB,OAAO;UACvB,QAAQ,IAAI,aAAa,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;QAAA;AAIzC,kBAAU,OAAO,OAAO;UACpB,MAAM;UACN,OAAO;UACP,YAAY;QAAA,GACb,OAAO;AAEV,YAAI,QAAQ,UACZ;AACW,iBAAA,OAAO,UAAU,QAAQ,QAAQ;QAAA;AAG5C,cAAM,QAAQ,WAAW,QAAQ,KAAK,QAAQ,QAAQ,GAAG,QAAQ;AAEjE,aAAK,cAAc;AAEd,aAAA,WAAW,IAAI,cAAc,QAAQ;AACrC,aAAA,YAAY,QAAQ,YAAY;AACrC,aAAK,aAAa,QAAQ;AAE1B,aAAK,aAAa,IAAI,MAAM,QAAQ,IAAI;AACnC,aAAA,WAAW,KAAK,WAAW,qBAAqB;AACrD,aAAK,cAAc;AACnB,aAAK,QAAQ,QAAQ;MAAA;MAIzB,IAAI,UACJ;AACI,eAAO,KAAK,SAAS;MAAA;MAEzB,IAAI,QAAQ,OACZ;AACQ,YAAA,KAAK,SAAS,aAAa,OAC/B;AACQ,cAAA,CAAC,KAAK,SAAS,SAAS,YAAY,cAAc,CAAC,MAAM,YAAY,WACzE;AACI,iBAAK,cAAc;UAAA;AAGvB,eAAK,SAAS,WAAW;AACzB,eAAK,SAAS,UAAU;QAAA;MAC5B;MAOJ,IAAI,MAAM,OACV;AACI,YAAI,UAAU,KAAK;AAAQ;AAE3B,aAAK,SAAS;AACd,aAAK,cAAc;MAAA;MAEvB,IAAI,QACJ;AACI,eAAO,KAAK;MAAA;MAOhB,IAAI,KAAK,OACT;AACI,YAAI,UAAU,KAAK;AAAM;AAEpB,aAAA,WAAW,SAAS,KAAK;AACzB,aAAA,WAAW,KAAK,WAAW,qBAAqB;AACrD,aAAK,cAAc;MAAA;MAEvB,IAAI,OACJ;AACI,eAAO,KAAK,WAAW;MAAA;MAO3B,IAAI,YACJ;AACW,eAAA,KAAK,WAAW,SAAS;MAAA;MAIpC,SACA;AACI,YAAI,KAAK,aACT;AACI,eAAK,cAAc;AACb,gBAAA,cAAc,KAAK,QAAQ;AACjC,gBAAM,kBAAmB,YAAY;AAErC,gBAAM,OACD,SAAS,KAAK,UAAU,EACxB,YAAY,KAAK,QAAQ,eAAe,EACxC,QAAQ,KAAK,SAAS,MAAM;QAAA;AAEjC,YAAA,KAAK,SAAS,OAAA,GAClB;AACS,eAAA,SAAS,iBAAiB,KAAK,SAAS;QAAA;MACjD;IAER;;;;;AClLA,IAAAE,YAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;;;ACHA,IAAI;AAAJ;AAAA;AAAA,IAAI,WAAW;AAAA;AAAA;;;ACAf,IAAI;AAAJ;AAAA;AAAA,IAAI,WAAW;AAAA;AAAA;;;ICmCT,iCACA,8BACA,oBAgCO,aAAA;;;;;;;;;;;;AAlCb,IAAM,kCAAkD,CAAA;AACxD,IAAM,+BAA+C,CAAA;AACrD,IAAM,qBAAuC,CAAA;AAgCtC,IAAM,cAAN,cAAyB,UAChC;MAyHI,YAAY,MAAc,QAAmC,CAAA,GAC7D;AACU,cAAA;AAGN,cAAM,EAAE,OAAO,MAAM,UAAU,eAAe,UAAU,SAAa,IAAA,OAAO,OACxE,CAAA,GAAI,YAAW,eAAe,KAAK;AAEnC,YAAA,CAAC,WAAW,UAAU,QAC1B,GAAA;AACU,gBAAA,IAAI,MAAM,uBAAuB,QAAW,GAAA;QAAA;AAGtD,aAAK,uBAAuB,CAAA;AAC5B,aAAK,aAAa;AAClB,aAAK,cAAc;AACnB,aAAK,SAAS;AACT,aAAA,aAAa,IAAI,MAAM,IAAI;AAChC,aAAK,QAAQ;AACb,aAAK,YAAY;AACjB,aAAK,YAAY;AACjB,aAAK,OAAO;AACZ,aAAK,YAAY;AACjB,aAAK,iBAAiB;AACtB,aAAK,iBAAiB;AACjB,aAAA,UAAU,IAAI,gBAAgB,MAAY;AAAE,eAAK,QAAQ;QAAA,GAAS,MAAM,GAAG,CAAC;AACjF,aAAK,eAAe,SAAS;AAC7B,aAAK,QAAQ;AACb,aAAK,cAAc,SAAS;AAC5B,aAAK,kBAAkB;AACvB,aAAK,gBAAgB,CAAA;MAAC;MAI1B,aACA;;AACU,cAAA,OAAO,WAAW,UAAU,KAAK,SAAA;AACvC,cAAM,WAAW,KAAK;AAChB,cAAA,QAAQ,WAAW,KAAK;AACxB,cAAA,MAAM,IAAI,MAAM;AACtB,cAAM,QAA0B,CAAA;AAChC,cAAM,aAAa,CAAA;AACnB,cAAM,aAAa,CAAA;AACnB,cAAM,OAAO,KAAK,MAAM,QAAQ,gBAAgB,IAAI,KAAK;AACnD,cAAA,aAAa,sBAAsB,IAAI;AAC7C,cAAM,WAAW,KAAK,YAAY,KAAK,OAAO;AAC9C,cAAM,mBAAmB,KAAK,sBAAsB,SAC9C,kCAAkC;AAExC,YAAI,eAAe;AACnB,YAAI,gBAAgB;AACpB,YAAI,eAAe;AACnB,YAAI,OAAO;AACX,YAAI,eAAe;AACnB,YAAI,iBAAiB;AACrB,YAAI,gBAAgB;AACpB,YAAI,gBAAgB;AACpB,YAAI,aAAa;AAEjB,iBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KACvC;AACI,gBAAM,OAAO,WAAW,CAAA;AAClB,gBAAA,WAAW,gBAAgB,IAAI;AAEhC,cAAA,SAAU,KAAK,IAAI,GACxB;AACmB,2BAAA;AACE,6BAAA;AACjB;UAAA;AAGA,cAAA,SAAS,QAAQ,SAAS,MAC9B;AACI,uBAAW,KAAK,aAAa;AAC7B,uBAAW,KAAK,EAAE;AACH,2BAAA,KAAK,IAAI,cAAc,aAAa;AACjD,cAAA;AACA,cAAA;AAEF,gBAAI,IAAI;AACR,gBAAI,KAAK,KAAK;AACC,2BAAA;AACF,yBAAA;AACb;UAAA;AAGE,gBAAA,WAAW,KAAK,MAAM,QAAA;AAE5B,cAAI,CAAC,UACL;AACI;UAAA;AAGA,cAAA,gBAAgB,SAAS,QAAQ,YACrC,GAAA;AACQ,gBAAA,KAAK,SAAS,QAAQ,YAAA;UAAA;AAGxB,gBAAA,iBAAiC,mBAAmB,IAAA,KAAS;YAC/D,SAAS,QAAQ;YACjB,MAAM;YACN,UAAU;YACV,YAAY;YACZ,UAAU,IAAI,MAAM;UAAA;AAGxB,yBAAe,UAAU,SAAS;AAClC,yBAAe,OAAO;AACtB,yBAAe,WAAW;AACX,yBAAA,SAAS,IAAI,KAAK,MAAM,IAAI,IAAI,SAAS,UAAW,KAAK,iBAAiB,CAAE;AAC3F,yBAAe,SAAS,IAAI,KAAK,MAAM,IAAI,IAAI,SAAS,OAAO;AAC/D,yBAAe,aAAa;AAE5B,gBAAM,KAAK,cAAc;AAEzB,0BAAgB,eAAe,SAAS,IAClC,KAAK,IAAI,SAAS,WAAW,SAAS,SAAS,SAAS,QAAQ,KAAK,KAAK;AAC5E,cAAA,KAAK,SAAS,WAAW,KAAK;AAClC,0BAAgB,KAAK,IAAI,eAAgB,SAAS,UAAU,SAAS,QAAQ,MAAO;AACrE,yBAAA;AAEf,cAAI,iBAAiB,MAAM,WAAW,KAAK,IAAI,IAAI,UACnD;AACM,cAAA;AACF,wBAAM,YAAY,OAAO,IAAI,eAAe,eAAe,IAAI,IAAI,YAAY;AAC3E,gBAAA;AACW,2BAAA;AAEf,uBAAW,KAAK,cAAc;AACnB,uBAAA,KAAK,MAAM,SAAS,IAAI,MAAM,MAAM,SAAS,CAAG,EAAA,aAAa,CAAC;AAC1D,2BAAA,KAAK,IAAI,cAAc,cAAc;AACpD;AAEA,gBAAI,IAAI;AACR,gBAAI,KAAK,KAAK;AACC,2BAAA;AACF,yBAAA;UAAA;QACjB;AAGE,cAAA,WAAW,WAAW,WAAW,SAAS,CAAA;AAE5C,YAAA,aAAa,QAAQ,aAAa,MACtC;AACS,cAAA,SAAU,KAAK,QAAQ,GAC5B;AACoB,4BAAA;UAAA;AAGpB,qBAAW,KAAK,aAAa;AACd,yBAAA,KAAK,IAAI,cAAc,aAAa;AACnD,qBAAW,KAAK,EAAE;QAAA;AAGtB,cAAM,mBAAmB,CAAA;AAEzB,iBAAS,IAAI,GAAG,KAAK,MAAM,KAC3B;AACI,cAAI,cAAc;AAEd,cAAA,KAAK,WAAW,SACpB;AACI,0BAAc,eAAe,WAAW,CAAA;UAAA,WAEnC,KAAK,WAAW,UACzB;AACmB,2BAAA,eAAe,WAAW,CAAM,KAAA;UAAA,WAE1C,KAAK,WAAW,WACzB;AACI,0BAAc,WAAW,CAAK,IAAA,IAAI,KAAoB,eAAA,WAAW,CAAA,KAAM,WAAW,CAAA;UAAA;AAGtF,2BAAiB,KAAK,WAAW;QAAA;AAGrC,cAAM,WAAW,MAAM;AAEvB,cAAM,gBAA8C,CAAA;AAEpD,cAAM,mBAAmC,CAAA;AAEzC,cAAM,sBAAsB,KAAK;AAEhB,yBAAA,KAAK,GAAG,mBAAmB;AAE5C,iBAAS,IAAI,GAAG,IAAI,UAAU,KAC9B;AACU,gBAAA,UAAU,MAAM,CAAG,EAAA;AACnB,gBAAA,iBAAiB,QAAQ,YAAY;AAEvC,cAAA,CAAC,cAAc,cACnB,GAAA;AACQ,gBAAA,eAAe,iBAAiB,IAAI;AAExC,gBAAI,CAAC,cACL;AACU,oBAAA,WAAW,IAAI,aAAa;AAC9B,kBAAA;AACA,kBAAA;AAEA,kBAAA,KAAK,sBAAsB,QAC/B;AACe,2BAAA,IAAI,aAAa,QAAQ,KAAK;AACzC,gCAAgB,YAAY;cAAA,OAGhC;AACI,2BAAW,IAAI,aAAa,QAAQ,OAChC,EAAE,SAAS,QAAQ,KAAK,UAAU,QAAQ,GAAG,UAAU,EAAE,SAAS,EAAA,EAAA,CAAK;AAC3E,gCAAgB,YAAY;cAAA;AAGhC,oBAAM,OAAO,IAAI,KAAK,UAAU,QAAQ;AAExC,mBAAK,YAAY;AAEF,6BAAA;gBACX,OAAO;gBACP,YAAY;gBACZ,aAAa;gBACb,UAAU;gBACV,OAAO;gBACP;gBACA,UAAU;gBACV,KAAK;gBACL,SAAS;cAAA;YACb;AAIJ,yBAAa,QAAQ;AACrB,yBAAa,aAAa;AAC1B,yBAAa,cAAc;AAC3B,yBAAa,WAAW;AACxB,yBAAa,QAAQ;AAGrB,kBAAM,EAAE,cAAkB,IAAA;AAE1B,0BAAc,cAAA,IAAkB,cAAc,cAAA,KAAmB,IAAI,QAAQ,QAAQ,WAAW;AACnF,yBAAA,KAAK,UAAU,cAAc,cAAA;AAE7B,yBAAA,KAAK,OAAO,KAAK,WAAW;AAEzC,6BAAiB,KAAK,YAAY;AAElC,0BAAc,cAAkB,IAAA;UAAA;AAGpC,wBAAc,cAAgB,EAAA;QAAA;AAKlC,iBAAS,IAAI,GAAG,IAAI,oBAAoB,QAAQ,KAChD;AACI,cAAI,CAAC,iBAAiB,SAAS,oBAAoB,CAAA,CAAE,GACrD;AACS,iBAAA,YAAY,oBAAoB,CAAA,EAAG,IAAI;UAAA;QAChD;AAKJ,iBAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAC7C;AACI,cAAI,iBAAiB,CAAA,EAAG,KAAK,WAAW,MACxC;AACS,iBAAA,SAAS,iBAAiB,CAAA,EAAG,IAAI;UAAA;QAC1C;AAIJ,aAAK,uBAAuB;AAE5B,mBAAW,KAAK,eAChB;AACI,gBAAM,eAAe,cAAc,CAAA;AACnC,gBAAM,QAAQ,aAAa;AAIvB,cAAA,IAAe,kBAAA,YAAA,mBAAS,UAAS,IAAI,UAAU,aAAa,SAAS,SAAS,KAAK,iBAAiB,GACxG;AACI,yBAAa,WAAW,IAAI,aAAa,IAAI,IAAI,KAAK;AACtD,yBAAa,MAAM,IAAI,aAAa,IAAI,IAAI,KAAK;AACjD,yBAAa,UAAU,IAAI,YAAY,IAAI,KAAK;UAAA,OAGpD;AACI,kBAAM,SAAQ,aAAa;AAC3B,kBAAM,WAAW,aAAa;AAG9B,qBAAS,KAAI,SAAQ,IAAI,GAAG,KAAI,SAAS,QAAQ,MACjD;AACI,uBAAS,EAAK,IAAA;YAAA;UAClB;AAKS,uBAAA,KAAK,OAAO,IAAI;QAAA;AAGjC,iBAAS,IAAI,GAAG,IAAI,UAAU,KAC9B;AACI,gBAAM,OAAO,MAAM,CAAA;AACf,cAAA,SAAS,KAAK,SAAS,IAAK,iBAAiB,KAAK,IAAA,KAAc,KAAA,WAAW,YAAY,KAAK,aAAa;AAE7G,cAAI,KAAK,cACT;AACa,qBAAA,KAAK,MAAM,MAAM;UAAA;AAG9B,gBAAM,OAAO,SAAS;AAChB,gBAAA,OAAO,KAAK,SAAS,IAAI;AAC/B,gBAAM,UAAU,KAAK;AAEf,gBAAA,WAAW,cAAc,QAAQ,YAAY,GAAA;AAEnD,gBAAM,eAAe,QAAQ;AAC7B,gBAAM,aAAa,QAAQ;AAE3B,gBAAM,QAAQ,SAAS;AAEvB,mBAAS,QAAS,QAAQ,IAAK,CAAA,IAAK,IAAK,QAAQ;AACjD,mBAAS,QAAS,QAAQ,IAAK,CAAA,IAAK,IAAK,QAAQ;AACjD,mBAAS,QAAS,QAAQ,IAAK,CAAA,IAAK,IAAK,QAAQ;AACjD,mBAAS,QAAS,QAAQ,IAAK,CAAA,IAAK,IAAK,QAAQ;AACjD,mBAAS,QAAS,QAAQ,IAAK,CAAA,IAAK,IAAK,QAAQ;AACjD,mBAAS,QAAS,QAAQ,IAAK,CAAA,IAAK,IAAK,QAAQ;AAExC,mBAAA,SAAU,QAAQ,IAAK,CAAK,IAAA;AAC5B,mBAAA,SAAU,QAAQ,IAAK,CAAK,IAAA;AAErC,mBAAS,SAAU,QAAQ,IAAK,CAAK,IAAA,OAAQ,aAAa,QAAQ;AACzD,mBAAA,SAAU,QAAQ,IAAK,CAAK,IAAA;AAErC,mBAAS,SAAU,QAAQ,IAAK,CAAK,IAAA,OAAQ,aAAa,QAAQ;AAClE,mBAAS,SAAU,QAAQ,IAAK,CAAK,IAAA,OAAQ,aAAa,SAAS;AAE1D,mBAAA,SAAU,QAAQ,IAAK,CAAK,IAAA;AACrC,mBAAS,SAAU,QAAQ,IAAK,CAAK,IAAA,OAAQ,aAAa,SAAS;AAEnE,mBAAS,IAAK,QAAQ,IAAK,CAAA,IAAK,WAAW;AAC3C,mBAAS,IAAK,QAAQ,IAAK,CAAA,IAAK,WAAW;AAE3C,mBAAS,IAAK,QAAQ,IAAK,CAAA,IAAK,WAAW;AAC3C,mBAAS,IAAK,QAAQ,IAAK,CAAA,IAAK,WAAW;AAE3C,mBAAS,IAAK,QAAQ,IAAK,CAAA,IAAK,WAAW;AAC3C,mBAAS,IAAK,QAAQ,IAAK,CAAA,IAAK,WAAW;AAE3C,mBAAS,IAAK,QAAQ,IAAK,CAAA,IAAK,WAAW;AAC3C,mBAAS,IAAK,QAAQ,IAAK,CAAA,IAAK,WAAW;QAAA;AAG/C,aAAK,aAAa,eAAe;AACjC,aAAK,eAAe,IAAI,IAAI,KAAK,cAAc;AAE/C,mBAAW,KAAK,eAChB;AACI,gBAAM,eAAe,cAAc,CAAA;AAGnC,cAAI,KAAK,OAAO,MAAM,KAAK,KAAK,OAAO,MAAM,GAC7C;AACI,gBAAI,cAAc;AAElB,kBAAM,gBAAgB,KAAK,aAAa,KAAK,OAAO;AACpD,kBAAM,gBAAgB,KAAK,cAAc,KAAK,OAAO;AAErD,qBAAS,KAAI,GAAG,KAAI,aAAa,OAAO,MACxC;AACI,2BAAa,SAAS,aAAkB,KAAA;AACxC,2BAAa,SAAS,aAAkB,KAAA;AAExC,2BAAa,SAAS,aAAkB,KAAA;AACxC,2BAAa,SAAS,aAAkB,KAAA;AAExC,2BAAa,SAAS,aAAkB,KAAA;AACxC,2BAAa,SAAS,aAAkB,KAAA;AAExC,2BAAa,SAAS,aAAkB,KAAA;AACxC,2BAAa,SAAS,aAAkB,KAAA;YAAA;UAC5C;AAGJ,eAAK,iBAAiB,gBAAgB;AAEtC,gBAAM,eAAe,aAAa,KAAK,SAAS,UAAU,iBAAiB;AAC3E,gBAAM,gBAAgB,aAAa,KAAK,SAAS,UAAU,eAAe;AAC1E,gBAAM,cAAc,aAAa,KAAK,SAAS,SAAS;AAExD,uBAAa,OAAO,aAAa;AACjC,wBAAc,OAAO,aAAa;AAClC,sBAAY,OAAO,aAAa;AAEhC,uBAAa,OAAO;AACpB,wBAAc,OAAO;AACrB,sBAAY,OAAO;QAAA;AAGvB,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAClC;AACuB,6BAAA,KAAK,MAAM,CAAE,CAAA;QAAA;AAGpC,aAAK,QAAQ;AACb,aAAK,QAAQ;MAAA;MAGjB,kBACA;AACI,aAAK,SAAS;AACd,aAAK,yBAAyB;MAAA;MAGlC,QAAQ,UACR;AACI,YAAI,KAAK,mBAAmB,KAAK,gBAAgB,SAAS,YAC1D;AACI,eAAK,cAAc,SAAS;AAC5B,eAAK,QAAQ;QAAA;AAIjB,cAAM,EAAE,oBAAoB,mBAAmB,KAAS,IAAA,WAAW,UAAU,KAAK,SAAA;AAElF,YAAI,sBAAsB,QAC1B;AAEI,gBAAM,EAAE,GAAG,GAAG,GAAG,EAAA,IAAM,KAAK;AAE5B,gBAAM,KAAK,KAAK,KAAM,IAAI,IAAM,IAAI,CAAE;AACtC,gBAAM,KAAK,KAAK,KAAM,IAAI,IAAM,IAAI,CAAE;AAChC,gBAAA,cAAc,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,KAAK;AAE7C,gBAAA,YAAY,KAAK,WAAW;AAE5B,gBAAA,aAAa,SAAS,MAAM;AAEvB,qBAAA,QAAQ,KAAK,sBACxB;AACI,iBAAK,KAAK,OAAO,SAAS,UAAU,aAAa,qBAAqB,YAAY;UAAA;QACtF;AAGJ,cAAM,QAAQ,QAAQ;MAAA;MAO1B,iBACA;AACI,aAAK,SAAS;AAEd,eAAO,MAAM,eAAe;MAAA;MAOhC,WACA;AACU,cAAA,OAAO,WAAW,UAAU,KAAK,SAAA;AAEvC,YAAI,CAAC,MACL;AACI,gBAAM,IAAI,MAAM,uBAAuB,KAAK,SAAY,GAAA;QAAA;AAExD,YAAA,KAAK,UAAU,MACnB;AACI,eAAK,QAAQ;QAAA;AAGjB,YAAI,KAAK,OACT;AACI,eAAK,WAAW;QAAA;MACpB;MAOJ,IAAW,OACX;AACI,eAAO,KAAK,WAAW;MAAA;MAG3B,IAAW,KAAK,OAChB;AACI,YAAI,KAAK,SAAS;AAAO;AAEpB,aAAA,WAAW,SAAS,KAAK;AAE9B,iBAAS,IAAI,GAAG,IAAI,KAAK,qBAAqB,QAAQ,KACtD;AACS,eAAA,qBAAqB,CAAG,EAAA,KAAK,OAAO;QAAA;MAC7C;MAQJ,IAAW,QACX;AACI,eAAO,KAAK;MAAA;MAGhB,IAAW,MAAM,OACjB;AACQ,YAAA,KAAK,WAAW,OACpB;AACI,eAAK,SAAS;AACd,eAAK,QAAQ;QAAA;MACjB;MAIJ,IAAW,WACX;AACI,eAAO,KAAK;MAAA;MAGhB,IAAW,SAAS,OACpB;AACQ,YAAA,CAAC,WAAW,UAAU,KAC1B,GAAA;AACU,gBAAA,IAAI,MAAM,uBAAuB,KAAQ,GAAA;QAAA;AAG/C,YAAA,KAAK,cAAc,OACvB;AACI,eAAK,YAAY;AACjB,eAAK,QAAQ;QAAA;MACjB;MAIJ,IAAW,WACX;AACI,eAAO,KAAK,aAAa,WAAW,UAAU,KAAK,SAAW,EAAA;MAAA;MAGlE,IAAW,SAAS,OACpB;AACQ,YAAA,KAAK,cAAc,OACvB;AACI,eAAK,YAAY;AACjB,eAAK,QAAQ;QAAA;MACjB;MAYJ,IAAW,SACX;AACI,eAAO,KAAK;MAAA;MAGhB,IAAW,OAAO,OAClB;AACQ,YAAA,OAAO,UAAU,UACrB;AACS,eAAA,QAAQ,IAAI,KAAK;QAAA,OAG1B;AACS,eAAA,QAAQ,SAAS,KAAK;QAAA;MAC/B;MAIJ,IAAW,OACX;AACI,eAAO,KAAK;MAAA;MAGhB,IAAW,KAAK,MAChB;AACI,eAAO,OAAO,SAAS,QAAQ,SAAS,SAAY,KAAK,IAAI;AAEzD,YAAA,KAAK,UAAU,MACnB;AACI;QAAA;AAEJ,aAAK,QAAQ;AACb,aAAK,QAAQ;MAAA;MAQjB,IAAW,WACX;AACI,eAAO,KAAK;MAAA;MAGhB,IAAW,SAAS,OACpB;AACQ,YAAA,KAAK,cAAc,OACvB;AACI;QAAA;AAEJ,aAAK,YAAY;AACjB,aAAK,QAAQ;MAAA;MAQjB,IAAW,gBACX;AACI,aAAK,SAAS;AAEd,eAAO,KAAK;MAAA;MAQhB,IAAW,YACX;AACI,aAAK,SAAS;AAEd,eAAO,KAAK;MAAA;MAIhB,IAAW,gBACX;AACI,eAAO,KAAK;MAAA;MAGhB,IAAW,cAAc,OACzB;AACQ,YAAA,KAAK,mBAAmB,OAC5B;AACI,eAAK,iBAAiB;AACtB,eAAK,QAAQ;QAAA;MACjB;MAUJ,IAAW,cACX;AACI,eAAO,KAAK;MAAA;MAGhB,IAAW,YAAY,OACvB;AACQ,YAAA,UAAU,KAAK,cACnB;AACI,eAAK,eAAe;AACpB,eAAK,QAAQ;QAAA;MACjB;MAQJ,IAAW,aACX;AACI,aAAK,SAAS;AAEd,eAAO,KAAK;MAAA;MAShB,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,WAAW,OACf;AACI,aAAK,kBAAkB;AAEnB,YAAA,KAAK,gBAAgB,OACzB;AACI;QAAA;AAGJ,aAAK,cAAc;AACnB,aAAK,QAAQ;MAAA;MAGjB,QAAQ,SACR;AACI,cAAM,EAAE,cAAkB,IAAA;AACpB,cAAA,OAAO,WAAW,UAAU,KAAK,SAAA;AACvC,cAAM,mBAAmB,KAAK,sBAAsB,SAC9C,kCAAkC;AAEvB,yBAAA,KAAK,GAAG,KAAK,oBAAoB;AACvC,mBAAA,gBAAgB,KAAK,sBAChC;AACS,eAAA,YAAY,aAAa,IAAI;QAAA;AAEtC,aAAK,uBAAuB,CAAA;AAG5B,yBACK,OAAO,CAAC,SAAS,cAAc,KAAK,KAAK,QAAQ,YAAY,GAAI,CAAA,EACjE,QAAQ,CAAC,SACV;AACS,eAAA,KAAK,UAAU,QAAQ;QAAA,CAC/B;AAEL,mBAAW,MAAM,eACjB;AACI,gBAAM,UAAU,cAAc,EAAA;AAE9B,kBAAQ,QAAQ;AAChB,iBAAO,cAAc,EAAA;QAAA;AAGzB,aAAK,QAAQ;AACb,aAAK,aAAa;AAClB,aAAK,gBAAgB;AAErB,cAAM,QAAQ,OAAO;MAAA;IAE7B;AAh3BO,IAAM,aAAN;AAAM,eAEK,gBAA2C;MACrD,OAAO;MACP,MAAM;MACN,UAAU;MACV,eAAe;IACnB;;;;;AC5EG,SAAA,aAAsB,KAAa,OAC1C;AACQ,MAAA,MAAM,QAAQ,KAAK,GACvB;AACI,eAAW,QAAQ,OACnB;AACQ,UAAA,IAAI,WAAW,QAAQ,IAAM,EAAA;AAAU,eAAA;IAAA;AAGxC,WAAA;EAAA;AAGJ,SAAA,IAAI,WAAW,QAAQ,KAAO,EAAA;AACzC;AAbO;;;;;;ACEA,SAAA,eAAwB,KAAa,WAC5C;AACI,QAAM,UAAU,IAAI,MAAM,GAAG,EAAE,CAAA;AAC/B,QAAM,MAAM,YAAM,KAAK,QAAQ,OAAO,EAAE,YAAY;AAEhD,MAAA,MAAM,QAAQ,SAAS,GAC3B;AACW,WAAA,UAAU,SAAS,GAAG;EAAA;AAGjC,SAAO,QAAQ;AACnB;;;;;;;;ACba,IAAA;AAAA;;IAAA,gBAAgB,CAAI,OAAoC,cACrE;AACI,UAAI,CAAC,MAAM,QAAQ,KAAK,GACxB;AACI,gBAAQ,CAAC,KAAU;MAAA;AAGvB,UAAI,CAAC,WACL;AACW,eAAA;MAAA;AAGH,aAAA,MAAyB,IAAI,CAAC,SACtC;AACQ,YAAA,OAAO,SAAS,UACpB;AACI,iBAAO,UAAU,IAAc;QAAA;AAG5B,eAAA;MAAA,CACV;IACL;;;;;ACfa,IAAA;AAAA;;IAAA,mBAAmB,CAAC,WAAmB,cACpD;AACI,YAAM,eAAe,UAAU,MAAM,GAAG,EAAE,CAAA;AAE1C,UAAI,cACJ;AACI,qBAAa,IAAI,YAAA;MAAA;AAGd,aAAA;IACX;;;;;AChBA,SAAA,SAAkB,MAAc,KAAiB,OAAe,QAAkB,MAClF;AACI,QAAM,KAAK,IAAI,KAAA;AAEf,WAAS,IAAI,GAAG,IAAI,GAAG,QAAQ,KAC/B;AACI,UAAM,QAAQ,GAAG,CAAA;AAEb,QAAA,QAAQ,IAAI,SAAS,GACzB;AACa,eAAA,KAAK,QAAQ,OAAO,KAAQ,GAAA,KAAK,GAAG,KAAK,QAAQ,GAAG,QAAQ,IAAI;IAAA,OAG7E;AACI,WAAK,KAAK,KAAK,QAAQ,OAAO,KAAA,GAAQ,KAAK,CAAC;IAAA;EAChD;AAER;AASO,SAAA,uBAAgC,QACvC;AACI,QAAM,QAAQ;AAER,QAAA,SAAS,OAAO,MAAM,KAAK;AAEjC,QAAM,OAAiB,CAAA;AAEvB,MAAI,QACJ;AACI,UAAM,MAAkB,CAAA;AAEjB,WAAA,QAAQ,CAAC,SAChB;AAEU,YAAA,QAAQ,KAAK,UAAU,GAAG,KAAK,SAAS,CAAC,EAAE,MAAM,GAAG;AAE1D,UAAI,KAAK,KAAK;IAAA,CACjB;AAED,aAAS,QAAQ,KAAK,GAAG,QAAQ,IAAI;EAAA,OAGzC;AACI,SAAK,KAAK,MAAM;EAAA;AAGb,SAAA;AACX;AAtDA;;;;;;ACIO,IAAM;AAAN;;IAAM,eAAe,CAAC,SAA4B,CAAC,MAAM,QAAQ,IAAI;;;;;ACJ5E,IAAAC,cAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;ICeM,YAgKO;;;;;;AAhKb,IAAM,aAAN,MACA;MADA,cAAA;AAEI,aAAQ,WAA0B,CAAA;AAEjB,aAAA,SAAA,oBAA+B,IAAI;AACnC,aAAA,YAAA,oBAGR,IAAI;MAAA;MAGb,QACA;AACI,aAAK,UAAU,MAAM;AACrB,aAAK,OAAO,MAAM;MAAA;MAOf,IAAI,KACX;AACW,eAAA,KAAK,OAAO,IAAI,GAAG;MAAA;MAOvB,IAAa,KACpB;AACI,cAAM,SAAS,KAAK,OAAO,IAAI,GAAG;AAElC,YAAI,CAAC,QACL;AAEY,kBAAA,KAAK,qBAAqB,GAAgC,6BAAA;QAAA;AAI/D,eAAA;MAAA;MAQJ,IAAI,KAAwB,OACnC;AACU,cAAA,OAAO,cAAsB,GAAG;AAElC,YAAA;AAEJ,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACU,gBAAA,SAAS,KAAK,QAAQ,CAAA;AAExB,cAAA,OAAO,KAAK,KAAK,GACrB;AACsB,8BAAA,OAAO,mBAAmB,MAAM,KAAK;AAEvD;UAAA;QACJ;AAGJ,YAAI,CAAC,iBACL;AACI,4BAAkB,CAAA;AAEb,eAAA,QAAQ,CAAC,SACd;AACI,4BAAgB,IAAO,IAAA;UAAA,CAC1B;QAAA;AAGC,cAAA,YAAY,OAAO,KAAK,eAAe;AAE7C,cAAM,eAAe;UACjB;UACA;QAAA;AAIC,aAAA,QAAQ,CAAC,SACd;AACS,eAAA,UAAU,IAAI,MAAK,YAAY;QAAA,CACvC;AAES,kBAAA,QAAQ,CAAC,SACnB;AACQ,cAAA,KAAK,OAAO,IAAI,IAAG,KAAK,KAAK,OAAO,IAAI,IAAG,MAAM,OACrD;AAEY,oBAAA,KAAK,4BAA4B,IAAG;UAAA;AAIhD,eAAK,OAAO,IAAI,MAAK,gBAAgB,IAAI,CAAA;QAAA,CAC5C;AAGD,YAAI,iBAAiB,SACrB;AACI,gBAAM,UAAmB;AAEpB,eAAA,QAAQ,CAAC,SACd;AACI,gBAAI,QAAQ,gBAAgB,QAAQ,MAAM,aAC1C;AACgB,0BAAA,WAAW,QAAQ,aAAa,IAAG;YAAA;AAG3C,oBAAA,WAAW,SAAS,IAAG;UAAA,CAClC;QAAA;MACL;MASG,OAAO,KACd;AACS,aAAA,UAAU,IAAI,GAAG;AAEtB,YAAI,CAAC,KAAK,UAAU,IAAI,GAAG,GAC3B;AAEY,kBAAA,KAAK,qBAAqB,GAAgC,6BAAA;AAGlE;QAAA;AAGJ,cAAM,WAAW,KAAK,UAAU,IAAI,GAAG;AAEvC,cAAM,YAAY,SAAS;AAEjB,kBAAA,QAAQ,CAAC,SACnB;AACS,eAAA,OAAO,OAAO,IAAG;QAAA,CACzB;AAEQ,iBAAA,KAAK,QAAQ,CAAC,SACvB;AACS,eAAA,UAAU,OAAO,IAAG;QAAA,CAC5B;MAAA;MAIL,IAAW,UACX;AACI,eAAO,KAAK;MAAA;IAEpB;AAEa,IAAA,QAAQ,IAAI,WAAW;;;;;ACzKxB,IAAA;AAAA;;IAAA,wBAAA,CAAA,0BAAL;AAIH,4BAAA,sBAAA,KAAA,IAAM,CAAN,IAAA;AAEA,4BAAA,sBAAA,QAAA,IAAS,CAAT,IAAA;AAEA,4BAAA,sBAAA,MAAA,IAAO,CAAP,IAAA;AARQ,aAAA;IAAA,GAAA,wBAAA,CAAA,CAAA;;;;;ICJN,oBACA,eAGO;;;;;;;AAJb,IAAM,qBAAqB;AAC3B,IAAM,gBAAgB;AAGf,IAAM,WAAW;MACpB,WAAW;QACP,MAAM,cAAc;QACpB,UAAU,qBAAqB;MAAA;MAGnC,MAAM;MAEN,KAAK,KACL;AACI,eAAO,aAAa,KAAK,aAAa,KAAK,eAAe,KAAK,kBAAkB;MAAA;MAGrF,MAAM,KAAQ,KACd;AACI,cAAM,WAAW,MAAM,SAAS,QAAQ,MAAM,GAAG;AAE3C,cAAA,OAAO,MAAM,SAAS,KAAK;AAE1B,eAAA;MAAA;IAEf;AAEA,eAAW,IAAI,QAAQ;;;;;IC3BjB,mBACA,cAGO;;;;;;;AAJb,IAAM,oBAAoB;AAC1B,IAAM,eAAe;AAGd,IAAM,UAAU;MAEnB,MAAM;MAEN,WAAW;QACP,MAAM,cAAc;QACpB,UAAU,qBAAqB;MAAA;MAGnC,KAAK,KACL;AACI,eAAO,aAAa,KAAK,YAAY,KAAK,eAAe,KAAK,iBAAiB;MAAA;MAGnF,MAAM,KAAK,KACX;AACI,cAAM,WAAW,MAAM,SAAS,QAAQ,MAAM,GAAG;AAE3C,cAAA,MAAM,MAAM,SAAS,KAAK;AAEzB,eAAA;MAAA;IAEf;AAEA,eAAW,IAAI,OAAO;;;;;ACWf,SAAA,kBAA2B,KAClC;AACI,QAAM,MAAM,YAAM,KAAK,QAAQ,GAAG;AAClC,QAAM,OAAO,YAAM,KAAK,SAAS,KAAK,GAAG;AAGzC,QAAM,iBAAiB,KAAK,QAAQ,UAAU,GAAG;AAGjD,QAAM,aAAa,eAAe,YAAA,EAC7B,MAAM,GAAG,EACT,IAAI,CAAC,SAAS,KAAK,OAAO,CAAC,EAAE,YAAA,IAAgB,KAAK,MAAM,CAAC,CAAC;AAE3D,MAAA,QAAQ,WAAW,SAAS;AAEhC,aAAW,SAAS,YACpB;AACI,QAAI,CAAC,MAAM,MAAM,qBAAqB,GACtC;AACY,cAAA;AACR;IAAA;EACJ;AAGA,MAAA,iBAAiB,WAAW,KAAK,GAAG;AAExC,MAAI,CAAC,OACL;AACI,qBAAiB,IAAI,eAAe,QAAQ,UAAU,MAAM,CAAA;EAAA;AAGzD,SAAA;AACX;IAtEM,cAIA,qBACA,gBA0BA,uBA0CO;;;;;;;AAzEb,IAAM,eAAe;MACjB;MAAU;MACV;MAAO;MAAO;MAAO;MAAO;MAAO;MAAO;MAAO;MAAO;IAC5D;AACA,IAAM,sBAAsB,CAAC,QAAQ,QAAQ,SAAS,QAAQ;AAC9D,IAAM,iBAAiB;MACnB;MACA;MACA;MACA;IACJ;AAqBA,IAAM,wBAAwB;AA0CvB,IAAM,cAAc;MACvB,WAAW;QACP,MAAM,cAAc;QACpB,UAAU,qBAAqB;MAAA;MAGnC,MAAM;MAEN,KAAK,KACL;AACI,eAAO,aAAa,KAAK,cAAc,KAAK,eAAe,KAAK,mBAAmB;MAAA;MAGvF,MAAM,KAAK,KAAa,SACxB;;AACU,cAAA,QAAQ,SAAS,QAAQ,eAAe;AAE9C,YAAI,OACJ;AACI,gBAAM,YAAwB,CAAA;AAC9B,gBAAM,SAAO,aAAQ,SAAR,mBAAc,WAAU,kBAAkB,GAAG;AAC1D,gBAAM,YAAU,mBAAQ,SAAR,mBAAc,YAAd,mBAAuB,OAAO,CAAC,WAAW,aAAa,SAAS,MAAM,OAAM,CAAC,QAAQ;AAC/F,gBAAA,OAAO,QAAQ,QAAQ,CAAA;AAE7B,mBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KACpC;AACI,kBAAM,SAAS,QAAQ,CAAA;AAEvB,kBAAM,OAAO,IAAI,SAAS,MAAM,OAAO,UAAU,GAAG,CAAM,KAAA;cACtD,GAAG;cACH;YAAA,CACH;AAED,kBAAM,KAAK,KAAK;AAEhB,kBAAM,IAAI,IAAI;AAEd,sBAAU,KAAK,IAAI;UAAA;AAGvB,iBAAO,UAAU,WAAW,IAAI,UAAU,CAAK,IAAA;QAAA;AAInD,gBAAQ,KAAK,oEAAoE;AAG1E,eAAA;MAAA;MAGX,OAAO,MACP;AACK,SAAA,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC,IAAI,GAC9B,QAAQ,CAAC,MAAM,SAAS,QAAQ,eAAA,EAAiB,OAAO,CAAC,CAAC;MAAA;IAEvE;AAEA,eAAW,IAAI,WAAW;;;;;ACrII,SAAA,cAAA,MAAmB,QAAgB,KACjE;AACU,QAAA,UAAU,IAAI,QAAQ,IAAI;AAGxB,UAAA,YAAY,GAAG,WAAW,MAClC;AACI,WAAO,OAAO,aAAa,GAAA;EAAA,CAC9B;AAEM,SAAA;AACX;;;;;;;;AChBA,IAAI,MACA,aAGE,WAEA,sBA+BA,YAyCF,WAEE,oBAyJA;AAzON;;IAAI,OAAO;AAIX,IAAM,YAAY;AAElB,IAAM,uBAAuB;MACzB,IAAI;MACJ,MAAM;;;;;;;4CAOkC,SAAA;;;;;;;;;;;;;IAa5C;AASA,IAAM,aAAa;MACf,IAAI;MACJ,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAqCV;AAIA,IAAM,qBAAN,MACA;MAmBI,cACA;AALA,aAAQ,eAAe;AACvB,aAAQ,kBAAkB;AAKtB,aAAK,aAAa,CAAA;AAClB,aAAK,QAAQ,CAAA;AAEb,aAAK,cAAc,CAAA;MAAC;MAGxB,yBACA;AACI,YAAI,KAAK,4BAA4B;AAAW,iBAAO,KAAK;AAE5D,aAAK,0BAA0B,IAAI,QAAQ,CAAC,YAC5C;AACI,gBAAM,aAAY,IAAI,gBAAgB,IAAI,KAAK,CAAC,qBAAqB,IAAI,GACrE,EAAE,MAAM,yBAAA,CAA0B,CAAC;AACjC,gBAAA,SAAS,IAAI,OAAO,UAAS;AAE5B,iBAAA,iBAAiB,WAAW,CAAC,UACpC;AACI,mBAAO,UAAU;AACjB,gBAAI,gBAAgB,UAAS;AAC7B,oBAAQ,MAAM,IAAI;UAAA,CACrB;QAAA,CACJ;AAED,eAAO,KAAK;MAAA;MAGT,gBAAgB,KACvB;AACI,eAAO,KAAK,KAAK,mBAAmB,CAAC,GAAG,CAAC;MAAA;MAG7C,MAAc,eACd;AACI,YAAI,KAAK;AAAc;AAEvB,aAAK,eAAe;MAAA;MAGxB,YACA;AACI,YAAI,gBAAgB,QACpB;AACI,wBAAc,UAAU,uBAAuB;QAAA;AAE/C,YAAA,SAAS,KAAK,WAAW,IAAI;AAEjC,YAAI,CAAC,UAAU,KAAK,kBAAkB,aACtC;AACI,cAAI,CAAC,WACL;AACI,wBAAY,IAAI,gBAAgB,IAAI,KAAK,CAAC,WAAW,IAAI,GAAG,EAAE,MAAM,yBAAyB,CAAC,CAAC;UAAA;AAI9F,eAAA;AACI,mBAAA,IAAI,OAAO,SAAS;AAEtB,iBAAA,iBAAiB,WAAW,CAAC,UACpC;AACS,iBAAA,SAAS,MAAM,IAAI;AAEnB,iBAAA,aAAa,MAAM,MAAgB;AACxC,iBAAK,KAAK;UAAA,CACb;QAAA;AAGE,eAAA;MAAA;MAGH,aAAa,QACrB;AACS,aAAA,WAAW,KAAK,MAAM;MAAA;MAGvB,SAAS,MACjB;AACQ,YAAA,KAAK,UAAU,QACnB;AACI,eAAK,YAAY,KAAK,IAAM,EAAA,OAAO,KAAK,KAAK;QAAA,OAGjD;AACI,eAAK,YAAY,KAAK,IAAM,EAAA,QAAQ,KAAK,IAAI;QAAA;AAG5C,aAAA,YAAY,KAAK,IAAQ,IAAA;MAAA;MAGlC,MAAc,KAAK,IAAY,MAC/B;AACI,cAAM,KAAK,aAAa;AAGxB,cAAM,UAAU,IAAI,QAAQ,CAAC,SAAS,WACtC;AACS,eAAA,MAAM,KAAK,EAAE,IAAI,WAAW,MAAM,SAAS,OAAA,CAAQ;QAAA,CAC3D;AAED,aAAK,KAAK;AAEH,eAAA;MAAA;MAGX,OACA;AAEQ,YAAA,CAAC,KAAK,MAAM;AAAQ;AAElB,cAAA,SAAS,KAAK,UAAU;AAG9B,YAAI,CAAC,QACL;AACI;QAAA;AAGE,cAAA,OAAO,KAAK,MAAM,IAAI;AAE5B,cAAM,KAAK,KAAK;AAEX,aAAA,YAAY,IAAA,IAAQ,EAAE,SAAS,KAAK,SAAS,QAAQ,KAAK,OAAO;AAEtE,eAAO,YAAY;UACf,MAAM,KAAK;UACX,MAAM;UACN;QAAA,CACH;MAAA;IAET;AAEM,IAAA,gBAAgB,IAAI,mBAAmB;;;;;ACnL7C,eAAA,gBAAsC,KACtC;AACI,QAAM,WAAW,MAAM,SAAS,QAAQ,MAAM,GAAG;AAE7C,MAAA,CAAC,SAAS,IACd;AACI,UAAM,IAAI,MAAM,qCAAqC,GAAA,KAC5C,SAAS,MAAA,IAAU,SAAS,UAAY,EAAA;EAAA;AAG/C,QAAA,YAAY,MAAM,SAAS,KAAK;AAChC,QAAA,cAAc,MAAM,kBAAkB,SAAS;AAE9C,SAAA;AACX;IAxDM,sBACA,iBA8EO;;;;;;;;;AA/Eb,IAAM,uBAAuB,CAAC,SAAS,QAAQ,QAAQ,SAAS,OAAO;AACvE,IAAM,kBAAkB;MACpB;MACA;MACA;MACA;IACJ;AAyEO,IAAM,eAAe;MAExB,MAAM;MAEN,WAAW;QACP,MAAM,cAAc;QACpB,UAAU,qBAAqB;MAAA;MAGnC,QAAQ;QACJ,eAAe;QACf,yBAAyB;QACzB,aAAa;MAAA;MAGjB,KAAK,KACL;AACI,eAAO,aAAa,KAAK,eAAe,KAAK,eAAe,KAAK,oBAAoB;MAAA;MAGzF,MAAM,KAAK,KAAa,OAAuC,QAC/D;AACI,YAAI,MAAW;AAEf,YAAI,WAAW,qBAAqB,KAAK,OAAO,yBAChD;AACI,cAAI,KAAK,OAAO,iBAAiB,MAAM,cAAc,uBAAA,GACrD;AACU,kBAAA,MAAM,cAAc,gBAAgB,GAAG;UAAA,OAGjD;AACU,kBAAA,MAAM,gBAAgB,GAAG;UAAA;QACnC,OAGJ;AACI,gBAAM,MAAM,IAAI,QAAQ,CAAC,YACzB;AACI,kBAAM,IAAI,MAAM;AACZ,gBAAA,cAAc,KAAK,OAAO;AAE9B,gBAAI,MAAM;AACV,gBAAI,IAAI,UACR;AACI,sBAAQ,GAAG;YAAA,OAGf;AACI,kBAAI,SAAS,MACb;AACI,wBAAQ,GAAG;cAAA;YACf;UACJ,CACH;QAAA;AAGC,cAAA,OAAO,IAAI,YAAY,KAAK;UAC9B,YAAY,YAAM,mBAAmB,GAAG;UACxC,GAAG,MAAM;QAAA,CACZ;AAED,aAAK,SAAS,MAAM;AAEb,eAAA,cAAc,MAAM,QAAQ,GAAG;MAAA;MAG1C,OAAO,SACP;AACI,gBAAQ,QAAQ,IAAI;MAAA;IAE5B;AAEA,eAAW,IAAI,YAAY;;;;;ICxJrB,mBACA,cAGO;;;;;;;;;AAJb,IAAM,oBAAoB;AAC1B,IAAM,eAAe;AAGd,IAAM,UAAU;MACnB,WAAW;QACP,MAAM,cAAc;QACpB,UAAU,qBAAqB;MAAA;MAGnC,MAAM;MAEN,KAAK,KACL;AACI,eAAO,aAAa,KAAK,YAAY,KAAK,eAAe,KAAK,iBAAiB;MAAA;MAGnF,MAAM,UAAU,MAChB;AACW,eAAA,YAAY,KAAK,IAAI;MAAA;MAGhC,MAAM,MAAM,OAAe,MAAsC,QACjE;;AACI,cAAM,MAAM,IAAI,YAAY,QAAO,kCAAM,SAAN,mBAAY,eAAe;AAE9D,cAAM,IAAI,KAAK;AAET,cAAA,OAAO,IAAI,YAAY,KAAK;UAC9B,YAAY,YAAM,mBAAmB,KAAK;UAC1C,GAAG,6BAAM;QAAA,CACZ;AAED,aAAK,SAAS,MAAM;AAEpB,cAAM,UAAU,cAAc,MAAM,QAAQ,KAAK;AAE1C,eAAA;MAAA;MAGX,MAAM,KAAK,KAAa,UACxB;AACI,cAAM,WAAW,MAAM,SAAS,QAAQ,MAAM,GAAG;AAEjD,eAAO,SAAS,KAAK;MAAA;MAGzB,QAAQ,aAAa;IAEzB;AAEA,eAAW,IAAI,OAAO;;;;;ACxDf,IAAM;AAAN;;IAAM,mBAAN,MACP;MAqBI,YAAY,QAAgB,UAAU,OACtC;AACI,aAAK,UAAU;AACf,aAAK,aAAa,CAAA;AAClB,aAAK,aAAa;AAClB,aAAK,iBAAiB;AACtB,aAAK,UAAU;MAAA;MAOZ,IAAI,WACX;AACc,kBAAA,QAAQ,CAAC,MACnB;AACS,eAAA,WAAW,KAAK,CAAC;QAAA,CACzB;AAGD,YAAI,KAAK;AAAgB,kBAAA,IAAI,+BAA+B,KAAK,UAAU;AAE3E,YAAI,KAAK,aAAa,CAAC,KAAK,YAC5B;AACI,eAAK,MAAM;QAAA;MACf;MAQJ,MAAc,QACd;AACI,YAAI,KAAK,WAAW,UAAU,KAAK,WACnC;AACI,eAAK,aAAa;AAElB,gBAAM,SAAS,CAAA;AAEf,gBAAM,eAAe,KAAK,IAAI,KAAK,WAAW,QAAQ,KAAK,cAAc;AAEzE,mBAAS,IAAI,GAAG,IAAI,cAAc,KAClC;AACI,mBAAO,KAAK,KAAK,WAAW,IAAA,CAAK;UAAA;AAG/B,gBAAA,KAAK,QAAQ,KAAK,MAAM;AAE9B,eAAK,aAAa;AAElB,eAAK,MAAM;QAAA;MACf;MAOJ,IAAI,SACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,OAAO,OACX;AACI,YAAI,KAAK,cAAc;AAAO;AAE9B,aAAK,YAAY;AAEb,YAAA,SAAS,CAAC,KAAK,YACnB;AACI,eAAK,MAAM;QAAA;MACf;IAER;;;;;ICzFa;;;;;;;AAAN,IAAM,SAAN,MACP;MADO,cAAA;AAEH,aAAQ,WAA2B,CAAA;AAGnC,aAAQ,oBAAoB;AAG5B,aAAO,UAAU,IAAI,MAAM,KAAK,UAAU;UACtC,KAAK,CAAC,QAAQ,KAAK,UACnB;AACI,iBAAK,oBAAoB;AAEzB,mBAAO,GAAwB,IAAA;AAExB,mBAAA;UAAA;QACX,CACH;AAGD,aAAO,eAAiD,CAAA;MAAC;MAGzD,QACA;AACI,aAAK,oBAAoB;AACzB,aAAK,eAAe,CAAA;MAAC;MASjB,yBAAyB,KAAa,MAC9C;AACI,cAAM,SAA2B;UAC7B,SAAS;UACT,QAAQ;QAAA;AAGZ,eAAO,WACP,YAAA;;AACI,cAAI,QAAQ;AAEZ,cAAI,SAAuB;AAG3B,cAAI,KAAK,YACT;AAEa,qBAAA,KAAK,YAAY,KAAK,UAAA;AAE/B,gBAAI,CAAC,QACL;AAGI,sBAAQ,KAAK,mCAAmC,KAAK,UAAA,6BAAuC,GAAK,EAAA;YAAA;UAErG;AAIJ,cAAI,CAAC,QACL;AACI,qBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACU,oBAAA,UAAU,KAAK,QAAQ,CAAA;AAE7B,kBAAI,QAAQ,UAAQ,aAAQ,SAAR,iCAAe,KAAK,MAAM,QAC9C;AACa,yBAAA;AACT;cAAA;YACJ;AAGJ,gBAAI,CAAC,QACL;AAGY,sBAAA,KAAK,YAAY,GAAoG,iGAAA;AAGtH,qBAAA;YAAA;UACX;AAGJ,kBAAQ,MAAM,OAAO,KAAK,KAAK,MAAM,IAAI;AACzC,iBAAO,SAAS;AAEhB,mBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACU,kBAAA,UAAS,KAAK,QAAQ,CAAA;AAE5B,gBAAI,QAAO,OACX;AACQ,kBAAA,QAAO,SAAS,QAAM,aAAO,cAAP,iCAAmB,OAAO,MAAM,QAC1D;AAEI,wBAAQ,MAAM,QAAO,MAAM,OAAO,MAAM,IAAI,KAAK;AAEjD,uBAAO,SAAS;cAAA;YACpB;UACJ;AAGG,iBAAA;QAAA,GACR;AAEI,eAAA;MAAA;MA2BX,MAAa,KACT,gBACA,YAEJ;AACQ,YAAA,CAAC,KAAK,mBACV;AACI,eAAK,iBAAiB;QAAA;AAG1B,YAAI,QAAQ;AAEZ,cAAM,SAAuC,CAAA;AAEvC,cAAA,cAAc,aAAa,cAAc;AAE/C,cAAM,eAAe,cAAyB,gBAAgB,CAAC,UAAU;UACrE,KAAK;QAAA,EACP;AAEF,cAAM,QAAQ,aAAa;AAE3B,cAAM,WAA4B,aAAa,IAAI,OAAO,UAC1D;AACI,gBAAM,MAAM,YAAM,KAAK,WAAW,MAAM,GAAG;AAEvC,cAAA,CAAC,OAAO,MAAM,GAClB,GAAA;AAEI,gBAAA;AACQ,kBAAA,CAAC,KAAK,aAAa,GACvB,GAAA;AACI,qBAAK,aAAa,GAAA,IAAO,KAAK,yBAAyB,KAAK,KAAK;cAAA;AAGrE,qBAAO,MAAM,GAAA,IAAO,MAAM,KAAK,aAAa,GAAK,EAAA;AAG7C,kBAAA;AAAuB,2BAAA,EAAE,QAAQ,KAAK;YAAA,SAEvC,GAAP;AAII,qBAAO,KAAK,aAAa,GAAA;AACzB,qBAAO,OAAO,MAAM,GAAA;AAGd,oBAAA,IAAI,MAAM,gCAAgC,GAAA;EAAS,CAAG,EAAA;YAAA;UAChE;QACJ,CACH;AAEK,cAAA,QAAQ,IAAI,QAAQ;AAE1B,eAAO,cAAc,OAAO,aAAa,CAAA,EAAG,GAAO,IAAA;MAAA;MAevD,MAAa,OACT,kBAEJ;AACI,cAAM,iBAAiB,cAAyB,kBAAkB,CAAC,UAAU;UACzE,KAAK;QAAA,EACP;AAEF,cAAM,WAA4B,eAAe,IAAI,OAAO,UAC5D;;AACI,gBAAM,MAAM,YAAM,KAAK,WAAW,MAAM,GAAG;AAErC,gBAAA,cAAc,KAAK,aAAa,GAAA;AAEtC,cAAI,aACJ;AACU,kBAAA,cAAc,MAAM,YAAY;AAEtC,oCAAY,WAAZ,mBAAoB,WAApB,4BAA6B,aAAa,OAAO;AAEjD,mBAAO,KAAK,aAAa,GAAA;UAAA;QAC7B,CACH;AAEK,cAAA,QAAQ,IAAI,QAAQ;MAAA;MAI9B,mBACA;AACI,aAAK,oBAAoB;AAEzB,aAAK,cAAc,KAAK,SACnB,OAAO,CAAC,WAAW,OAAO,IAAI,EAC9B,OAAO,CAAC,MAAM,WACf;AACQ,cAAA,KAAK,OAAO,IAChB,GAAA;AAEY,oBAAA,KAAK,sCAAsC,OAAO,IAAO,GAAA;UAAA;AAIrE,iBAAO,EAAE,GAAG,MAAM,CAAC,OAAO,IAAA,GAAO,OAAO;QAAA,GACzC,CAAA,CAAkC;MAAA;IAEjD;;;;;AC9QA,IAAAC,cAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AACA;AACA,IAAAC;AAAA;AAAA;;;ACFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;ICyDa;;;;;;;AAAN,IAAM,WAAN,MACP;MADO,cAAA;AAEH,aAAQ,kCAAqE;UACzE,WAAW;UACX,qBAAqB,CAAC,UAAU,YAC5B,GAAG,QAAA,GAAW,KAAK,kBAAqB,GAAA,OAAA;UAC5C,0BAA0B,CAAC,UAAU,kBACjC,cAAc,QAAQ,GAAG,QAAA,GAAW,KAAK,kBAAA,IAAsB,EAAE;QAAA;AAIjE,aAAA,qBAAqB,KAAK,gCAAgC;AAQ1D,aAAA,uBAGM,KAAK,gCAAgC;AAQ3C,aAAA,4BAGM,KAAK,gCAAgC;AAEnD,aAAQ,YAA4C,CAAA;AACpD,aAAQ,kBAAiC,CAAA;AACzC,aAAQ,WAA+B,CAAA;AAEvC,aAAQ,gBAA8C,CAAA;AAItD,aAAQ,WAAqC,CAAA;MAAC;MAQvC,oBAAoB,kBAC3B;AACS,aAAA,qBAAqB,iBAAiB,aAAa,KAAK;AACxD,aAAA,uBAAuB,iBAAiB,uBAAuB,KAAK;AACpE,aAAA,4BAA4B,iBAAiB,4BAA4B,KAAK;AAE/E,YAAA,KAAK,0BAA0B,OAAO,KAAK,qBAAqB,OAAO,KAAK,CAAC,MAAM,OACvF;AACU,gBAAA,IAAI,MAAM,4DAA4D;QAAA;MAChF;MAmBG,UAAU,cACjB;AACiB,qBAAA,QAAQ,CAAC,WACtB;AACS,eAAA,gBAAgB,KAAK,MAAM;AAE5B,cAAA,CAAC,OAAO,UACZ;AAEI,mBAAO,WAAW,OAAO,KAAK,OAAO,MAAM;UAAA;QAC/C,CACH;AAED,aAAK,gBAAgB,CAAA;MAAC;MAW1B,IAAW,SAAS,UACpB;AACI,aAAK,YAAY;MAAA;MAGrB,IAAW,WACX;AACI,eAAO,KAAK;MAAA;MAchB,IAAW,SAAS,UACpB;AACI,aAAK,YAAY;MAAA;MAGrB,IAAW,WACX;AACI,eAAO,KAAK;MAAA;MAwChB,IAAW,UACX;AACI,eAAO,KAAK;MAAA;MAIhB,QACA;AACS,aAAA,oBAAoB,KAAK,+BAA+B;AAE7D,aAAK,YAAY,CAAA;AACjB,aAAK,kBAAkB,CAAA;AAGvB,aAAK,gBAAgB,CAAA;AACrB,aAAK,YAAY;AACjB,aAAK,YAAY;AACjB,aAAK,YAAY;AACjB,aAAK,WAAW,CAAA;AAChB,aAAK,uBAAuB;MAAA;MAOzB,uBAAuB,cAC9B;AACQ,YAAA,OAAO,iBAAiB,UAC5B;AACI,eAAK,uBAAuB;QAAA,OAGhC;AACI,gBAAM,cAAc;AAEpB,eAAK,uBAAuB,OAAO,KAAK,WAAW,EAC9C,IAAI,CAAC,QAAQ,GAAG,mBAAmB,GAAG,CAAA,IAAK,mBAAmB,YAAY,GAAA,CAAI,CAAG,EAAA,EACjF,KAAK,GAAG;QAAA;MACjB;MAQG,YAAY,UACnB;AACI,YAAI,KAAK,WACT;AAEI,kBAAQ,KAAK,8DAA8D;QAAA;AAI/E,aAAK,YAAY;AAER,iBAAA,QAAQ,QAAQ,CAAC,WAC1B;AACI,eAAK,UAAU,OAAO,MAAM,OAAO,MAAM;QAAA,CAC5C;MAAA;MAiBE,UAAU,UAAkB,QACnC;AACI,cAAM,aAAuB,CAAA;AAMzB,YAAA,MAAM,QAAQ,MAAM,GACxB;AACW,iBAAA,QAAQ,CAAC,UAChB;AACQ,gBAAA,OAAO,MAAM,SAAS,UAC1B;AACI,oBAAM,gBAAgB,KAAK,qBAAqB,UAAU,MAAM,IAAI;AAEpE,yBAAW,KAAK,aAAa;AAExB,mBAAA,IAAI,CAAC,MAAM,MAAM,aAAa,GAAG,MAAM,MAAM,MAAM,IAAI;YAAA,OAGhE;AACU,oBAAA,YAAY,MAAM,KAAK,IAAI,CAAC,SAAS,KAAK,qBAAqB,UAAU,IAAI,CAAC;AAE1E,wBAAA,QAAQ,CAAC,cACnB;AACI,2BAAW,KAAK,SAAQ;cAAA,CAC3B;AAEI,mBAAA,IAAI,CAAC,GAAG,MAAM,MAAM,GAAG,SAAS,GAAG,MAAM,IAAI;YAAA;UACtD,CACH;QAAA,OAGL;AACI,iBAAO,KAAK,MAAM,EAAE,QAAQ,CAAC,QAC7B;AACI,uBAAW,KAAK,KAAK,qBAAqB,UAAU,GAAG,CAAC;AACnD,iBAAA,IAAI,CAAC,KAAK,KAAK,qBAAqB,UAAU,GAAG,CAAC,GAAG,OAAO,GAAI,CAAA;UAAA,CACxE;QAAA;AAGL,aAAK,SAAS,QAAY,IAAA;MAAA;MAgC9B,IAAW,QAA2B,UAA6D,MACnG;AACU,cAAA,OAAiB,cAAsB,MAAM;AAE9C,aAAA,QAAQ,CAAC,QACd;AACQ,cAAA,KAAK,OAAO,GAAG,GACnB;AAEY,oBAAA,KAAK,+BAA+B,GAAiB,cAAA;UAAA;QAEjE,CACH;AAED,YAAI,CAAC,MAAM,QAAQ,QAAQ,GAC3B;AACQ,cAAA,OAAO,aAAa,UACxB;AACI,uBAAW,uBAAuB,QAAQ;UAAA,OAG9C;AACI,uBAAW,CAAC,QAAQ;UAAA;QACxB;AAGJ,cAAM,WAA2B,SAAS,IAAI,CAAC,UAC/C;AACI,cAAI,iBAAiB;AAGjB,cAAA,OAAO,UAAU,UACrB;AAGI,gBAAI,SAAS;AAEb,qBAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAC1C;AACU,oBAAA,SAAS,KAAK,SAAS,CAAA;AAEzB,kBAAA,OAAO,KAAK,KAAK,GACrB;AACqB,iCAAA,OAAO,MAAM,KAAK;AAC1B,yBAAA;AACT;cAAA;YACJ;AAGJ,gBAAI,CAAC,QACL;AACqB,+BAAA;gBACb,KAAK;cAAA;YACT;UACJ;AAGA,cAAA,CAAC,eAAe,QACpB;AACI,2BAAe,SAAS,eAAe,IAAI,MAAM,GAAG,EAAE,IAAI;UAAA;AAG1D,cAAA,CAAC,eAAe,OACpB;AACI,2BAAe,QAAQ;UAAA;AAGvB,cAAA,KAAK,aAAa,KAAK,WAC3B;AACmB,2BAAA,MAAM,YAAM,KAAK,WAAW,eAAe,KAAK,KAAK,WAAW,KAAK,SAAS;UAAA;AAGjG,yBAAe,MAAM,KAAK,2BAA2B,eAAe,GAAG;AAExD,yBAAA,OAAO,eAAe,QAAQ;AAEtC,iBAAA;QAAA,CACV;AAEI,aAAA,QAAQ,CAAC,QACd;AACI,eAAK,UAAU,GAAO,IAAA;QAAA,CACzB;MAAA;MA4CE,cAAc,WAErB;AACU,cAAA,cAAc,aAAa,SAAS;AAE1C,oBAAY,cAAsB,SAAS;AAE3C,cAAM,MAAoD,CAAA;AAEhD,kBAAA,QAAQ,CAAC,aACnB;AACU,gBAAA,aAAa,KAAK,SAAS,QAAA;AAEjC,cAAI,YACJ;AACU,kBAAA,UAAU,KAAK,QAAQ,UAAU;AAEvC,kBAAM,SAAuC,CAAA;AAE7C,uBAAW,OAAO,SAClB;AACI,oBAAM,QAAQ,QAAQ,GAAA;AAEtB,qBAAO,KAAK,0BAA0B,UAAU,GAAG,CAAK,IAAA;YAAA;AAG5D,gBAAI,QAAY,IAAA;UAAA;QACpB,CACH;AAEM,eAAA,cAAc,IAAI,UAAU,CAAM,CAAA,IAAA;MAAA;MAQtC,WAAW,KAClB;AACU,cAAA,SAAS,KAAK,QAAQ,GAAG;AAE3B,YAAA,OAAO,QAAQ,UACnB;AACI,gBAAM,MAA8B,CAAA;AAEpC,qBAAW,KAAK,QAChB;AACQ,gBAAA,CAAA,IAAM,OAAwC,CAAG,EAAA;UAAA;AAGlD,iBAAA;QAAA;AAGX,eAAQ,OAAwB;MAAA;MAkB7B,QAAQ,MACf;AACU,cAAA,cAAc,aAAa,IAAI;AAErC,eAAO,cAAsB,IAAI;AAEjC,cAAM,SAAuC,CAAA;AAExC,aAAA,QAAQ,CAAC,QACd;AACQ,cAAA,CAAC,KAAK,cAAc,GACxB,GAAA;AACQ,gBAAA,KAAK,UAAU,GACnB,GAAA;AACQ,kBAAA,SAAS,KAAK,UAAU,GAAA;AAEtB,oBAAA,iBAAiB,KAAK,mBAAmB,MAAM;AAErD,oBAAM,YAAY,OAAO,CAAA;AAET,+DAAA,SAAS,QAAQ,CAAC,gBAClC;AACI,+BAAe,OAAO,WAAA,EAAa,QAAQ,CAAC,UAC5C;AACI,wBAAM,iBAAiB,OAAO,OAAO,CAAC,UACtC;AACI,wBAAI,MAAM,WACV,GAAA;AACI,6BAAO,MAAM,WAAiB,MAAA;oBAAA;AAG3B,2BAAA;kBAAA,CACV;AAED,sBAAI,eAAe,QACnB;AACa,6BAAA;kBAAA;gBACb,CACH;cAAA;AAGA,mBAAA,cAAc,GAAQ,IAAA,OAAO,CAAM,KAAA;YAAA,OAG5C;AACI,kBAAI,MAAM;AAEN,kBAAA,KAAK,aAAa,KAAK,WAC3B;AACI,sBAAM,YAAM,KAAK,WAAW,KAAK,KAAK,WAAW,KAAK,SAAS;cAAA;AAI7D,oBAAA,KAAK,2BAA2B,GAAG;AAGzC,mBAAK,cAAc,GAAO,IAAA;gBACtB;cAAA;YACJ;UACJ;AAGG,iBAAA,GAAA,IAAO,KAAK,cAAc,GAAA;QAAA,CACpC;AAEM,eAAA,cAAc,OAAO,KAAK,CAAM,CAAA,IAAA;MAAA;MAOpC,OAAO,KACd;AACW,eAAA,CAAC,CAAC,KAAK,UAAU,GAAA;MAAA;MAOrB,UAAU,KACjB;AACW,eAAA,CAAC,CAAC,KAAK,SAAS,GAAA;MAAA;MAOnB,mBAAmB,QAC3B;AACI,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KACnC;AACI,gBAAM,QAAQ,OAAO,CAAA;AAErB,gBAAM,YAAY,KAAK,gBAAgB,KAAK,CAAC,eACzC,WAAW,OAAO,OAAO,SAAS,MAAM,MAAM,CAAC;AAEnD,cAAI,WACJ;AACW,mBAAA;UAAA;QACX;AAGJ,eAAO,KAAK,gBAAgB,CAAA;MAAA;MAQxB,2BAA2B,KACnC;AACI,YAAI,CAAC,KAAK;AAA6B,iBAAA;AAEvC,cAAM,iBAAkB,KAAM,KAAK,GAAG,IAAI,MAAM;AAEzC,eAAA,GAAG,GAAM,GAAA,cAAA,GAAiB,KAAK,oBAAA;MAAA;IAE9C;;;;;IC5ea,aA4pBA;;;;;;;;;;;;AA5pBN,IAAM,cAAN,MACP;MAqBI,cACA;AALA,aAAQ,cAAuC,CAAA;AAE/C,aAAQ,eAAe;AAId,aAAA,WAAW,IAAI,SAAS;AACxB,aAAA,SAAS,IAAI,OAAO;AACzB,aAAK,QAAQ;AAEb,aAAK,oBAAoB,IAAI,iBAAiB,KAAK,MAAM;AACzD,aAAK,kBAAkB,SAAS;AAEhC,aAAK,MAAM;MAAA;MAUf,MAAa,KAAK,UAA4B,CAAA,GAC9C;;AACI,YAAI,KAAK,cACT;AAEI,kBAAQ,KAAK,0FAA0F;AAGvG;QAAA;AAGJ,aAAK,eAAe;AAEpB,YAAI,QAAQ,qBACZ;AACS,eAAA,SAAS,uBAAuB,QAAQ,mBAAmB;QAAA;AAGpE,YAAI,QAAQ,UACZ;AACS,eAAA,SAAS,WAAW,QAAQ;QAAA;AAGrC,YAAI,QAAQ,kBACZ;AACS,eAAA,SAAS,oBAAoB,QAAQ,gBAAgB;QAAA;AAG9D,YAAI,QAAQ,UACZ;AACI,cAAI,WAAW,QAAQ;AAEnB,cAAA,OAAO,aAAa,UACxB;AACe,uBAAA,MAAM,KAAK,KAAuB,QAAQ;UAAA;AAGpD,eAAA,SAAS,YAAY,QAAQ;QAAA;AAGhC,cAAA,mBAAiB,aAAQ,sBAAR,mBAA2B,eAAc;AAChE,cAAM,aAAc,OAAO,mBAAmB,WAAY,CAAC,cAAc,IAAI;AAE7E,YAAIC,WAAoB,CAAA;AAEpB,aAAA,aAAQ,sBAAR,mBAA2B,QAC/B;AACU,gBAAA,cAAa,aAAQ,sBAAR,mBAA2B;AAE9C,UAAAA,WAAW,OAAO,eAAe,WAAY,CAAC,UAAU,IAAI;AAGjD,qBAAA,aAAa,KAAK,aAC7B;AACI,gBAAI,CAAC,MAAM,UAAU,KAAA,GACrB;AACc,cAAAA,WAAA,MAAM,UAAU,OAAOA,QAAO;YAAA;UAC5C;QACJ,OAGJ;AAEe,qBAAA,aAAa,KAAK,aAC7B;AACQ,gBAAA,MAAM,UAAU,KAAA,GACpB;AACc,cAAAA,WAAA,MAAM,UAAU,IAAIA,QAAO;YAAA;UACzC;QACJ;AAGJ,aAAK,SAAS,OAAO;UACjB,QAAQ;YACJ,QAAQA;YACR;UAAA;QACJ,CACH;AAED,YAAI,QAAQ,aACZ;AACS,eAAA,eAAe,QAAQ,WAAW;QAAA;MAC3C;MAsDJ,IAAW,QAA2B,UAA8C,MACpF;AACI,aAAK,SAAS,IAAI,QAAQ,UAAU,IAAI;MAAA;MAmC5C,MAAa,KACT,MACA,YAEJ;AACQ,YAAA,CAAC,KAAK,cACV;AACI,gBAAM,KAAK,KAAK;QAAA;AAGd,cAAA,cAAc,aAAa,IAAI;AAErC,cAAM,WAAW,cAA4B,IAAI,EAC5C,IAAI,CAAC,QACN;AACQ,cAAA,OAAO,QAAQ,UACnB;AACI,iBAAK,SAAS,IAAI,IAAI,KAAe,GAAG;AAExC,mBAAO,IAAI;UAAA;AAGf,cAAI,CAAC,KAAK,SAAS,OAAO,GAAG,GAC7B;AACS,iBAAA,SAAS,IAAI,KAAK,GAAG;UAAA;AAGvB,iBAAA;QAAA,CACV;AAGL,cAAM,iBAAiB,KAAK,SAAS,QAAQ,QAAQ;AAGrD,cAAM,MAAyB,MAAM,KAAK,kBAAqB,gBAAgB,UAAU;AAElF,eAAA,cAAc,IAAI,SAAS,CAAgB,CAAA,IAAA;MAAA;MAmB/C,UAAU,UAAkB,QACnC;AACS,aAAA,SAAS,UAAU,UAAU,MAAM;MAAA;MAuD5C,MAAa,WAAW,WAA8B,YACtD;AACQ,YAAA,CAAC,KAAK,cACV;AACI,gBAAM,KAAK,KAAK;QAAA;AAGpB,YAAI,cAAc;AAEd,YAAA,OAAO,cAAc,UACzB;AACkB,wBAAA;AACd,sBAAY,CAAC,SAAS;QAAA;AAG1B,cAAM,iBAAiB,KAAK,SAAS,cAAc,SAAS;AAE5D,cAAM,MAA2C,CAAA;AAE3C,cAAA,OAAO,OAAO,KAAK,cAAc;AACvC,YAAI,QAAQ;AACZ,YAAI,QAAQ;AACZ,cAAM,cAAc,MACpB;AACiB,mDAAA,EAAE,QAAQ;QAAK;AAEhC,cAAM,WAAW,KAAK,IAAI,CAAC,aAC3B;AACI,gBAAM,gBAAgB,eAAe,QAAA;AAE5B,mBAAA,OAAO,KAAK,aAAa,EAAE;AAEpC,iBAAO,KAAK,kBAAkB,eAAe,WAAW,EACnD,KAAK,CAAC,mBACP;AACI,gBAAI,QAAY,IAAA;UAAA,CACnB;QAAA,CACR;AAEK,cAAA,QAAQ,IAAI,QAAQ;AAEnB,eAAA,cAAc,IAAI,UAAU,CAAM,CAAA,IAAA;MAAA;MAmB7C,MAAa,eAAe,MAC5B;AACQ,YAAA,CAAC,KAAK,cACV;AACI,gBAAM,KAAK,KAAK;QAAA;AAGhB,YAAA,OAAO,SAAS,UACpB;AACI,iBAAO,CAAC,IAAI;QAAA;AAGhB,cAAM,iBAAiB,KAAK,SAAS,QAAQ,IAAI;AAEjD,aAAK,kBAAkB,IAAI,OAAO,OAAO,cAAc,CAAC;MAAA;MA2B5D,MAAa,qBAAqB,WAClC;AACQ,YAAA,CAAC,KAAK,cACV;AACI,gBAAM,KAAK,KAAK;QAAA;AAGhB,YAAA,OAAO,cAAc,UACzB;AACI,sBAAY,CAAC,SAAS;QAAA;AAG1B,cAAM,iBAAiB,KAAK,SAAS,cAAc,SAAS;AAE5D,eAAO,OAAO,cAAc,EAAE,QAAQ,CAAC,kBACvC;AACI,eAAK,kBAAkB,IAAI,OAAO,OAAO,aAAa,CAAC;QAAA,CAC1D;MAAA;MAQL,QACA;AACI,aAAK,SAAS,MAAM;AACpB,aAAK,OAAO,MAAM;AAClB,aAAK,MAAM,MAAM;AAEjB,aAAK,eAAe;MAAA;MAYjB,IAAa,MACpB;AACQ,YAAA,OAAO,SAAS,UACpB;AACW,iBAAA,MAAM,IAAI,IAAI;QAAA;AAGzB,cAAM,SAA4B,CAAA;AAElC,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KACjC;AACI,iBAAO,CAAK,IAAA,MAAM,IAAI,KAAK,CAAE,CAAA;QAAA;AAG1B,eAAA;MAAA;MAQX,MAAc,kBACV,gBACA,YAEJ;AACU,cAAA,eAAe,OAAO,OAAO,cAAc;AAC3C,cAAA,cAAc,OAAO,KAAK,cAAc;AAG9C,aAAK,kBAAkB,SAAS;AAEhC,cAAM,eAAe,MAAM,KAAK,OAAO,KAAQ,cAAc,UAAU;AAGvE,aAAK,kBAAkB,SAAS;AAIhC,cAAM,MAAyB,CAAA;AAElB,qBAAA,QAAQ,CAAC,eAAe,MACrC;AACU,gBAAA,QAAQ,aAAa,cAAc,GAAA;AAEnC,gBAAA,OAAO,CAAC,cAAc,GAAG;AAE/B,cAAI,cAAc,OAClB;AACS,iBAAA,KAAK,GAAG,cAAc,KAAK;UAAA;AAGpC,cAAI,YAAY,CAAM,CAAA,IAAA;AAEhB,gBAAA,IAAI,MAAM,KAAK;QAAA,CACxB;AAEM,eAAA;MAAA;MA0BX,MAAa,OACT,MAEJ;AACQ,YAAA,CAAC,KAAK,cACV;AACI,gBAAM,KAAK,KAAK;QAAA;AAGpB,cAAM,WAAW,cAAkC,IAAI,EAClD,IAAI,CAAC,QACA,OAAO,QAAQ,WAAY,IAAI,MAAM,GAAI;AAGnD,cAAM,iBAAiB,KAAK,SAAS,QAAQ,QAAQ;AAE/C,cAAA,KAAK,oBAAoB,cAAc;MAAA;MAwBjD,MAAa,aAAa,WAC1B;AACQ,YAAA,CAAC,KAAK,cACV;AACI,gBAAM,KAAK,KAAK;QAAA;AAGpB,oBAAY,cAAsB,SAAS;AAE3C,cAAM,iBAAiB,KAAK,SAAS,cAAc,SAAS;AAE5D,cAAM,WAAW,OAAO,KAAK,cAAc,EAAE,IAAI,CAAC,aAC9C,KAAK,oBAAoB,eAAe,QAAA,CAAS,CAAC;AAEhD,cAAA,QAAQ,IAAI,QAAQ;MAAA;MAG9B,MAAc,oBAAoB,eAClC;AACU,cAAA,eAAe,OAAO,OAAO,aAAa;AAEnC,qBAAA,QAAQ,CAAC,mBACtB;AACU,gBAAA,OAAO,eAAc,GAAG;QAAA,CACjC;AAEK,cAAA,KAAK,OAAO,OAAO,YAAY;MAAA;MAIzC,IAAW,aACX;AACI,eAAO,KAAK;MAAA;MAOhB,IAAW,gBACX;AACI,eAAO,aAAa,OAAO;MAAA;MAE/B,IAAW,cAAc,OACzB;AAEU,oBAAA,YAAY,SAAS,kGACwC;AAEnE,aAAK,eAAe,EAAE,eAAe,MAAA,CAAO;MAAA;MAOzC,eAAe,aACtB;AAGI,aAAK,OAAO,QAAQ,QAAQ,CAAC,WAC7B;AACI,cAAI,CAAC,OAAO;AAAQ;AAEnB,iBAAO,KAAK,OAAO,MAAM,EACrB,OAAO,CAAC,QAAQ,OAAO,WAAW,EAClC,QAAQ,CAAC,QACV;AACW,mBAAA,OAAO,GAAA,IAAO,YAAY,GAAA;UAAA,CACpC;QAAA,CACR;MAAA;IAET;AAEa,IAAA,SAAS,IAAI,YAAY;AAGtC,eACK,aAAa,cAAc,YAAY,OAAO,OAAO,OAAO,EAC5D,aAAa,cAAc,eAAe,OAAO,SAAS,OAAO,EACjE,aAAa,cAAc,aAAa,OAAO,MAAM,OAAO,EAC5D,aAAa,cAAc,iBAAiB,OAAO,UAAU;;;;;ICl3BrD;;;;AAAN,IAAM,oBAA4C;MACrD,WAAW,cAAc;MAEzB,MAAM,CAAC,UAAiB,MAAM,QAAQ,KAAK,KAAK,MAAM,MAAM,CAAC,MAAM,aAAa,OAAO;MAEvF,oBAAoB,CAAC,MAAgB,UACrC;AACI,cAAM,MAA+B,CAAA;AAEhC,aAAA,QAAQ,CAAC,QACd;AACU,gBAAA,QAAQ,CAAC,MAAe,MAC9B;AACI,gBAAI,OAAO,MAAM,IAAI,KAAK,IAAI,EAAM,IAAA;UAAA,CACvC;QAAA,CACJ;AAEM,eAAA;MAAA;IAEf;AAEA,eAAW,IAAI,iBAAiB;;;;;ICrBnB;;;;AAAN,IAAM,aAAoC;MAC7C,WAAW;QACP,MAAM,cAAc;QACpB,UAAU;MAAA;MAEd,MAAM,YACN;AACI,YAAI,CAAC,WAAW;AAA0B,iBAAA;AAG1C,cAAM,WAAW;AACjB,cAAM,OAAO,MAAM,SAAS,QAAQ,MAAM,QAAQ,EAAE,KAAK,CAAC,MAAM,EAAE,KAAA,CAAM;AAExE,eAAO,kBAAkB,IAAI,EAAE,KAAK,MAAM,MAAM,MAAM,KAAK;MAAA;MAE/D,KAAK,OAAOC,aAAY,CAAC,GAAGA,UAAS,MAAM;MAC3C,QAAQ,OAAOA,aAAYA,SAAQ,OAAO,CAAC,MAAM,MAAM,MAAM;IACjE;AAEA,eAAW,IAAI,UAAU;;;;;ICnBZ;;;;AAAN,IAAM,aAAa;MACtB,WAAW;QACP,MAAM,cAAc;QACpB,UAAU;MAAA;MAEd,MAAM,YACN;AACI,YAAI,CAAC,WAAW;AAA0B,iBAAA;AAE1C,cAAM,WAAW;AACjB,cAAM,OAAO,MAAM,SAAS,QAAQ,MAAM,QAAQ,EAAE,KAAK,CAAC,MAAM,EAAE,KAAA,CAAM;AAExE,eAAO,kBAAkB,IAAI,EAAE,KAAK,MAAM,MAAM,MAAM,KAAK;MAAA;MAE/D,KAAK,OAAOC,aAAY,CAAC,GAAGA,UAAS,MAAM;MAC3C,QAAQ,OAAOA,aAAYA,SAAQ,OAAO,CAAC,MAAM,MAAM,MAAM;IACjE;AAEA,eAAW,IAAI,UAAU;;;;;IClBnB,cAEO;;;;AAFb,IAAM,eAAe,CAAC,OAAO,OAAO,MAAM;AAEnC,IAAM,iBAAiB;MAC1B,WAAW;QACP,MAAM,cAAc;QACpB,UAAU;MAAA;MAEd,MAAM,MAAwB,QAAQ,QAAQ,IAAI;MAClD,KAAK,OAAOC,aAAY,CAAC,GAAGA,UAAS,GAAG,YAAY;MACpD,QAAQ,OAAOA,aAAYA,SAAQ,OAAO,CAAC,MAAM,CAAC,aAAa,SAAS,CAAC,CAAC;IAC9E;AAEA,eAAW,IAAI,cAAc;;;;;AChB7B;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AACA;AAAA;AAAA;;;ICIa;;;;;;AAAN,IAAM,oBAAoB;MAC7B,WAAW,cAAc;MACzB,MAAM,aAAa;MACnB,OAAO,CAAC,UACH;;AAAA;UACG,YAAY,aAAW,cAAS,cAAc,KAAK,KAAK,MAAjC,mBAAqC,OAAM,GAAG;UACrE,QAAQ,MAAM,MAAM,GAAG,EAAE,IAAI;UAC7B,KAAK;QAAA;;IAEjB;AAEA,eAAW,IAAI,iBAAiB;;;;;ICT1B;;;;AAAN,IAAM,cAAc;MAChB,QAAQ,cAAc;MACtB,UAAU,cAAc;MACxB,OAAO,cAAc;MACrB,WAAW,cAAc;IAC7B;AAoBA,eAAW,OAAO,cAAc,OAAO,CAAC,cACxC;AACI,YAAM,MAAM,UAAU;AAEtB,aAAO,QAAQ,WAAW,EACrB,OAAO,CAAC,CAAC,GAAS,MAAA,CAAC,CAAC,IAAI,GAAiB,CAAA,EACzC,QAAQ,CAAC,CAAC,KAAK,IAAA,MAAU,WAAW,IAAI,OAAO,OAC5C,IAAI,GAGJ,GAAA,EAAE,WAAW,IAAI,GAAkB,EAAA,aAAa,KAAK,CACzD,CAAC,CAAC;IACV,GAAG,CAAC,cACJ;AACI,YAAM,MAAM,UAAU;AAEtB,aAAO,KAAK,WAAW,EAClB,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,GAAiB,CAAA,EACvC,QAAQ,CAAC,QAAQ,WAAW,OAAO,IAAI,GAAA,CAAiB,CAAC;IAClE,CAAC;;;;;ACnDD;AAAA;AAAA;AAAA;;;ACAA,IAAAC,gBAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AACA;AACA,IAAAC;AAAA;AAAA;;;ACFA,IAAAC,gBAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;;ACFA;AAAA;AAAA,IAAAC;AAAA;AAAA;;;ACAA,IAAAC,gBAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAAC,cAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA,IAAAC;AACA,IAAAC;AAAA;AAAA;;;ACDA,IAAAC,YAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,IAAAC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;IChBM,iBAGO;;;;;;;;;AAHb,IAAM,kBAAkB,CAAC,QAAQ,MAAM;AAGhC,IAAM,iBAAiB;MAC1B,WAAW;QACP,MAAM,cAAc;QACpB,UAAU,qBAAqB;MAAA;MAGnC,MAAM;MAEN,KAAK,KACL;AACW,eAAA,gBAAgB,SAAS,YAAM,KAAK,QAAQ,GAAG,EAAE,YAAA,CAAa;MAAA;MAGzE,MAAM,UAAU,MAChB;AACI,eAAO,WAAW,KAAK,IAAI,KAAK,gBAAgB,KAAK,IAAI;MAAA;MAG7D,MAAM,MAAM,OAAe,MAAiB,QAC5C;AACU,cAAA,WAA2B,WAAW,KAAK,KAAK,IAChD,WAAW,MAAM,KAAK,IACtB,gBAAgB,MAAM,KAAK;AAEjC,cAAM,EAAE,IAAQ,IAAA;AACV,cAAA,EAAE,MAAM,MAAU,IAAA;AACxB,cAAM,cAAc,CAAA;AAEpB,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GACpC;AACU,gBAAA,WAAW,MAAM,CAAG,EAAA;AACtB,cAAA,YAAY,YAAM,KAAK,KAAK,YAAM,KAAK,QAAQ,GAAG,GAAG,QAAQ;AAErD,sBAAA,iBAAiB,WAAW,GAAG;AAE3C,sBAAY,KAAK,SAAS;QAAA;AAG9B,cAAM,iBAAiB,MAAM,OAAO,KAAc,WAAW;AAC7D,cAAM,WAAW,YAAY,IAAI,CAAC,QAAQ,eAAe,GAAI,CAAA;AAE7D,eAAO,WAAW,QAAQ,UAAU,UAAU,IAAI;MAAA;MAGtD,MAAM,KAAK,KAAa,UACxB;AACI,cAAM,WAAW,MAAM,SAAS,QAAQ,MAAM,GAAG;AAEjD,eAAO,SAAS,KAAK;MAAA;MAGzB,OAAO,YACP;AACI,mBAAW,QAAQ;MAAA;IAE3B;AAEA,eAAW,IAAI,cAAc;;;;;ACrE7B;AAAA;AAAA;AAAA;;;ACAA,IAAAC,YAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;ACAY,IAAA,WA2BA,UAuCC,QAuCA;AAzGD,IAAAC,cAAA;;IAAA,aAAA,CAAA,eAAL;AAOK,iBAAA,OAAA,IAAA;AAKA,iBAAA,OAAA,IAAA;AAKA,iBAAA,OAAA,IAAA;AAjBA,aAAA;IAAA,GAAA,aAAA,CAAA,CAAA;AA2BA,IAAA,YAAA,CAAA,cAAL;AAOI,gBAAA,MAAA,IAAA;AAKC,gBAAA,OAAA,IAAA;AAKC,gBAAA,QAAA,IAAA;AAjBD,aAAA;IAAA,GAAA,YAAA,CAAA,CAAA;AAuCL,IAAM,SAAS;MAClB,UAAU;MACV,WAAW;MACX,aAAa;MACb,aAAc;MAEd,SAAS;MAET,eAAe,QAAgB,kBAAkB,IACjD;AACI,YAAI,CAAC,KAAK,YAAY,CAAC,UAAU,MAAM,MAAM,GAC7C;AACW,iBAAA;QAAA;AAGX,YAAI,SAAS,KAAK,KAAK,SAAS,KAAK,SAAS;AAE1C,YAAA,SAAS,KAAK,aAClB;AACI,mBAAS,KAAK;QAAA,WAET,SAAS,KAAK,aACvB;AACI,mBAAS,KAAK;QAAA;AAGX,eAAA;MAAA;IAEf;AAWO,IAAM,kBAAkB;;;;;ACzGxB,IAAM;AAAN;;IAAM,eAAN,MAAM,cACb;MAgCI,YAAY,OAAe,YAAuB,MAAM,YAAuB,MAAM,SAAiB,MACtG;AAbA,aAAA,SAAmB,CAAA;AAInB,aAAA,QAA6B,CAAA;AAUzB,aAAK,QAAQ;AACb,aAAK,YAAY;AACjB,aAAK,YAAY;AACjB,aAAK,SAAS;AACd,aAAK,OAAO,MAAM;MAAA;MAOtB,QACA;AACW,eAAA,IAAI,cACP,KAAK,OACL,KAAK,WACL,KAAK,WACL,KAAK,MACT;MAAA;MAIJ,UACA;AACI,aAAK,QAAQ;AACb,aAAK,MAAM,SAAS;AACpB,aAAK,QAAQ;AACb,aAAK,OAAO,SAAS;AACrB,aAAK,SAAS;AACd,aAAK,YAAY;AACjB,aAAK,YAAY;MAAA;IAEzB;;;;;IC3Da;;;;AAAN,IAAM,cAAkC;MAE3C,MAAM,cACN;AAEI,cAAM,SAAS,aAAa;AAExB,YAAA;AACA,YAAA;AACA,YAAA;AACA,YAAA;AACA,YAAA;AACA,YAAA;AAEA,YAAA,aAAa,SAAS,OAAO,MACjC;AACI,gBAAM,SAAS,aAAa;AAE5B,cAAI,OAAO;AACX,cAAI,OAAO;AACX,eAAK,KAAK,OAAO;AACjB,eAAK,KAAK;QAAA,WAEL,aAAa,SAAS,OAAO,MACtC;AACI,gBAAM,UAAU,aAAa;AAE7B,cAAI,QAAQ;AACZ,cAAI,QAAQ;AACZ,eAAK,QAAQ;AACb,eAAK,QAAQ;AACb,eAAK,KAAK;QAAA,OAGd;AACI,gBAAM,cAAc,aAAa;AAC3B,gBAAA,YAAY,YAAY,QAAQ;AAChC,gBAAA,aAAa,YAAY,SAAS;AAExC,cAAI,YAAY,IAAI;AACpB,cAAI,YAAY,IAAI;AACpB,eAAK,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,YAAY,QAAQ,KAAK,IAAI,WAAW,UAAU,CAAC,CAAC;AACnF,eAAK,YAAY;AACjB,eAAK,aAAa;QAAA;AAGlB,YAAA,EAAA,MAAQ,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,IAC7C;AACI,iBAAO,SAAS;AAEhB;QAAA;AAIE,cAAA,IAAI,KAAK,KAAK,MAAM,KAAK,KAAK,KAAK,EAAE,CAAC;AAC5C,cAAM,IAAK,IAAI,KAAA,KAAW,IAAI,MAAA,KAAW,IAAI;AAE7C,eAAO,SAAS;AAEhB,YAAI,MAAM,GACV;AACI;QAAA;AAGJ,YAAI,MAAM,GACV;AACI,iBAAO,SAAS;AACT,iBAAA,CAAA,IAAK,OAAO,CAAA,IAAK,IAAI;AACrB,iBAAA,CAAA,IAAK,OAAO,CAAA,IAAK,IAAI;AACrB,iBAAA,CAAA,IAAK,OAAO,CAAA,IAAK,IAAI;AACrB,iBAAA,CAAA,IAAK,OAAO,CAAA,IAAK,IAAI;AAE5B;QAAA;AAGJ,YAAI,KAAK;AACT,YAAI,KAAM,IAAI,KAAM,KAAK,IAAI,KAAK;AAClC,YAAI,KAAK;AACT,YAAI,KAAK;AAET;AACI,gBAAM,KAAK,KAAK;AAChB,gBAAM,KAAK;AACX,gBAAM,KAAK,IAAI;AACf,gBAAM,KAAK,IAAI;AACf,gBAAM,KAAK,IAAI;AAEf,iBAAO,IAAQ,IAAA;AACf,iBAAO,IAAQ,IAAA;AACf,iBAAO,EAAE,EAAM,IAAA;AACf,iBAAO,EAAE,EAAM,IAAA;AAEf,cAAI,IACJ;AACI,kBAAM,KAAK,IAAI;AAEf,mBAAO,IAAQ,IAAA;AACf,mBAAO,IAAQ,IAAA;AACf,mBAAO,EAAE,EAAM,IAAA;AACf,mBAAO,EAAE,EAAM,IAAA;UAAA;QACnB;AAGJ,iBAAS,IAAI,GAAG,IAAI,GAAG,KACvB;AACI,gBAAM,IAAI,KAAK,KAAK,KAAS,IAAA;AAC7B,gBAAM,KAAK,KAAM,KAAK,IAAI,CAAC,IAAI;AAC/B,gBAAM,KAAK,KAAM,KAAK,IAAI,CAAC,IAAI;AAC/B,gBAAM,KAAK,IAAI;AACf,gBAAM,KAAK,IAAI;AACf,gBAAM,KAAK,IAAI;AACf,gBAAM,KAAK,IAAI;AAEf,iBAAO,IAAQ,IAAA;AACf,iBAAO,IAAQ,IAAA;AACf,iBAAO,EAAE,EAAM,IAAA;AACf,iBAAO,EAAE,EAAM,IAAA;AACf,iBAAO,IAAQ,IAAA;AACf,iBAAO,IAAQ,IAAA;AACf,iBAAO,EAAE,EAAM,IAAA;AACf,iBAAO,EAAE,EAAM,IAAA;QAAA;AAGnB;AACI,gBAAM,KAAK;AACX,gBAAM,KAAK,KAAK;AAChB,gBAAM,KAAK,IAAI;AACf,gBAAM,KAAK,IAAI;AACf,gBAAM,KAAK,IAAI;AACf,gBAAM,KAAK,IAAI;AAEf,iBAAO,IAAQ,IAAA;AACf,iBAAO,IAAQ,IAAA;AACf,iBAAO,EAAE,EAAM,IAAA;AACf,iBAAO,EAAE,EAAM,IAAA;AAEf,cAAI,IACJ;AACI,mBAAO,IAAQ,IAAA;AACf,mBAAO,IAAQ,IAAA;AACf,mBAAO,EAAE,EAAM,IAAA;AACf,mBAAO,EAAE,EAAM,IAAA;UAAA;QACnB;MACJ;MAGJ,YAAY,cAAc,kBAC1B;AACI,cAAM,SAAS,aAAa;AAC5B,cAAM,QAAQ,iBAAiB;AAC/B,cAAMC,WAAU,iBAAiB;AAE7B,YAAA,OAAO,WAAW,GACtB;AACI;QAAA;AAGA,YAAA,UAAU,MAAM,SAAS;AAC7B,cAAM,SAAS;AAEX,YAAA;AACA,YAAA;AAEA,YAAA,aAAa,SAAS,OAAO,MACjC;AACI,gBAAM,SAAS,aAAa;AAE5B,cAAI,OAAO;AACX,cAAI,OAAO;QAAA,OAGf;AACI,gBAAM,cAAc,aAAa;AAE7B,cAAA,YAAY,IAAK,YAAY,QAAQ;AACrC,cAAA,YAAY,IAAK,YAAY,SAAS;QAAA;AAG9C,cAAM,SAAS,aAAa;AAGtB,cAAA,KACF,aAAa,SAAU,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO,KAAK,GACpE,aAAa,SAAU,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO,KAAK,CAAC;AAEzE;AAEA,cAAM,KAAK,OAAO,CAAI,GAAA,OAAO,CAAE,CAAA;AAE/B,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GACxC;AACI,gBAAM,KAAK,OAAO,CAAI,GAAA,OAAO,IAAI,CAAE,CAAA;AAG3B,UAAAA,SAAA,KAAK,WAAW,QAAQ,OAAO;QAAA;AAG3C,QAAAA,SAAQ,KAAK,SAAS,GAAG,QAAQ,OAAO;MAAA;IAEhD;;;;;AClNA,SAAwB,eAAA,QAAkB,OAAO,OACjD;AACI,QAAM,IAAI,OAAO;AAEjB,MAAI,IAAI,GACR;AACI;EAAA;AAGJ,MAAI,OAAO;AAEX,WAAS,IAAI,GAAG,KAAK,OAAO,IAAI,CAAA,GAAI,KAAK,OAAO,IAAI,CAAA,GAAI,IAAI,GAAG,KAAK,GACpE;AACI,UAAM,KAAK,OAAO,CAAA;AACZ,UAAA,KAAK,OAAO,IAAI,CAAA;AAEb,aAAA,KAAK,OAAY,KAAA;AAErB,SAAA;AACA,SAAA;EAAA;AAGT,MAAK,CAAC,QAAQ,OAAO,KAAO,QAAQ,QAAQ,GAC5C;AACI,UAAM,IAAI,IAAI;AAEd,aAAS,IAAI,IAAK,IAAI,GAAI,IAAI,GAAG,KAAK,GACtC;AACU,YAAA,KAAK,IAAI,IAAI;AACb,YAAA,KAAK,IAAI,IAAI;AACnB,YAAM,KAAK;AACX,YAAM,KAAK,IAAI;AAEd,OAAA,OAAO,EAAA,GAAK,OAAO,EAAA,CAAG,IAAI,CAAC,OAAO,EAAK,GAAA,OAAO,EAAG,CAAA;AACjD,OAAA,OAAO,EAAA,GAAK,OAAO,EAAA,CAAG,IAAI,CAAC,OAAO,EAAK,GAAA,OAAO,EAAG,CAAA;IAAA;EACtD;AAER;IAWa;;;;AAAN,IAAM,YAAgC;MAEzC,MAAM,cACN;AACI,qBAAa,SAAU,aAAa,MAAkB,OAAO,MAAM;MAAA;MAGvE,YAAY,cAAc,kBAC1B;AACI,YAAI,SAAS,aAAa;AAC1B,cAAM,QAAQ,aAAa;AAC3B,cAAM,QAAQ,iBAAiB;AAC/B,cAAMC,WAAU,iBAAiB;AAE7B,YAAA,OAAO,UAAU,GACrB;AACI,yBAAe,QAAQ,KAAK;AAE5B,gBAAM,YAAY,CAAA;AAGlB,mBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAClC;AACI,kBAAM,OAAO,MAAM,CAAA;AAEJ,2BAAA,KAAK,QAAQ,IAAI;AAEtB,sBAAA,KAAK,OAAO,SAAS,CAAC;AACvB,qBAAA,OAAO,OAAO,KAAK,MAAM;UAAA;AAItC,gBAAM,YAAY,YAAM,OAAO,QAAQ,WAAW,CAAC;AAEnD,cAAI,CAAC,WACL;AACI;UAAA;AAGE,gBAAA,UAAU,MAAM,SAAS;AAE/B,mBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK,GAC3C;AACY,YAAAA,SAAA,KAAK,UAAU,CAAA,IAAK,OAAO;AACnC,YAAAA,SAAQ,KAAK,UAAU,IAAI,CAAA,IAAK,OAAO;AACvC,YAAAA,SAAQ,KAAK,UAAU,IAAI,CAAA,IAAK,OAAO;UAAA;AAG3C,mBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KACnC;AACU,kBAAA,KAAK,OAAO,CAAE,CAAA;UAAA;QACxB;MACJ;IAER;;;;;AC9FO,IAAM;AAAN;;IAAM,iBAAqC;MAE9C,MAAM,cACN;AAII,cAAM,WAAW,aAAa;AAC9B,cAAM,IAAI,SAAS;AACnB,cAAM,IAAI,SAAS;AACnB,cAAM,QAAQ,SAAS;AACvB,cAAM,SAAS,SAAS;AAExB,cAAM,SAAS,aAAa;AAE5B,eAAO,SAAS;AAEhB,YAAI,EAAE,SAAS,KAAK,UAAU,IAC9B;AACI;QAAA;AAGJ,eAAO,KAAK,GAAG,GACX,IAAI,OAAO,GACX,IAAI,OAAO,IAAI,QACf,GAAG,IAAI,MAAM;MAAA;MAGrB,YAAY,cAAc,kBAC1B;AACI,cAAM,SAAS,aAAa;AAC5B,cAAM,QAAQ,iBAAiB;AAE3B,YAAA,OAAO,WAAW,GACtB;AACI;QAAA;AAGE,cAAA,UAAU,MAAM,SAAS;AAE/B,cAAM,KAAK,OAAO,CAAA,GAAI,OAAO,CAAA,GACzB,OAAO,CAAI,GAAA,OAAO,CAClB,GAAA,OAAO,CAAA,GAAI,OAAO,CAAA,GAClB,OAAO,CAAA,GAAI,OAAO,CAAE,CAAA;AAExB,yBAAiB,QAAQ,KAAK,SAAS,UAAU,GAAG,UAAU,GAC1D,UAAU,GAAG,UAAU,GAAG,UAAU,CAAC;MAAA;IAEjD;;;;;IC9Ca;;;;AAAN,IAAM,wBAA4C;MAErD,MAAM,cACN;AACI,oBAAY,MAAM,YAAY;MAAA;MAGlC,YAAY,cAAc,kBAC1B;AACgB,oBAAA,YAAY,cAAc,gBAAgB;MAAA;IAE9D;;;;;ICTa;;;;;AAAN,IAAM,WAAN,MACP;MAYI,OAAO,QAAQ,IAAY,IAAY,IAAY,IAAY,QAAgB,QAC/E;AACU,cAAA,QAAQ,OAAO,OAAO,SAAS,CAAA;AAC/B,cAAA,QAAQ,OAAO,OAAO,SAAS,CAAA;AAErC,cAAM,KAAK,QAAQ;AACnB,cAAM,KAAK,QAAQ;AACnB,cAAM,KAAK,KAAK;AAChB,cAAM,KAAK,KAAK;AAChB,cAAM,KAAK,KAAK,IAAK,KAAK,KAAO,KAAK,EAAG;AAErC,YAAA,KAAK,QAAU,WAAW,GAC9B;AACQ,cAAA,OAAO,OAAO,SAAS,CAAA,MAAO,MAAM,OAAO,OAAO,SAAS,CAAA,MAAO,IACtE;AACW,mBAAA,KAAK,IAAI,EAAE;UAAA;AAGf,iBAAA;QAAA;AAGL,cAAA,KAAM,KAAK,KAAO,KAAK;AACvB,cAAA,KAAM,KAAK,KAAO,KAAK;AACvB,cAAA,KAAM,KAAK,KAAO,KAAK;AAC7B,cAAM,KAAK,SAAS,KAAK,KAAK,EAAE,IAAI;AACpC,cAAM,KAAK,SAAS,KAAK,KAAK,EAAE,IAAI;AAC9B,cAAA,KAAK,KAAK,KAAK;AACf,cAAA,KAAK,KAAK,KAAK;AACf,cAAA,KAAM,KAAK,KAAO,KAAK;AACvB,cAAA,KAAM,KAAK,KAAO,KAAK;AACvB,cAAA,KAAK,MAAW,KAAA;AAChB,cAAA,KAAK,MAAW,KAAA;AAChB,cAAA,KAAK,MAAW,KAAA;AAChB,cAAA,KAAK,MAAW,KAAA;AACtB,cAAM,aAAa,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAC9C,cAAM,WAAW,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAErC,eAAA;UACH,IAAK,KAAK;UACV,IAAK,KAAK;UACV;UACA;UACA;UACA,eAAgB,KAAK,KAAK,KAAK;QAAA;MACnC;MAmBJ,OAAO,IAAI,SAAiB,SAAiB,IAAY,IAAY,QACjE,YAAoB,UAAkB,gBAAyB,QACnE;AACI,cAAM,QAAQ,WAAW;AACzB,cAAM,IAAI,OAAO,eACb,KAAK,IAAI,KAAK,IAAI,QAClB,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI,EACxC;AAEM,cAAA,QAAS,SAAc,IAAA;AAC7B,cAAM,SAAS,QAAQ;AACjB,cAAA,SAAS,KAAK,IAAI,KAAK;AACvB,cAAA,SAAS,KAAK,IAAI,KAAK;AAC7B,cAAM,WAAW,IAAI;AACf,cAAA,YAAa,WAAW,IAAK;AAEnC,iBAAS,IAAI,GAAG,KAAK,UAAU,EAAE,GACjC;AACU,gBAAA,OAAO,IAAK,YAAY;AACxB,gBAAA,QAAU,QAAS,aAAc,SAAS;AAC1C,gBAAA,IAAI,KAAK,IAAI,KAAK;AACxB,gBAAM,IAAI,CAAC,KAAK,IAAI,KAAK;AAEzB,iBAAO,MACA,SAAS,IAAM,SAAS,KAAM,SAAU,KACxC,SAAS,CAAC,IAAM,SAAS,KAAM,SAAU,EAChD;QAAA;MACJ;IAER;;;;;ACnHO,IAAM;AAAN;;IAAM,YAAN,MACP;MAOI,cACA;AACI,aAAK,MAAM;MAAA;MASf,MAAa,OAA8B,YAAoB,aAC/D;AACI,aAAK,MAAM;AACX,aAAK,QAAQ;AACb,aAAK,QAAQ;AACb,aAAK,cAAc;MAAA;MAQhB,IAAI,UAAkB,WAC7B;AACS,aAAA,aAAa,YAAY,KAAK;AAC9B,aAAA,OAAO,WAAW,KAAK;MAAA;MAGhC,QACA;AACI,aAAK,QAAQ;AACb,aAAK,OAAO;AACZ,aAAK,QAAQ;AACb,aAAK,cAAc;AACnB,aAAK,aAAa;MAAA;IAE1B;;;;;IC/Ca;;;;AAAN,IAAM,cAAN,MAAM,aACb;MAgBI,OAAO,YACH,OAAe,OACf,KAAa,KACb,MAAc,MACd,KAAa,KACjB;AACI,cAAM,IAAI;AACV,YAAI,SAAS;AACb,YAAI,IAAI;AACR,YAAI,KAAK;AACT,YAAI,KAAK;AACT,YAAI,KAAK;AACT,YAAI,MAAM;AACV,YAAI,MAAM;AACV,YAAI,IAAI;AACR,YAAI,IAAI;AACR,YAAI,KAAK;AACT,YAAI,KAAK;AACT,YAAI,QAAQ;AACZ,YAAI,QAAQ;AAEZ,iBAAS,IAAI,GAAG,KAAK,GAAG,EAAE,GAC1B;AACI,cAAI,IAAI;AACR,eAAK,IAAI;AACT,eAAK,KAAK;AACV,eAAM,IAAM;AACZ,gBAAM,KAAK;AACX,gBAAM,MAAM;AAEP,cAAA,MAAM,QAAU,IAAM,MAAM,IAAI,MAAQ,IAAM,KAAK,KAAK,OAAS,KAAK;AACtE,cAAA,MAAM,QAAU,IAAM,MAAM,IAAI,MAAQ,IAAI,KAAK,KAAK,OAAS,KAAK;AACzE,eAAK,QAAQ;AACb,eAAK,QAAQ;AACL,kBAAA;AACA,kBAAA;AAER,oBAAU,KAAK,KAAM,KAAK,KAAO,KAAK,EAAG;QAAA;AAGtC,eAAA;MAAA;MAgBX,OAAO,QACH,KAAa,KACb,MAAc,MACd,KAAa,KACb,QACJ;AACU,cAAA,QAAQ,OAAO,OAAO,SAAS,CAAA;AAC/B,cAAA,QAAQ,OAAO,OAAO,SAAS,CAAA;AAErC,eAAO,UAAU;AAEjB,cAAM,IAAI,OAAO,eACb,aAAY,YAAY,OAAO,OAAO,KAAK,KAAK,MAAM,MAAM,KAAK,GAAG,CACxE;AAEA,YAAI,KAAK;AACT,YAAI,MAAM;AACV,YAAI,MAAM;AACV,YAAI,KAAK;AACT,YAAI,KAAK;AAEF,eAAA,KAAK,OAAO,KAAK;AAExB,iBAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,EAAE,GACjC;AACI,cAAI,IAAI;AAER,eAAM,IAAI;AACV,gBAAM,KAAK;AACX,gBAAM,MAAM;AAEZ,eAAK,IAAI;AACT,eAAK,KAAK;AAEH,iBAAA,KACF,MAAM,QAAU,IAAI,MAAM,IAAI,MAAQ,IAAI,KAAK,KAAK,OAAS,KAAK,KAClE,MAAM,QAAU,IAAI,MAAM,IAAI,MAAQ,IAAI,KAAK,KAAK,OAAS,KAAK,GACvE;QAAA;MACJ;IAER;;;;;AChGA,SAAA,OACI,GACA,GACA,IACA,IACA,aACA,aACA,WACA,OAEJ;AACU,QAAA,KAAK,IAAK,KAAK;AACf,QAAA,KAAK,IAAK,KAAK;AACf,QAAA,KAAK,IAAK,KAAK;AACf,QAAA,KAAK,IAAK,KAAK;AAGjB,MAAA;AACA,MAAA;AAEJ,MAAI,WACJ;AACU,UAAA;AACN,UAAM,CAAC;EAAA,OAGX;AACI,UAAM,CAAC;AACD,UAAA;EAAA;AAIV,QAAM,MAAM,KAAK;AACjB,QAAM,MAAM,KAAK;AACjB,QAAM,MAAM,KAAK;AACjB,QAAM,MAAM,KAAK;AAGjB,QAAM,KACF,KAAK,KACL,KAAK,GAAG;AAEL,SAAA;AACX;AAkBA,SAAA,MACI,IACA,IACA,IACA,IACA,IACA,IACA,OACA,WAEJ;AACI,QAAM,SAAS,KAAK;AACpB,QAAM,SAAS,KAAK;AAEpB,MAAI,SAAS,KAAK,MAAM,QAAQ,MAAM;AACtC,MAAI,SAAS,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAEpC,MAAA,aAAa,SAAS,QAC1B;AACI,cAAU,KAAK,KAAK;EAAA,WAEf,CAAC,aAAa,SAAS,QAChC;AACI,cAAU,KAAK,KAAK;EAAA;AAGxB,MAAI,aAAa;AACjB,QAAM,YAAY,SAAS;AACrB,QAAA,eAAe,KAAK,IAAI,SAAS;AAoBvC,QAAM,SAAS,KAAK,KAAM,SAAS,SAAW,SAAS,MAAO;AACxD,QAAA,YAAa,KAAK,eAAe,KAAK,KAAK,MAAM,IAAI,KAAK,MAAO,KAAK;AAC5E,QAAM,WAAW,YAAY;AAEf,gBAAA;AAEd,MAAI,WACJ;AACI,UAAM,KACF,IAAI,IACJ,IAAI,EAAE;AAED,aAAA,IAAI,GAAG,QAAQ,YAAY,IAAI,UAAU,KAAK,SAAS,UAChE;AACI,YAAM,KACF,IAAI,IACJ,KAAO,KAAK,IAAI,KAAK,IAAI,QAAU,KAAO,KAAK,IAAI,KAAK,IAAI,MAAQ;IAAA;AAG5E,UAAM,KACF,IAAI,IACJ,IAAI,EAAE;EAAA,OAGd;AACI,UAAM,KACF,IAAI,IACJ,IAAI,EAAE;AAED,aAAA,IAAI,GAAG,QAAQ,YAAY,IAAI,UAAU,KAAK,SAAS,UAChE;AACI,YAAM,KACF,KAAO,KAAK,IAAI,KAAK,IAAI,QAAU,KAAO,KAAK,IAAI,KAAK,IAAI,QAC5D,IAAI,EAAE;IAAA;AAGd,UAAM,KACF,IAAI,IACJ,IAAI,EAAE;EAAA;AAGd,SAAO,WAAW;AACtB;AAWA,SAAA,mBAA4B,cAA4B,kBACxD;AACI,QAAM,QAAQ,aAAa;AAC3B,MAAI,SAAS,aAAa,UAAU,MAAM,OAAO,MAAM;AACvD,QAAM,MAAM,iBAAiB;AAEzB,MAAA,OAAO,WAAW,GACtB;AACI;EAAA;AAYJ,QAAM,QAAQ,aAAa;AAG3B,QAAM,aAAa,IAAI,MAAM,OAAO,CAAA,GAAI,OAAO,CAAE,CAAA;AAC3C,QAAA,YAAY,IAAI,MAAM,OAAO,OAAO,SAAS,CAAI,GAAA,OAAO,OAAO,SAAS,CAAE,CAAA;AAChF,QAAM,cAAc,MAAM,SAAS,OAAO,QAAQ,MAAM;AACxD,QAAM,aAAa,KAAK,IAAI,WAAW,IAAI,UAAU,CAAC,IAAI,OACnD,KAAK,IAAI,WAAW,IAAI,UAAU,CAAC,IAAI;AAG9C,MAAI,aACJ;AAEI,aAAS,OAAO,MAAM;AAEtB,QAAI,YACJ;AACI,aAAO,IAAI;AACX,aAAO,IAAI;AACD,gBAAA,IAAI,OAAO,OAAO,SAAS,CAAA,GAAI,OAAO,OAAO,SAAS,CAAE,CAAA;IAAA;AAGtE,UAAM,aAAa,WAAW,IAAI,UAAU,KAAK;AACjD,UAAM,aAAa,UAAU,IAAI,WAAW,KAAK;AAE1C,WAAA,QAAQ,WAAW,SAAS;AAC5B,WAAA,KAAK,WAAW,SAAS;EAAA;AAGpC,QAAM,QAAQ,iBAAiB;AACzB,QAAA,SAAS,OAAO,SAAS;AAC/B,MAAI,aAAa,OAAO;AAClB,QAAA,aAAa,MAAM,SAAS;AAG5B,QAAA,QAAQ,MAAM,QAAQ;AAC5B,QAAM,eAAe,QAAQ;AACvB,QAAA,oBAAoB,MAAM,aAAa,MAAM;AAGnD,MAAI,KAAK,OAAO,CAAA;AAChB,MAAI,KAAK,OAAO,CAAA;AAChB,MAAI,KAAK,OAAO,CAAA;AAChB,MAAI,KAAK,OAAO,CAAA;AAChB,MAAI,KAAK;AACT,MAAI,KAAK;AAGL,MAAA,QAAQ,EAAO,KAAA;AACnB,MAAI,QAAQ,KAAK;AACjB,MAAI,SAAS;AACb,MAAI,SAAS;AAEb,MAAI,OAAO,KAAK,KAAM,QAAQ,QAAU,QAAQ,KAAM;AAE7C,WAAA;AACA,WAAA;AACA,WAAA;AACA,WAAA;AAET,QAAM,QAAQ,MAAM;AACd,QAAA,eAAe,IAAI,SAAS;AAClC,QAAM,cAAc,QAAQ;AAE5B,MAAI,CAAC,aACL;AACQ,QAAA,MAAM,QAAQ,SAAS,OAC3B;AACkB,oBAAA,MACV,KAAM,SAAuB,cAAA,eAAe,KAC5C,KAAM,SAAuB,cAAA,eAAe,KAC5C,KAAM,QAAQ,aACd,KAAM,QAAQ,aACd,KAAM,QAAQ,aACd,KAAM,QAAQ,aACd,OACA,IACJ,IAAI;IAAA,WAEC,MAAM,QAAQ,SAAS,QAChC;AACkB,oBAAA,OAAO,IAAI,IAAI,OAAO,OAAO,aAAa,aAAa,MAAM,KAAK;IAAA;EACpF;AAIJ,QAAM,KACF,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AAE1D,WAAS,IAAI,GAAG,IAAI,SAAS,GAAG,EAAE,GAClC;AACS,SAAA,QAAQ,IAAI,KAAK,CAAA;AACjB,SAAA,QAAa,IAAA,KAAK,IAAK,CAAA;AAE5B,SAAK,OAAO,IAAI,CAAA;AACX,SAAA,OAAQ,IAAI,IAAK,CAAA;AAEjB,SAAA,QAAQ,IAAI,KAAK,CAAA;AACjB,SAAA,QAAa,IAAA,KAAK,IAAK,CAAA;AAE5B,YAAQ,EAAO,KAAA;AACf,YAAQ,KAAK;AAEb,WAAO,KAAK,KAAM,QAAQ,QAAU,QAAQ,KAAM;AACzC,aAAA;AACA,aAAA;AACA,aAAA;AACA,aAAA;AAET,aAAS,EAAO,KAAA;AAChB,aAAS,KAAK;AAEd,WAAO,KAAK,KAAM,SAAS,SAAW,SAAS,MAAO;AAC5C,cAAA;AACA,cAAA;AACA,cAAA;AACA,cAAA;AAGV,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AAGX,UAAA,MAAO,MAAM,MAAQ,MAAM;AAE3B,UAAA,QAAS,MAAM,MAAQ,MAAM;AACnC,UAAM,YAAa,QAAQ;AAIvB,QAAA,KAAK,IAAI,KAAK,IAAI,OAAQ,KAAK,IAAI,GAAG,GAC1C;AACI,YAAM,KACF,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AAG1D,UAAI,OAAO,GACX;AACQ,YAAA,MAAM,SAAS,UAAU,OAC7B;AACI,wBAAc,MACV,IAAI,IACJ,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5C,OAAO,KAAK,IAAI;QAAA,OAGxB;AACkB,wBAAA;QAAA;AAGlB,cAAM,KACF,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5C,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;MAAA;AAGhE;IAAA;AAIE,UAAA,MAAQ,CAAA,QAAQ,OAAO,CAAC,QAAQ,OAAU,CAAA,QAAQ,OAAO,CAAC,QAAQ;AAClE,UAAA,MAAQ,CAAA,SAAS,OAAO,CAAC,SAAS,OAAU,CAAA,SAAS,OAAO,CAAC,SAAS;AAC5E,UAAM,MAAO,MAAM,KAAO,MAAM,MAAO;AACvC,UAAM,MAAO,MAAM,KAAO,MAAM,MAAO;AACvC,UAAM,SAAe,KAAA,OAAA,KAAY,OAAS,KAAK,OAAY,KAAA;AAGrD,UAAA,MAAM,MAAO,KAAK,MAAM;AACxB,UAAA,MAAM,MAAO,KAAK,MAAM;AAExB,UAAA,MAAM,MAAO,KAAK,MAAM;AACxB,UAAA,MAAM,MAAO,KAAK,MAAM;AAGxB,UAAA,yBAAyB,KAAK,IAAK,MAAM,MAAQ,MAAM,KAAO,MAAM,MAAQ,MAAM,GAAI;AACtF,UAAA,eAAe,YAAY,cAAc;AACzC,UAAA,0BAA0B,yBAA0B,eAAe,eAAe;AACxF,UAAM,gBAAgB,SAAS;AAE/B,QAAI,OAAO,MAAM;AAEjB,QAAI,SAAS,UAAU,SAAS,QAAQ,eAAe,mBACvD;AACI,aAAO,UAAU;IAAA;AAGrB,QAAI,eACJ;AACY,cAAA,MAAA;QAAA,KAEC,UAAU,OACf;AACI,gBAAM,KACF,KAAK,KACL,KAAK,GAAG;AACZ;QAAA;QACJ,KACK,UAAU,OACf;AACI,cAAI,WACJ;AACI,kBAAM,KACF,KAAK,KACL,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAK,KACL,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;UAAA,OAGhE;AACI,kBAAM,KACF,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAK,KACL,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5C,KAAK,GAAG;UAAA;AAGF,wBAAA;AACd;QAAA;QACJ,KACK,UAAU,OACf;AACI,cAAI,WACJ;AACU,kBAAA,KACF,KAAK,KACL,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AAE1D,0BAAc,MACV,IAAI,IACJ,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5C,OAAO,IACX,IAAI;AAEE,kBAAA,KACF,KAAK,KACL,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;UAAA,OAGhE;AACU,kBAAA,KACF,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAK,GAAG;AAEZ,0BAAc,MACV,IAAI,IACJ,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5C,OAAO,KACX,IAAI;AAEE,kBAAA,KACF,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5C,KAAK,GAAG;UAAA;AAEhB;QAAA;MACJ;IAAA,OAIR;AACI,YAAM,KACF,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AAClD,cAAA,MAAA;QAAA,KAEC,UAAU,OACf;AACI,cAAI,WACJ;AACI,kBAAM,KACF,KAAK,KACL,KAAK,GAAG;UAAA,OAGhB;AACI,kBAAM,KACF,KAAK,KACL,KAAK,GAAG;UAAA;AAEF,wBAAA;AACd;QAAA;QACJ,KACK,UAAU,OACf;AACI,cAAI,WACJ;AACI,0BAAc,MACV,IAAI,IACJ,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5C,OAAO,IACX,IAAI;UAAA,OAGR;AACI,0BAAc,MACV,IAAI,IACJ,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5C,OAAO,KACX,IAAI;UAAA;AAER;QAAA;MACJ;AAEJ,YAAM,KACF,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5C,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;AAC9C,oBAAA;IAAA;EAClB;AAGC,OAAA,QAAQ,SAAS,KAAK,CAAA;AACtB,OAAA,QAAkB,SAAA,KAAK,IAAK,CAAA;AAE5B,OAAA,QAAQ,SAAS,KAAK,CAAA;AACtB,OAAA,QAAkB,SAAA,KAAK,IAAK,CAAA;AAEjC,UAAQ,EAAO,KAAA;AACf,UAAQ,KAAK;AAEb,SAAO,KAAK,KAAM,QAAQ,QAAU,QAAQ,KAAM;AACzC,WAAA;AACA,WAAA;AACA,WAAA;AACA,WAAA;AAET,QAAM,KACF,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AAE1D,MAAI,CAAC,aACL;AACQ,QAAA,MAAM,QAAQ,SAAS,OAC3B;AACkB,oBAAA,MACV,KAAM,SAAuB,cAAA,eAAe,KAC5C,KAAM,SAAuB,cAAA,eAAe,KAC5C,KAAM,QAAQ,aACd,KAAM,QAAQ,aACd,KAAM,QAAQ,aACd,KAAM,QAAQ,aACd,OACA,KACJ,IAAI;IAAA,WAEC,MAAM,QAAQ,SAAS,QAChC;AACkB,oBAAA,OAAO,IAAI,IAAI,OAAO,OAAO,aAAa,aAAa,OAAO,KAAK;IAAA;EACrF;AAGJ,QAAMC,WAAU,iBAAiB;AAC3B,QAAA,OAAO,OAAO,UAAU,OAAO;AAGrC,WAAS,IAAI,YAAY,IAAI,aAAa,aAAa,GAAG,EAAE,GAC5D;AACI,SAAK,MAAO,IAAI,CAAA;AACX,SAAA,MAAO,IAAI,IAAK,CAAA;AAEhB,SAAA,OAAO,IAAI,KAAK,CAAA;AAChB,SAAA,OAAY,IAAA,KAAK,IAAK,CAAA;AAEtB,SAAA,OAAO,IAAI,KAAK,CAAA;AAChB,SAAA,OAAY,IAAA,KAAK,IAAK,CAAA;AAG3B,QAAI,KAAK,IAAK,MAAM,KAAK,MAAQ,MAAW,KAAA,MAAQ,MAAM,KAAK,GAAI,IAAI,MACvE;AACI;IAAA;AAGJ,IAAAA,SAAQ,KAAK,GAAG,IAAI,GAAG,IAAI,CAAC;EAAA;AAEpC;AAWA,SAAA,gBAAyB,cAA4B,kBACrD;AACI,MAAI,IAAI;AAER,QAAM,QAAQ,aAAa;AACrB,QAAA,SAAS,aAAa,UAAU,MAAM;AAC5C,QAAM,cAAc,MAAM,SAAS,OAAO,QAAQ,MAAM;AAExD,MAAI,OAAO,WAAW;AAAG;AAEzB,QAAM,QAAQ,iBAAiB;AAC/B,QAAMA,WAAU,iBAAiB;AAC3B,QAAA,SAAS,OAAO,SAAS;AAEzB,QAAA,aAAa,MAAM,SAAS;AAClC,MAAI,eAAe;AAEnB,QAAM,KAAK,OAAO,CAAI,GAAA,OAAO,CAAE,CAAA;AAE/B,OAAK,IAAI,GAAG,IAAI,QAAQ,KACxB;AACI,UAAM,KAAK,OAAO,IAAI,CAAA,GAAI,OAAQ,IAAI,IAAK,CAAE,CAAA;AACrC,IAAAA,SAAA,KAAK,cAAc,eAAe,CAAC;AAE3C;EAAA;AAGJ,MAAI,aACJ;AACY,IAAAA,SAAA,KAAK,cAAc,UAAU;EAAA;AAE7C;AAWO,SAAA,UAAmB,cAA4B,kBACtD;AACQ,MAAA,aAAa,UAAU,QAC3B;AACI,oBAAgB,cAAc,gBAAgB;EAAA,OAGlD;AACI,uBAAmB,cAAc,gBAAgB;EAAA;AAEzD;;;;;;;;;ICloBa;;;;AAAN,IAAM,iBAAN,MAAM,gBACb;MAcI,OAAO,YACH,OAAe,OACf,KAAa,KACb,KAAa,KACjB;AACU,cAAA,KAAK,QAAS,IAAM,MAAO;AAC3B,cAAA,KAAK,QAAS,IAAM,MAAO;AAC3B,cAAA,KAAM,IAAM,MAAQ,IAAM;AAC1B,cAAA,KAAM,IAAM,MAAQ,IAAM;AAChC,cAAM,IAAI,KAAa,KAAA,KAAO,KAAK;AACnC,cAAM,IAAI,KAAa,KAAA,KAAO,KAAK;AAC7B,cAAA,IAAK,KAAK,KAAO,KAAK;AAE5B,cAAM,IAAI,IAAM,KAAK,KAAK,IAAI,IAAI,CAAC;AAC7B,cAAA,KAAK,KAAK,KAAK,CAAC;AAChB,cAAA,MAAM,IAAM,IAAI;AACtB,cAAM,KAAK,IAAM,KAAK,KAAK,CAAC;AAC5B,cAAM,KAAK,IAAI;AAGV,gBAAA,MAAM,IACA,KAAK,KAAA,IAAS,OAEX,IAAM,IAAI,IAAM,IAAI,KACrB,KAAK,KAAM,IAAM,KAAM,KAAK,MAAW,KAAA,GAAG,MAE5C,IAAA;MAAA;MAaf,OAAO,QAAQ,KAAa,KAAa,KAAa,KAAa,QACnE;AACU,cAAA,QAAQ,OAAO,OAAO,SAAS,CAAA;AAC/B,cAAA,QAAQ,OAAO,OAAO,SAAS,CAAA;AAE/B,cAAA,IAAI,OAAO,eACb,gBAAe,YAAY,OAAO,OAAO,KAAK,KAAK,KAAK,GAAG,CAC/D;AAEA,YAAI,KAAK;AACT,YAAI,KAAK;AAET,iBAAS,IAAI,GAAG,KAAK,GAAG,EAAE,GAC1B;AACI,gBAAM,IAAI,IAAI;AAET,eAAA,SAAU,MAAM,SAAS;AACzB,eAAA,SAAU,MAAM,SAAS;AAE9B,iBAAO,KAAK,MAAgB,OAAA,MAAM,OAAO,IAAM,MAAM,GACjD,MAAgB,OAAA,MAAM,OAAO,IAAM,MAAM,CAAE;QAAA;MACnD;IAER;;;;;ICnDa,eAaA,YAOA;;;;;;;;;;;;;;;;;AApBN,IAAM,gBAAoD;MAC7D,CAAC,OAAO,IAAO,GAAA;MACf,CAAC,OAAO,IAAO,GAAA;MACf,CAAC,OAAO,IAAO,GAAA;MACf,CAAC,OAAO,IAAO,GAAA;MACf,CAAC,OAAO,IAAO,GAAA;IACnB;AAOO,IAAM,aAA+B,CAAA;AAOrC,IAAM,iBAAuC,CAAA;;;;;IC7B9C,UAUO,mBAAA;;;;;;;;;;AAVb,IAAM,WAAW,IAAI,MAAM;AAUpB,IAAM,oBAAN,cAA+B,cACtC;MAsEI,cACA;AACU,cAAA;AAnEV,aAAO,gBAAgB;AAGvB,aAAO,gBAAgB;AAEI,aAAA,aAAA;AACgB,aAAA,gBAAA;AAC/B,aAAA,YAAA;AAGZ,aAAA,SAAmB,CAAA;AAGnB,aAAA,SAAmB,CAAA;AAGnB,aAAA,MAAgB,CAAA;AAGhB,aAAA,UAAoB,CAAA;AAGpB,aAAA,aAAuB,CAAA;AAMvB,aAAA,eAAoC,CAAA;AAMpC,aAAA,YAAkC,CAAA;AAGrB,aAAA,aAAA;AAOb,aAAA,UAA4B,CAAA;AAG5B,aAAU,QAAQ;AAGlB,aAAU,aAAa;AAGvB,aAAU,aAAa;AAGvB,aAAU,aAAa;AAGb,aAAA,UAAkB,IAAI,OAAO;AAGvC,aAAU,cAAc;MAAA;MAiBxB,IAAW,SACX;AACI,aAAK,cAAc;AAEf,YAAA,KAAK,gBAAgB,KAAK,OAC9B;AACI,eAAK,cAAc,KAAK;AACxB,eAAK,gBAAgB;QAAA;AAGzB,eAAO,KAAK;MAAA;MAIhB,aACA;AACI,aAAK,cAAc;AACd,aAAA;AACA,aAAA;AACL,aAAK,aAAa;AAElB,aAAK,OAAO,SAAS;AACrB,aAAK,OAAO,SAAS;AACrB,aAAK,IAAI,SAAS;AAClB,aAAK,QAAQ,SAAS;AACtB,aAAK,WAAW,SAAS;AAEzB,iBAAS,IAAI,GAAG,IAAI,KAAK,UAAU,QAAQ,KAC3C;AACS,eAAA,UAAU,CAAG,EAAA,SAAS,MAAM;AAClB,yBAAA,KAAK,KAAK,UAAU,CAAE,CAAA;QAAA;AAGzC,aAAK,UAAU,SAAS;AAExB,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACU,gBAAA,YAAY,KAAK,QAAQ,CAAA;AAE/B,oBAAU,MAAM;AAChB,qBAAW,KAAK,SAAS;QAAA;AAG7B,aAAK,QAAQ,SAAS;MAAA;MAO1B,QACA;AACQ,YAAA,KAAK,aAAa,SAAS,GAC/B;AACI,eAAK,WAAW;AACX,eAAA;AACL,eAAK,aAAa,SAAS;QAAA;AAGxB,eAAA;MAAA;MAWJ,UACH,OACA,YAAuB,MACvB,YAAuB,MACvB,SAAiB,MACrB;AACI,cAAM,OAAO,IAAI,aAAa,OAAO,WAAW,WAAW,MAAM;AAE5D,aAAA,aAAa,KAAK,IAAI;AACtB,aAAA;AAEE,eAAA;MAAA;MASX,SAAgB,OAAe,SAAiB,MAChD;AACQ,YAAA,CAAC,KAAK,aAAa,QACvB;AACW,iBAAA;QAAA;AAGX,cAAM,OAAO,IAAI,aAAa,OAAO,MAAM,MAAM,MAAM;AAEvD,cAAM,YAAY,KAAK,aAAa,KAAK,aAAa,SAAS,CAAA;AAE/D,aAAK,YAAY,UAAU;AAEjB,kBAAA,MAAM,KAAK,IAAI;AAEpB,aAAA;AAEE,eAAA;MAAA;MAIX,UACA;AACI,cAAM,QAAQ;AAGd,iBAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,EAAE,GAChD;AACS,eAAA,aAAa,CAAA,EAAG,QAAQ;QAAA;AAGjC,aAAK,OAAO,SAAS;AACrB,aAAK,SAAS;AACd,aAAK,OAAO,SAAS;AACrB,aAAK,SAAS;AACd,aAAK,IAAI,SAAS;AAClB,aAAK,MAAM;AACX,aAAK,QAAQ,SAAS;AACtB,aAAK,UAAU;AACf,aAAK,YAAY,QAAQ;AACzB,aAAK,cAAc;AACnB,aAAK,aAAa,SAAS;AAC3B,aAAK,eAAe;AACpB,aAAK,UAAU,SAAS;AACxB,aAAK,YAAY;AACjB,aAAK,QAAQ,SAAS;AACtB,aAAK,UAAU;AACf,aAAK,UAAU;MAAA;MAQZ,cAAc,OACrB;AACI,cAAM,eAAe,KAAK;AAE1B,iBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,EAAE,GAC3C;AACI,gBAAM,OAAO,aAAa,CAAA;AAEtB,cAAA,CAAC,KAAK,UAAU,SACpB;AACI;UAAA;AAIJ,cAAI,KAAK,OACT;AACI,gBAAI,KAAK,QACT;AACS,mBAAA,OAAO,aAAa,OAAO,QAAQ;YAAA,OAG5C;AACI,uBAAS,SAAS,KAAK;YAAA;AAG3B,gBAAI,KAAK,MAAM,SAAS,SAAS,GAAG,SAAS,CAAC,GAC9C;AACI,kBAAI,UAAU;AAEd,kBAAI,KAAK,OACT;AACI,yBAAS,KAAI,GAAG,KAAI,KAAK,MAAM,QAAQ,MACvC;AACU,wBAAA,OAAO,KAAK,MAAM,EAAA;AAExB,sBAAI,KAAK,MAAM,SAAS,SAAS,GAAG,SAAS,CAAC,GAC9C;AACc,8BAAA;AACV;kBAAA;gBACJ;cACJ;AAGJ,kBAAI,CAAC,SACL;AACW,uBAAA;cAAA;YACX;UACJ;QACJ;AAGG,eAAA;MAAA;MAOX,gBACA;AACQ,YAAA,CAAC,KAAK,aAAa,QACvB;AACI,eAAK,YAAY;AAEjB;QAAA;AAGA,YAAA,CAAC,KAAK,iBAAA,GACV;AACI;QAAA;AAGJ,aAAK,aAAa,KAAK;AAEvB,cAAM,MAAM,KAAK;AACjB,cAAM,eAAe,KAAK;AAE1B,YAAI,YAAuB;AAE3B,YAAI,eAAe;AAEf,YAAA,KAAK,QAAQ,SAAS,GAC1B;AACI,sBAAY,KAAK,QAAQ,KAAK,QAAQ,SAAS,CAAA;AAC/C,yBAAe,UAAU;QAAA;AAG7B,iBAAS,IAAI,KAAK,YAAY,IAAI,aAAa,QAAQ,KACvD;AACS,eAAA;AAEL,gBAAM,OAAO,aAAa,CAAA;AAC1B,gBAAM,YAAY,KAAK;AACvB,gBAAM,YAAY,KAAK;AACjB,gBAAA,UAAU,cAAc,KAAK,IAAA;AAGnC,kBAAQ,MAAM,IAAI;AAElB,cAAI,KAAK,QACT;AACI,iBAAK,gBAAgB,KAAK,QAAQ,KAAK,MAAM;UAAA;AAG7C,cAAA,UAAU,WAAW,UAAU,SACnC;AACS,iBAAA,aAAa,KAAK,KAAK;UAAA;AAGhC,mBAAS,IAAI,GAAG,IAAI,GAAG,KACvB;AACU,kBAAA,QAAS,MAAM,IAAK,YAAY;AAEtC,gBAAI,CAAC,MAAM;AAAS;AAEd,kBAAA,cAAc,MAAM,QAAQ;AAC5B,kBAAA,SAAQ,KAAK,QAAQ;AACrB,kBAAA,cAAc,KAAK,OAAO,SAAS;AAEzC,wBAAY,WAAW,WAAW;AAElC,gBAAI,MAAM,GACV;AACI,mBAAK,YAAY,IAAI;YAAA,OAGzB;AACI,mBAAK,YAAY,IAAI;YAAA;AAGzB,kBAAM,OAAQ,KAAK,OAAO,SAAS,IAAK;AAExC,gBAAI,SAAS;AAAG;AAEhB,gBAAI,aAAa,CAAC,KAAK,eAAe,cAAc,KAAK,GACzD;AACc,wBAAA,IAAI,QAAO,WAAW;AACpB,0BAAA;YAAA;AAGhB,gBAAI,CAAC,WACL;AACI,0BAAY,WAAW,IAAA,KAAS,IAAI,UAAU;AACpC,wBAAA,MAAM,OAAO,QAAO,WAAW;AACpC,mBAAA,QAAQ,KAAK,SAAS;AACZ,6BAAA;YAAA;AAGd,iBAAA,OAAO,KAAK,QAAQ,KAAK,MAAM,SAAS,aAAa,MAAM,MAAM,MAAM;UAAA;QAChF;AAGE,cAAA,QAAQ,KAAK,QAAQ;AACrB,cAAA,SAAS,KAAK,OAAO,SAAS;AAEpC,YAAI,WACJ;AACc,oBAAA,IAAI,OAAO,MAAM;QAAA;AAG3B,YAAA,KAAK,QAAQ,WAAW,GAC5B;AAGI,eAAK,YAAY;AAEjB;QAAA;AAGJ,cAAM,SAAS,SAAS;AAGxB,YAAI,KAAK,iBAAiB,KAAK,QAAQ,WAAW,KAAK,cAAc,UAC9D,WAAY,KAAK,cAAc,oBAAoB,GAC1D;AACS,eAAA,cAAc,IAAI,KAAK,OAAO;QAAA,OAGvC;AACS,eAAA,gBAAgB,SAAS,IAAI,YAAY,KAAK,OAAO,IAAI,IAAI,YAAY,KAAK,OAAO;QAAA;AAIzF,aAAA,YAAY,KAAK,YAAY;AAElC,YAAI,KAAK,WACT;AACI,eAAK,YAAY;QAAA,OAGrB;AACI,eAAK,eAAe;QAAA;MACxB;MAQM,eAAe,QAA+B,QACxD;AACQ,YAAA,CAAC,UAAU,CAAC,QAChB;AACW,iBAAA;QAAA;AAGX,YAAI,OAAO,QAAQ,gBAAgB,OAAO,QAAQ,aAClD;AACW,iBAAA;QAAA;AAGX,YAAI,OAAO,QAAQ,OAAO,UAAU,OAAO,QAAQ,OAAO,OAC1D;AACW,iBAAA;QAAA;AAGX,YAAI,CAAC,CAAE,OAAqB,WAAW,CAAC,CAAE,OAAqB,QAC/D;AACW,iBAAA;QAAA;AAGJ,eAAA;MAAA;MAIX,mBACA;AACI,YAAI,KAAK,UAAU,KAAK,cAAc,CAAC,KAAK,aAAa,QACzD;AACW,iBAAA;QAAA;AAGF,iBAAA,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,IAAI,GAAG,KACrD;AACU,gBAAA,OAAO,KAAK,aAAa,CAAA;AAC/B,gBAAM,OAAO,KAAK;AAClB,gBAAM,OAAO,KAAK;AAElB,cAAI,QAAQ,CAAC,KAAK,QAAQ,YAAY;AAAc,mBAAA;AACpD,cAAI,QAAQ,CAAC,KAAK,QAAQ,YAAY;AAAc,mBAAA;QAAA;AAGjD,eAAA;MAAA;MAIX,cACA;AACS,aAAA;AACL,aAAK,aAAa,IAAI,aAAa,KAAK,GAAG;AAE3C,cAAM,UAAU,KAAK;AAErB,iBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,IAAI,GAAG,KAC3C;AACI,gBAAM,QAAQ,QAAQ,CAAA;AAEtB,mBAAS,IAAI,GAAG,IAAI,MAAM,MAAM,KAChC;AACU,kBAAA,QAAQ,MAAM,QAAQ;AAE5B,iBAAK,cAAc,KAAA,IAAS,KAAK,cAAc,KAAA,IAAS,MAAM;UAAA;QAClE;MACJ;MAOJ,cACA;AAEI,YAAI,KAAK,OAAO,SAAS,QAAS,GAClC;AACW,iBAAA;QAAA;AAGX,cAAM,UAAU,KAAK;AAErB,iBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KACpC;AACS,cAAA,QAAQ,CAAG,EAAA,MAAoB,QACpC;AACW,mBAAA;UAAA;QACX;AAGJ,eAAQ,KAAK,OAAO,SAAS,kBAAiB,iBAAiB;MAAA;MAInE,iBACA;AACQ,YAAA,OAAO,EAAE,YAAY;AAEzB,iBAAS,IAAI,GAAG,IAAI,KAAK,UAAU,QAAQ,KAC3C;AACS,eAAA,UAAU,CAAG,EAAA,SAAS,MAAM;AAClB,yBAAA,KAAK,KAAK,UAAU,CAAE,CAAA;QAAA;AAGzC,aAAK,UAAU,SAAS;AAExB,cAAM,SAAS,KAAK;AACpB,cAAM,aAAa,KAAK;AAEpB,YAAA,eAA8B,eAAe,IAAI;AAErD,YAAI,CAAC,cACL;AACI,yBAAe,IAAI,cAAc;AACpB,uBAAA,WAAW,IAAI,kBAAkB;QAAA;AAElD,qBAAa,SAAS,QAAQ;AAC9B,qBAAa,QAAQ;AACrB,qBAAa,OAAO;AACpB,qBAAa,OAAO,WAAW;AAE/B,YAAI,eAAe;AACnB,YAAI,iBAAiB;AACrB,YAAI,YAAY;AAChB,YAAI,SAAS;AACb,YAAI,WAAW,WAAW;AAE1B,YAAI,QAAQ;AAEP,aAAA,UAAU,KAAK,YAAY;AAGhC,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACU,gBAAA,OAAO,KAAK,QAAQ,CAAA;AAG1B,gBAAM,cAAc;AAGpB,gBAAM,QAAQ,KAAK;AAEb,gBAAA,cAAc,MAAM,QAAQ;AAElC,cAAI,WAAW,CAAC,CAAC,MAAM,QACvB;AACa,qBAAA,CAAC,CAAC,MAAM;AACN,uBAAA,SAAS,WAAW,QAAQ,WAAW;AAGjC,6BAAA;AACF,2BAAA;AACf;UAAA;AAGJ,cAAI,mBAAmB,aACvB;AACqB,6BAAA;AAEb,gBAAA,YAAY,kBAAkB,MAClC;AACI,kBAAI,iBAAiB,aACrB;AACI;AAEe,+BAAA;AAEX,oBAAA,aAAa,OAAO,GACxB;AACI,iCAAe,eAAe,IAAI;AAClC,sBAAI,CAAC,cACL;AACI,mCAAe,IAAI,cAAc;AACpB,iCAAA,WAAW,IAAI,kBAAkB;kBAAA;AAE7C,uBAAA,UAAU,KAAK,YAAY;gBAAA;AAGpC,6BAAa,QAAQ;AACrB,6BAAa,OAAO;AACpB,6BAAa,SAAS,QAAQ;AAC9B,6BAAa,OAAO;cAAA;AAKxB,0BAAY,UAAU;AAEtB,0BAAY,gBAAgB;AAC5B,0BAAY,iBAAiB;AAC7B,0BAAY,WAAW,WAAW;AAElC,2BAAa,SAAS,SAAS,aAAa,SAAS,OAAW,IAAA;AAChE;YAAA;UACJ;AAGJ,uBAAa,QAAQ,KAAK;AAC1B,mBAAS,KAAK;AAEd,sBAAY,YAAY;AAEnB,eAAA,UAAU,QAAQ,MAAM,OAAO,MAAM,OAAO,KAAK,YAAY,KAAK,WAAW;AAClF,eAAK,cAAc,YAAY,WAAW,KAAK,YAAY,KAAK,WAAW;QAAA;AAG/E,oBAAY,eAAe;AAI3B,aAAK,eAAe;MAAA;MAIxB,iBACA;AACI,cAAM,QAAQ,KAAK;AACnB,cAAM,MAAM,KAAK;AACjB,cAAM,SAAS,KAAK;AACpB,cAAM,aAAa,KAAK;AAGxB,cAAM,WAAW,IAAI,YAAY,MAAM,SAAS,IAAI,CAAC;AAC/C,cAAA,MAAM,IAAI,aAAa,QAAQ;AAC/B,cAAA,MAAM,IAAI,YAAY,QAAQ;AAEpC,YAAI,IAAI;AAER,iBAAS,IAAI,GAAG,IAAI,MAAM,SAAS,GAAG,KACtC;AACQ,cAAA,GAAA,IAAO,MAAM,IAAI,CAAA;AACjB,cAAA,GAAA,IAAO,MAAO,IAAI,IAAK,CAAA;AAEvB,cAAA,GAAA,IAAO,IAAI,IAAI,CAAA;AACf,cAAA,GAAA,IAAO,IAAK,IAAI,IAAK,CAAA;AAEzB,cAAI,GAAA,IAAO,OAAO,CAAA;AAElB,cAAI,GAAA,IAAO,WAAW,CAAA;QAAA;AAGrB,aAAA,QAAQ,OAAO,QAAQ;AACvB,aAAA,aAAa,OAAO,KAAK,aAAa;MAAA;MAOrC,YAAY,MACtB;AACQ,YAAA,KAAK,MAAM,QACf;AACc,oBAAA,YAAY,MAAM,IAAI;QAAA,OAGpC;AACU,gBAAA,UAAU,cAAc,KAAK,IAAA;AAE3B,kBAAA,YAAY,MAAM,IAAI;QAAA;MAClC;MAOM,YAAY,MACtB;AACI,kBAAU,MAAM,IAAI;AAEpB,iBAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KACvC;AACc,oBAAA,KAAK,MAAM,CAAA,GAAI,IAAI;QAAA;MACjC;MAOM,aAAa,OACvB;AACI,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAClC;AACI,gBAAM,OAAO,MAAM,CAAA;AACb,gBAAA,UAAU,cAAc,KAAK,IAAA;AAEnC,kBAAQ,MAAM,IAAI;AAElB,cAAI,KAAK,QACT;AACI,iBAAK,gBAAgB,KAAK,QAAQ,KAAK,MAAM;UAAA;QACjD;MACJ;MAIJ,kBACA;AACI,cAAM,SAAS,KAAK;AAEpB,eAAO,MAAM;AACb,eAAO,cAAe,KAAK,QAAgB,GAAG,KAAK,OAAO,MAAM;AAChE,eAAO,IAAI,KAAK,eAAe,KAAK,aAAa;MAAA;MAQ3C,gBAAgB,QAAuB,QACjD;AACI,iBAAS,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KACvC;AACU,gBAAA,IAAI,OAAQ,IAAI,CAAA;AAChB,gBAAA,IAAI,OAAQ,IAAI,IAAK,CAAA;AAEnB,iBAAA,IAAI,CAAA,IAAO,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO;AACnD,iBAAA,IAAI,IAAK,CAAM,IAAA,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO;QAAA;MACnE;MAWJ,UACI,QACA,OACA,OACA,MACA,SAAS,GACb;AACI,cAAM,MAAM,MAAM,OACb,SAAS,KAAK,EACd,qBAAqB;AAE1B,cAAM,SAAS,MAAM,OAChB,SAAS,GAAG,EACZ,gBAAgB,KAAK;AAE1B,eAAO,SAAS,KAAK,IAAI,OAAO,QAAQ,SAAS,IAAI;AAErD,iBAAS,IAAI,GAAG,IAAI,MAAM,KAC1B;AACI,iBAAO,SAAS,CAAK,IAAA;QAAA;MACzB;MAUJ,cACI,YACA,IACA,MACA,SAAS,GACb;AACI,mBAAW,SAAS,KAAK,IAAI,WAAW,QAAQ,SAAS,IAAI;AAE7D,iBAAS,IAAI,GAAG,IAAI,MAAM,KAC1B;AACI,qBAAW,SAAS,CAAK,IAAA;QAAA;MAC7B;MAYM,OACN,OACA,KACA,SACA,OACA,MACA,SAAiB,MACrB;AACI,YAAI,QAAQ;AACZ,cAAM,WAAW,IAAI;AACrB,cAAM,QAAQ,QAAQ;AAEtB,eAAO,QAAQ,MACf;AACQ,cAAA,IAAI,OAAO,QAAQ,SAAS,CAAA;AAChC,cAAI,IAAI,OAAgB,QAAA,SAAS,IAAK,CAAA;AAEtC,cAAI,QACJ;AACI,kBAAM,KAAM,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO;AAEpD,gBAAK,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO;AACzC,gBAAA;UAAA;AAGR;AAEA,cAAI,KAAK,IAAI,MAAM,OAAO,IAAI,MAAM,MAAM;QAAA;AAG9C,cAAM,cAAc,QAAQ;AAE5B,YAAI,MAAM,QAAQ,YAAY,SACvB,MAAM,SAAS,YAAY,QAClC;AACI,eAAK,UAAU,KAAK,SAAS,UAAU,IAAI;QAAA;MAC/C;MAWJ,UAAoB,KAAoB,SAAkB,OAAe,MACzE;AACI,cAAM,cAAc,QAAQ;AAC5B,cAAM,MAAM;AACN,cAAA,SAAS,QAAS,OAAO;AAC/B,cAAM,QAAQ,QAAQ;AAChB,cAAA,SAAS,MAAM,QAAQ,YAAY;AACnC,cAAA,SAAS,MAAM,SAAS,YAAY;AACtC,YAAA,UAAU,MAAM,IAAI,MAAM;AAC1B,YAAA,UAAU,MAAM,IAAI,MAAM;AAC9B,YAAI,OAAO,KAAK,MAAM,IAAI,KAAA,IAAS,GAAG;AACtC,YAAI,OAAO,KAAK,MAAM,IAAI,QAAQ,CAAA,IAAK,GAAG;AAE1C,iBAAS,IAAI,QAAQ,GAAG,IAAI,QAAQ,KAAK,GACzC;AACW,iBAAA,KAAK,IAAI,MAAM,KAAK,MAAM,IAAI,CAAA,IAAK,GAAG,CAAC;AACvC,iBAAA,KAAK,IAAI,MAAM,KAAK,MAAM,IAAI,IAAI,CAAK,IAAA,GAAG,CAAC;QAAA;AAE3C,mBAAA;AACA,mBAAA;AACX,iBAAS,IAAI,OAAO,IAAI,QAAQ,KAAK,GACrC;AACQ,cAAA,CAAA,KAAU,IAAA,CAAA,IAAK,WAAW;AAC9B,cAAI,IAAI,CAAA,KAAU,IAAA,IAAI,CAAA,IAAK,WAAW;QAAA;MAC1C;IAER;AAv3BO,IAAM,mBAAN;AAAM,qBAGK,iBAAiB;;;;;IC5BtB;;;;AAAN,IAAM,YAAN,MAAM,WACb;MAyBI,cACA;AArBA,aAAO,QAAQ;AAGf,aAAO,QAAQ;AAMf,aAAO,UAAmB,QAAQ;AAMlC,aAAO,SAAiB;AAGxB,aAAO,UAAU;AAIb,aAAK,MAAM;MAAA;MAIf,QACA;AACU,cAAA,MAAM,IAAI,WAAU;AAE1B,YAAI,QAAQ,KAAK;AACjB,YAAI,QAAQ,KAAK;AACjB,YAAI,UAAU,KAAK;AACnB,YAAI,SAAS,KAAK;AAClB,YAAI,UAAU,KAAK;AAEZ,eAAA;MAAA;MAIX,QACA;AACI,aAAK,QAAQ;AACb,aAAK,QAAQ;AACb,aAAK,UAAU,QAAQ;AACvB,aAAK,SAAS;AACd,aAAK,UAAU;MAAA;MAInB,UACA;AACI,aAAK,UAAU;AACf,aAAK,SAAS;MAAA;IAEtB;;;;;IC9Da;;;;;AAAN,IAAM,YAAN,MAAM,mBAAkB,UAC/B;MADO,cAAA;AAAA,cAAA,GAAA,SAAA;AAGH,aAAO,QAAQ;AAGf,aAAO,YAAY;AAGnB,aAAO,SAAS;AAOhB,aAAO,MAAM,SAAS;AAOtB,aAAO,OAAO,UAAU;AAGxB,aAAO,aAAa;MAAA;MAGpB,QACA;AACU,cAAA,MAAM,IAAI,WAAU;AAE1B,YAAI,QAAQ,KAAK;AACjB,YAAI,QAAQ,KAAK;AACjB,YAAI,UAAU,KAAK;AACnB,YAAI,SAAS,KAAK;AAClB,YAAI,UAAU,KAAK;AACnB,YAAI,QAAQ,KAAK;AACjB,YAAI,YAAY,KAAK;AACrB,YAAI,SAAS,KAAK;AAClB,YAAI,MAAM,KAAK;AACf,YAAI,OAAO,KAAK;AAChB,YAAI,aAAa,KAAK;AAEf,eAAA;MAAA;MAIX,QACA;AACI,cAAM,MAAM;AAGZ,aAAK,QAAQ;AAEb,aAAK,YAAY;AACjB,aAAK,QAAQ;AACb,aAAK,SAAS;MAAA;IAEtB;;;;;ICJM,iBAsBO,WAAA;;;;;;;;;;;;;AAtBb,IAAM,kBAA2C,CAAA;AAsB1C,IAAM,YAAN,cAAuB,UAC9B;MAkFI,YAAY,WAA6B,MACzC;AACU,cAAA;AA5DV,aAAO,SAAiB;AAGxB,aAAO,aAAa;AAMpB,aAAO,cAAuB;AAG9B,aAAU,UAAwC,CAAA;AAGlD,aAAU,YAAY;AAGtB,aAAU,aAAa;AAGvB,aAAU,aAA2B;AAG3B,aAAA,aAAwB,IAAI,UAAU;AAGtC,aAAA,aAAwB,IAAI,UAAU;AAGhD,aAAU,UAAkB;AAG5B,aAAU,YAAY;AAQd,aAAA,QAAe,MAAM,MAAM;AAqB1B,aAAA,YAAY,YAAY,IAAI,iBAAiB;AAClD,aAAK,UAAU;AAcf,aAAK,eAAe;AAGf,aAAA,aAAa,IAAI,MAAM,QAAQ;AACpC,aAAK,YAAY,YAAY;MAAA;MA/BjC,IAAW,WACX;AACI,eAAO,KAAK;MAAA;MAqChB,QACA;AACI,aAAK,WAAW;AAET,eAAA,IAAI,UAAS,KAAK,SAAS;MAAA;MAWtC,IAAW,UAAU,OACrB;AACI,aAAK,MAAM,YAAY;MAAA;MAG3B,IAAW,YACX;AACI,eAAO,KAAK,MAAM;MAAA;MAQtB,IAAW,OACX;AACI,eAAO,KAAK,WAAW;MAAA;MAG3B,IAAW,KAAK,OAChB;AACS,aAAA,WAAW,SAAS,KAAK;MAAA;MAOlC,IAAW,OACX;AACI,eAAO,KAAK;MAAA;MAOhB,IAAW,OACX;AACI,eAAO,KAAK;MAAA;MAiCT,UAAU,UAAsC,MACnD,QAAqB,GAAK,OAAgB,YAAY,KAAK,SAAS,OACxE;AAEQ,YAAA,OAAO,YAAY,UACvB;AACI,oBAAU,EAAE,OAAO,SAAS,OAAO,OAAO,WAAW,OAAO;QAAA;AAGzD,eAAA,KAAK,iBAAiB,OAAO;MAAA;MAoBjC,iBAAiB,SACxB;AAEI,cAAM,0BAA6C;UAC/C,OAAO;UACP,SAAS,QAAQ;UACjB,QAAO,mCAAS,WAAU,WAAW;UACrC,QAAQ;UACR,WAAW;UACX,QAAQ;UACR,KAAK,SAAS;UACd,MAAM,UAAU;UAChB,YAAY;QAAA;AAGN,kBAAA,OAAO,OAAO,yBAAyB,OAAO;AAExD,aAAK,eAAe,OAAO;AAE3B,YAAI,KAAK,aACT;AACI,eAAK,UAAU;QAAA;AAGnB,cAAM,UAAU,QAAQ,QAAQ,KAAK,QAAQ,QAAQ;AAErD,YAAI,CAAC,SACL;AACI,eAAK,WAAW,MAAM;QAAA,OAG1B;AACI,cAAI,QAAQ,QACZ;AACY,oBAAA,SAAS,QAAQ,OAAO,MAAM;AACtC,oBAAQ,OAAO,OAAO;UAAA;AAG1B,iBAAO,OAAO,KAAK,YAAY,EAAE,QAAA,GAAW,OAAO;QAAA;AAGhD,eAAA;MAAA;MAOX,YACA;AACI,YAAI,KAAK,aACT;AACU,gBAAA,SAAS,KAAK,YAAY;AAC1B,gBAAA,MAAM,KAAK,YAAY,OAAO;AAEpC,cAAI,MAAM,GACV;AACS,iBAAA,UAAU,KAAK,WAAW;AAC1B,iBAAA,cAAc,IAAI,QAAQ;AAC/B,iBAAK,YAAY,cAAc;AAC1B,iBAAA,YAAY,OAAO,KAAK,OAAO,MAAM,CAAI,GAAA,OAAO,MAAM,CAAE,CAAA;UAAA;QACjE,OAGJ;AACS,eAAA,cAAc,IAAI,QAAQ;AAC/B,eAAK,YAAY,cAAc;QAAA;MACnC;MAOJ,aACA;AACI,YAAI,KAAK,aACT;AACI,cAAI,KAAK,YAAY,OAAO,SAAS,GACrC;AACS,iBAAA,UAAU,KAAK,WAAW;AAC/B,iBAAK,cAAc;UAAA,OAGvB;AACS,iBAAA,YAAY,OAAO,SAAS;UAAA;QACrC;MACJ;MASG,OAAO,GAAW,GACzB;AACI,aAAK,UAAU;AACV,aAAA,YAAY,OAAO,CAAK,IAAA;AACxB,aAAA,YAAY,OAAO,CAAK,IAAA;AAEtB,eAAA;MAAA;MAUJ,OAAO,GAAW,GACzB;AACQ,YAAA,CAAC,KAAK,aACV;AACS,eAAA,OAAO,GAAG,CAAC;QAAA;AAId,cAAA,SAAS,KAAK,YAAY;AAC1B,cAAA,QAAQ,OAAO,OAAO,SAAS,CAAA;AAC/B,cAAA,QAAQ,OAAO,OAAO,SAAS,CAAA;AAEjC,YAAA,UAAU,KAAK,UAAU,GAC7B;AACW,iBAAA,KAAK,GAAG,CAAC;QAAA;AAGb,eAAA;MAAA;MAQX,WAAqB,IAAI,GAAG,IAAI,GAChC;AACI,YAAI,KAAK,aACT;AACI,cAAI,KAAK,YAAY,OAAO,WAAW,GACvC;AACI,iBAAK,YAAY,SAAS,CAAC,GAAG,CAAC;UAAA;QACnC,OAGJ;AACS,eAAA,OAAO,GAAG,CAAC;QAAA;MACpB;MAYJ,iBAAwB,KAAa,KAAa,KAAa,KAC/D;AACI,aAAK,WAAW;AAEV,cAAA,SAAS,KAAK,YAAY;AAE5B,YAAA,OAAO,WAAW,GACtB;AACS,eAAA,OAAO,GAAG,CAAC;QAAA;AAGpB,uBAAe,QAAQ,KAAK,KAAK,KAAK,KAAK,MAAM;AAE1C,eAAA;MAAA;MAaX,cAAqB,KAAa,KAAa,MAAc,MAAc,KAAa,KACxF;AACI,aAAK,WAAW;AAEJ,oBAAA,QAAQ,KAAK,KAAK,MAAM,MAAM,KAAK,KAAK,KAAK,YAAY,MAAM;AAEpE,eAAA;MAAA;MAiBX,MAAa,IAAY,IAAY,IAAY,IAAY,QAC7D;AACS,aAAA,WAAW,IAAI,EAAE;AAEhB,cAAA,SAAS,KAAK,YAAY;AAE1B,cAAA,SAAS,SAAS,QAAQ,IAAI,IAAI,IAAI,IAAI,QAAQ,MAAM;AAE9D,YAAI,QACJ;AACI,gBAAM,EAAE,IAAI,IAAI,QAAQ,SAAA,YAAY,UAAU,cAAkB,IAAA;AAEhE,eAAK,IAAI,IAAI,IAAI,SAAQ,YAAY,UAAU,aAAa;QAAA;AAGzD,eAAA;MAAA;MAgBJ,IAAI,IAAY,IAAY,QAAgB,YAAoB,UAAkB,gBAAgB,OACzG;AACI,YAAI,eAAe,UACnB;AACW,iBAAA;QAAA;AAGP,YAAA,CAAC,iBAAiB,YAAY,YAClC;AACgB,sBAAA;QAAA,WAEP,iBAAiB,cAAc,UACxC;AACkB,wBAAA;QAAA;AAGlB,cAAM,QAAQ,WAAW;AAEzB,YAAI,UAAU,GACd;AACW,iBAAA;QAAA;AAGX,cAAM,SAAS,KAAM,KAAK,IAAI,UAAU,IAAI;AAC5C,cAAM,SAAS,KAAM,KAAK,IAAI,UAAU,IAAI;AACtC,cAAA,MAAM,KAAK,UAAU;AAG3B,YAAI,SAAS,KAAK,cAAc,KAAK,YAAY,SAAS;AAE1D,YAAI,QACJ;AAII,gBAAM,QAAQ,KAAK,IAAI,OAAO,OAAO,SAAS,CAAA,IAAK,MAAM;AACzD,gBAAM,QAAQ,KAAK,IAAI,OAAO,OAAO,SAAS,CAAA,IAAK,MAAM;AAErD,cAAA,QAAQ,OAAO,QAAQ,KAC3B;UAAA,OAKA;AACW,mBAAA,KAAK,QAAQ,MAAM;UAAA;QAC9B,OAGJ;AACS,eAAA,OAAO,QAAQ,MAAM;AAC1B,mBAAS,KAAK,YAAY;QAAA;AAGrB,iBAAA,IAAI,QAAQ,QAAQ,IAAI,IAAI,QAAQ,YAAY,UAAU,eAAe,MAAM;AAEjF,eAAA;MAAA;MAUX,UAAiB,QAAqB,GAAG,OACzC;AACW,eAAA,KAAK,iBAAiB,EAAE,SAAS,QAAQ,OAAO,OAAO,MAAA,CAAO;MAAA;MAOjE,eAAe,SACvB;AACI,cAAM,OAAO,MAAM,OAAO,SAAS,QAAQ,SAAS,CAAC;AAE7C,gBAAA,QAAQ,KAAK,SAAS;AACtB,gBAAA,UAAA,QAAA,QAAU,KAAK;MAAA;MAa3B,iBAAiB,SACjB;AAEI,cAAM,iBAAoC;UACtC,SAAS,QAAQ;UACjB,OAAO;UACP,QAAQ;QAAA;AAGF,kBAAA,OAAO,OAAO,gBAAgB,OAAO;AAE/C,aAAK,eAAe,OAAO;AAE3B,YAAI,KAAK,aACT;AACI,eAAK,UAAU;QAAA;AAGb,cAAA,UAAU,QAAQ,QAAQ;AAEhC,YAAI,CAAC,SACL;AACI,eAAK,WAAW,MAAM;QAAA,OAG1B;AACI,cAAI,QAAQ,QACZ;AACY,oBAAA,SAAS,QAAQ,OAAO,MAAM;AACtC,oBAAQ,OAAO,OAAO;UAAA;AAG1B,iBAAO,OAAO,KAAK,YAAY,EAAE,QAAA,GAAW,OAAO;QAAA;AAGhD,eAAA;MAAA;MAOX,UACA;AACI,aAAK,WAAW;AAEhB,aAAK,WAAW,MAAM;AAEf,eAAA;MAAA;MAWX,SAAgB,GAAW,GAAW,OAAe,QACrD;AACW,eAAA,KAAK,UAAU,IAAI,UAAU,GAAG,GAAG,OAAO,MAAM,CAAC;MAAA;MAY5D,gBAAuB,GAAW,GAAW,OAAe,QAAgB,QAC5E;AACW,eAAA,KAAK,UAAU,IAAI,iBAAiB,GAAG,GAAG,OAAO,QAAQ,MAAM,CAAC;MAAA;MAU3E,WAAkB,GAAW,GAAW,QACxC;AACI,eAAO,KAAK,UAAU,IAAI,OAAO,GAAG,GAAG,MAAM,CAAC;MAAA;MAWlD,YAAmB,GAAW,GAAW,OAAe,QACxD;AACW,eAAA,KAAK,UAAU,IAAI,QAAQ,GAAG,GAAG,OAAO,MAAM,CAAC;MAAA;MAWnD,eAAe,MACtB;AACQ,YAAA;AACJ,YAAI,cAAc;AAElB,cAAM,OAAO,KAAK,CAAA;AAGlB,YAAI,KAAK,QACT;AACI,wBAAc,KAAK;AACnB,mBAAS,KAAK;QAAA,WAGd,MAAM,QAAQ,KAAK,CAAA,CAAE,GACzB;AACI,mBAAS,KAAK,CAAA;QAAA,OAGlB;AACa,mBAAA;QAAA;AAGP,cAAA,QAAQ,IAAI,QAAQ,MAAM;AAEhC,cAAM,cAAc;AAEpB,aAAK,UAAU,KAAK;AAEb,eAAA;MAAA;MAQJ,UAAU,OACjB;AACQ,YAAA,CAAC,KAAK,WACV;AACI,eAAK,UAAU,UACX,OACA,KAAK,WAAW,MAAA,GAChB,KAAK,WAAW,MAAA,GAChB,KAAK,OACT;QAAA,OAGJ;AACI,eAAK,UAAU,SAAS,OAAO,KAAK,OAAO;QAAA;AAGxC,eAAA;MAAA;MAOX,QACA;AACI,aAAK,UAAU,MAAM;AACrB,aAAK,WAAW,MAAM;AACtB,aAAK,WAAW,MAAM;AAEjB,aAAA;AACL,aAAK,UAAU;AACf,aAAK,YAAY;AACjB,aAAK,cAAc;AAEZ,eAAA;MAAA;MAQX,aACA;AACU,cAAA,OAAO,KAAK,UAAU;AAErB,eAAA,KAAK,WAAW,KAChB,KAAK,CAAA,EAAG,MAAM,SAAS,OAAO,QAC9B,CAAC,KAAK,CAAA,EAAG,UACT,CAAC,KAAK,CAAG,EAAA,MAAM,UACf,EAAO,KAAA,CAAA,EAAG,UAAU,WAAW,KAAK,CAAA,EAAG,UAAU;MAAA;MAOlD,QAAQ,UAClB;AACI,aAAK,WAAW;AAEhB,cAAM,WAAW,KAAK;AAItB,iBAAS,cAAc;AAEvB,YAAI,SAAS,WACb;AACQ,cAAA,KAAK,eAAe,SAAS,YACjC;AACI,iBAAK,iBAAiB;UAAA;AAG1B,eAAK,eAAe,QAAQ;QAAA,OAGhC;AAEI,mBAAS,MAAM,MAAM;AAErB,eAAK,cAAc,QAAQ;QAAA;MAC/B;MAIJ,mBACA;AACI,cAAM,WAAW,KAAK;AACtB,cAAM,YAAY,KAAK;AACjB,cAAA,MAAM,SAAS,QAAQ;AAE7B,aAAK,YAAY;AACjB,aAAK,eAAe;AACpB,aAAK,aAAa,SAAS;AAC3B,aAAK,QAAQ,SAAS;AAEtB,aAAK,aAAa,IAAI,aAAa,SAAS,MAAM;AAElD,iBAAS,IAAI,GAAG,IAAI,KAAK,KACzB;AACU,gBAAA,KAAK,SAAS,QAAQ,CAAA;AACtB,gBAAA,QAAQ,GAAG,MAAM;AACvB,gBAAM,aAAa,IAAI,aAAa,KAAK,WAAW,QAChD,GAAG,cAAc,IAAI,GACrB,GAAG,aAAa,CAAC;AAErB,gBAAM,MAAM,IAAI,aAAa,SAAS,WAAW,QAC7C,GAAG,cAAc,IAAI,GACrB,GAAG,aAAa,CAAC;AAEf,gBAAAC,WAAU,IAAI,YAAY,SAAS,cAAc,QACnD,GAAG,QAAQ,GACX,GAAG,IAAI;AAEX,gBAAM,QAAQ;YACV;YACA;YACA,SAAAA;YACA;YACA,WAAW,MAAM,OAAO,SAAS,KAAK,EAAE,WAAW;YACnD,UAAU;YACV,UAAU,GAAG,MAAM;YACnB,OAAO,GAAG,MAAM;YAChB,YAAY;UAAA;AAGhB,eAAK,QAAQ,CAAK,IAAA;QAAA;MACtB;MAOM,eAAe,UACzB;AACQ,YAAA,CAAC,KAAK,QAAQ,QAClB;AACI;QAAA;AAGJ,iBAAS,MAAM,kBAAkB,SAAS,QAAQ,KAAK,UAAW,CAAA;AAElE,aAAK,kBAAkB;AACvB,aAAK,eAAe;AAEX,iBAAA,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,IAAI,GAAG,KAChD;AACU,gBAAA,QAAQ,KAAK,QAAQ,CAAA;AAErB,gBAAA,aAAa,KAAK,aAAa,MAAM;AAE3C,mBAAS,QAAQ,KAAK,UAAY,EAAA,OAAO,KAAK;QAAA;MAClD;MAOM,cAAc,UACxB;AACU,cAAA,SAAS,KAAK,qBAAqB,QAAQ;AAEjD,cAAM,WAAW,KAAK;AACtB,cAAM,aAAa,KAAK;AACxB,cAAM,WAAW,OAAO;AACxB,cAAM,YAAY,SAAS;AAGlB,iBAAA,oBAAoB,KAAK,UAAU;AAGtC,cAAA,OAAO,SAAS,KAAK,UAAU,EAChC,YAAY,UAAU,EACtB,QAAQ,SAAS,IAAI;AAOjB,iBAAA,OAAO,KAAK,MAAM;AAClB,iBAAA,SAAS,KAAK,UAAU,MAAM;AAG9B,iBAAA,MAAM,IAAI,KAAK,KAAK;AAG7B,iBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,IAAI,GAAG,KAC7C;AACI,eAAK,sBAAsB,UAAU,SAAS,UAAU,CAAE,CAAA;QAAA;MAC9D;MAQM,sBAAsB,UAAoB,UACpD;AACI,cAAM,EAAE,UAAU,MAAM,MAAM,MAAU,IAAA;AACxC,cAAM,oBAAoB,SAAS;AAEnC,iBAAS,IAAI,GAAG,IAAI,mBAAmB,KACvC;AACI,mBAAS,QAAQ,KAAK,SAAS,SAAS,CAAA,GAAI,CAAC;QAAA;AAGjD,iBAAS,SAAS,KAAK,MAAM,MAAM,KAAK;MAAA;MAOlC,qBAAqB,UAC/B;AACI,YAAI,SAAS,KAAK;AAElB,cAAM,aAAa,KAAK;AAExB,YAAI,CAAC,QACL;AAIQ,cAAA,CAAC,gBAAgB,UACrB,GAAA;AACU,kBAAA,EAAE,YAAgB,IAAA,SAAS,QAAQ,UAAA;AACnC,kBAAA,eAAe,IAAI,WAAW,WAAW;AAE/C,qBAAS,IAAI,GAAG,IAAI,aAAa,KACjC;AACI,2BAAa,CAAK,IAAA;YAAA;AAGtB,kBAAM,WAAW;cACb,MAAM,IAAI,aAAa,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;cACnC,mBAAmB,IAAI,OAAO;cAC9B,SAAS,aAAa,KAAK,EAAE,WAAW,aAAA,GAAgB,IAAI;YAAA;AAGhE,kBAAM,UAAU,SAAS,QAAQ,UAAA,EAAY,QAAQ;AAErD,4BAAgB,UAAc,IAAA,IAAI,OAAO,SAAS,QAAQ;UAAA;AAG9D,mBAAS,gBAAgB,UAAA;QAAA;AAGtB,eAAA;MAAA;MAOX,mBACA;AACI,aAAK,WAAW;AAEhB,cAAM,WAAW,KAAK;AAGlB,YAAA,CAAC,SAAS,aAAa,QAC3B;AACI;QAAA;AAGJ,cAAM,EAAE,MAAM,MAAM,MAAM,KAAA,IAAS,SAAS;AAE5C,aAAK,QAAQ,SAAS,KAAK,WAAW,MAAM,MAAM,MAAM,IAAI;MAAA;MAQzD,cAAc,OACrB;AACI,aAAK,eAAe,aAAa,OAAO,UAAS,WAAW;AAE5D,eAAO,KAAK,UAAU,cAAc,UAAS,WAAW;MAAA;MAI5D,iBACA;AACQ,YAAA,KAAK,cAAc,KAAK,MAC5B;AACS,eAAA,YAAY,KAAK,WAAW,SAAS;AAE1C,mBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACU,kBAAA,QAAQ,KAAK,QAAQ,CAAA;AAErB,kBAAA,WAAW,MAAM,OAClB,SAAS,KAAK,UAAU,EACxB,SAAS,MAAM,SAAS,EACxB,qBAAqB;UAAA;QAC9B;MACJ;MAIJ,oBACA;AACU,cAAA,OAAO,KAAK,UAAU;AAExB,YAAA,KAAK,iBAAiB,MAC1B;AACI;QAAA;AAGJ,aAAK,eAAe;AAEd,cAAA,KAAK,KAAK,UAAU;AAC1B,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AACb,cAAM,KAAK,GAAG;AACd,cAAM,KAAK,GAAG;AAER,cAAA,OAAO,KAAK,UAAU;AAC5B,cAAM,aAAa,KAAK;AAExB,YAAI,QAAQ;AAEZ,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GACtC;AACI,gBAAM,IAAI,KAAK,CAAA;AACT,gBAAA,IAAI,KAAK,IAAI,CAAA;AAEnB,qBAAW,OAAY,IAAA,IAAI,IAAM,IAAI,IAAK;AAC1C,qBAAW,OAAY,IAAA,IAAI,IAAM,IAAI,IAAK;QAAA;MAC9C;MAOJ,YACA;AACI,cAAM,cAAc,KAAK;AAEzB,YAAI,aACJ;AAEI,sBAAY,cAAc;AAG1B,eAAK,WAAW;QAAA;AAGb,eAAA;MAAA;MAQJ,UAAU,QACjB;AACI,aAAK,UAAU;AAER,eAAA;MAAA;MAWX,YACA;AACI,aAAK,WAAW;AAChB,aAAK,YAAY;AAEV,eAAA;MAAA;MAOX,UACA;AACI,aAAK,WAAW;AAChB,aAAK,YAAY;AAEV,eAAA;MAAA;MAcJ,QAAQ,SACf;AACI,aAAK,UAAU;AACX,YAAA,KAAK,UAAU,aAAa,GAChC;AACI,eAAK,UAAU,QAAQ;QAAA;AAG3B,aAAK,UAAU;AACf,aAAK,cAAc;AACnB,aAAK,WAAW,QAAQ;AACxB,aAAK,aAAa;AAClB,aAAK,WAAW,QAAQ;AACxB,aAAK,aAAa;AAClB,aAAK,YAAY;AACjB,aAAK,SAAS;AACd,aAAK,aAAa;AAClB,aAAK,QAAQ,SAAS;AACtB,aAAK,UAAU;AAEf,cAAM,QAAQ,OAAO;MAAA;IAE7B;AA7nCO,IAAM,WAAN;AAAM,aAac,SAAS;AAMhC,aAAO,cAAc,IAAI,MAAM;;;;;IC7EtB;;;;;;;;;;;;;;;;;;;AAAN,IAAM,gBAAgB;MACzB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACJ;;;;;ICnCa;;;;AAAN,IAAM,gBAAN,cAA4B,aACnC;MAYI,YAAY,QAAQ,KAAK,SAAS,KAAK,WAAW,IAAI,YAAY,IAClE;AACU,cAAA;AAEN,aAAK,WAAW;AAChB,aAAK,YAAY;AAEjB,aAAK,QAAQ;AACb,aAAK,SAAS;AAEd,aAAK,MAAM;MAAA;MAOf,QACA;AACU,cAAA,QAAQ,KAAK,WAAW,KAAK;AACnC,cAAM,QAAQ,CAAA;AACd,cAAM,MAAM,CAAA;AACZ,cAAMC,WAAU,CAAA;AAEV,cAAA,YAAY,KAAK,WAAW;AAC5B,cAAA,YAAY,KAAK,YAAY;AAE7B,cAAA,QAAS,KAAK,QAAS;AACvB,cAAA,QAAS,KAAK,SAAU;AAE9B,iBAAS,IAAI,GAAG,IAAI,OAAO,KAC3B;AACU,gBAAA,IAAK,IAAI,KAAK;AACd,gBAAA,IAAM,IAAI,KAAK,WAAY;AAEjC,gBAAM,KAAK,IAAI,OAAO,IAAI,KAAK;AAC/B,cAAI,KAAK,IAAI,WAAW,IAAI,SAAS;QAAA;AAGzC,cAAM,WAAW,YAAY;AAE7B,iBAAS,IAAI,GAAG,IAAI,UAAU,KAC9B;AACI,gBAAM,OAAO,IAAI;AACX,gBAAA,OAAQ,IAAI,YAAa;AAEzB,gBAAA,QAAS,OAAO,KAAK,WAAY;AACvC,gBAAM,SAAU,OAAO,KAAK,WAAY,OAAO;AAC/C,gBAAM,UAAW,OAAO,KAAK,KAAK,WAAY;AAC9C,gBAAM,UAAW,OAAO,KAAK,KAAK,WAAY,OAAO;AAErD,UAAAA,SAAQ,KAAK,OAAO,QAAQ,QACxB,QAAQ,QAAQ,MAAM;QAAA;AAG9B,aAAK,QAAQ,CAAA,EAAG,OAAO,IAAI,aAAa,KAAK;AAC7C,aAAK,QAAQ,CAAA,EAAG,OAAO,IAAI,aAAa,GAAG;AAC3C,aAAK,YAAY,OAAO,IAAI,YAAYA,QAAO;AAG1C,aAAA,QAAQ,CAAA,EAAG,OAAO;AAClB,aAAA,QAAQ,CAAA,EAAG,OAAO;AACvB,aAAK,YAAY,OAAO;MAAA;IAEhC;;;;;ICnEa;;;;AAAN,IAAM,eAAN,cAA2B,aAClC;MAwBI,YAAY,QAAQ,KAAK,QAAkB,eAAe,GAC1D;AACI,cAAM,IAAI,aAAa,OAAO,SAAS,CAAC,GACpC,IAAI,aAAa,OAAO,SAAS,CAAC,GAClC,IAAI,aAAa,OAAO,SAAS,KAAK,CAAC,CAAC;AAE5C,aAAK,SAAS;AACd,aAAK,SAAS;AACd,aAAK,eAAe;AAEpB,aAAK,MAAM;MAAA;MAOf,IAAI,QACJ;AACI,eAAO,KAAK;MAAA;MAIhB,QACA;AACI,cAAM,SAAS,KAAK;AAEpB,YAAI,CAAC;AAAQ;AAEP,cAAA,eAAe,KAAK,UAAU,iBAAiB;AAC/C,cAAA,WAAW,KAAK,UAAU,eAAe;AACzC,cAAA,cAAc,KAAK,SAAS;AAG9B,YAAA,OAAO,SAAS,GACpB;AACI;QAAA;AAIJ,YAAI,aAAa,KAAK,SAAS,MAAM,OAAO,QAC5C;AACI,uBAAa,OAAO,IAAI,aAAa,OAAO,SAAS,CAAC;AACtD,mBAAS,OAAO,IAAI,aAAa,OAAO,SAAS,CAAC;AAClD,sBAAY,OAAO,IAAI,aAAoB,OAAA,SAAS,KAAK,CAAC;QAAA;AAG9D,cAAM,MAAM,SAAS;AACrB,cAAMC,WAAU,YAAY;AAE5B,YAAI,CAAK,IAAA;AACT,YAAI,CAAK,IAAA;AACT,YAAI,CAAK,IAAA;AACT,YAAI,CAAK,IAAA;AAET,YAAI,SAAS;AACb,YAAI,OAAO,OAAO,CAAA;AACZ,cAAA,eAAe,KAAK,SAAS,KAAK;AACxC,cAAM,QAAQ,OAAO;AAErB,iBAAS,IAAI,GAAG,IAAI,OAAO,KAC3B;AAEI,gBAAM,QAAQ,IAAI;AAEd,cAAA,KAAK,eAAe,GACxB;AAEI,kBAAM,KAAK,KAAK,IAAI,OAAO,CAAG,EAAA;AAC9B,kBAAM,KAAK,KAAK,IAAI,OAAO,CAAG,EAAA;AAC9B,kBAAM,WAAW,KAAK,KAAM,KAAK,KAAO,KAAK,EAAG;AAEhD,mBAAO,OAAO,CAAA;AACd,sBAAU,WAAW;UAAA,OAGzB;AAEI,qBAAS,KAAa,QAAA;UAAA;AAG1B,cAAI,KAAS,IAAA;AACb,cAAI,QAAQ,CAAK,IAAA;AAEjB,cAAI,QAAQ,CAAK,IAAA;AACjB,cAAI,QAAQ,CAAK,IAAA;QAAA;AAGrB,YAAI,aAAa;AAEjB,iBAAS,IAAI,GAAG,IAAI,QAAQ,GAAG,KAC/B;AACI,gBAAM,QAAQ,IAAI;AAElB,UAAAA,SAAQ,YAAgB,IAAA;AACxB,UAAAA,SAAQ,YAAA,IAAgB,QAAQ;AAChC,UAAAA,SAAQ,YAAA,IAAgB,QAAQ;AAEhC,UAAAA,SAAQ,YAAA,IAAgB,QAAQ;AAChC,UAAAA,SAAQ,YAAA,IAAgB,QAAQ;AAChC,UAAAA,SAAQ,YAAA,IAAgB,QAAQ;QAAA;AAIpC,iBAAS,OAAO;AAChB,oBAAY,OAAO;AAEnB,aAAK,eAAe;MAAA;MAIxB,iBACA;AACI,cAAM,SAAS,KAAK;AAEhB,YAAA,OAAO,SAAS,GACpB;AACI;QAAA;AAGJ,YAAI,YAAY,OAAO,CAAA;AACnB,YAAA;AACJ,YAAI,QAAQ;AACZ,YAAI,QAAQ;AAEN,cAAA,WAAW,KAAK,QAAQ,CAAG,EAAA;AACjC,cAAM,QAAQ,OAAO;AACf,cAAA,YAAY,KAAK,eAAe,IAAI,KAAK,eAAe,KAAK,SAAS,IAAI,KAAK,SAAS;AAE9F,iBAAS,IAAI,GAAG,IAAI,OAAO,KAC3B;AACI,gBAAM,QAAQ,OAAO,CAAA;AACrB,gBAAM,QAAQ,IAAI;AAEd,cAAA,IAAI,OAAO,SAAS,GACxB;AACI,wBAAY,OAAO,IAAI,CAAA;UAAA,OAG3B;AACgB,wBAAA;UAAA;AAGR,kBAAA,EAAY,UAAA,IAAI,UAAU;AAC1B,kBAAA,UAAU,IAAI,UAAU;AAEhC,cAAI,SAAS,IAAK,KAAK,QAAQ,MAAO;AAEtC,cAAI,QAAQ,GACZ;AACY,oBAAA;UAAA;AAGZ,gBAAM,aAAa,KAAK,KAAM,QAAQ,QAAU,QAAQ,KAAM;AAE9D,cAAI,aAAa,MACjB;AACY,oBAAA;AACA,oBAAA;UAAA,OAGZ;AACa,qBAAA;AACA,qBAAA;AAEA,qBAAA;AACA,qBAAA;UAAA;AAGJ,mBAAA,KAAA,IAAS,MAAM,IAAI;AACnB,mBAAA,QAAQ,CAAK,IAAA,MAAM,IAAI;AACvB,mBAAA,QAAQ,CAAK,IAAA,MAAM,IAAI;AACvB,mBAAA,QAAQ,CAAK,IAAA,MAAM,IAAI;AAEpB,sBAAA;QAAA;AAGX,aAAA,QAAQ,CAAA,EAAG,OAAO;MAAA;MAG3B,SACA;AACQ,YAAA,KAAK,eAAe,GACxB;AACI,eAAK,MAAM;QAAA,OAGf;AACI,eAAK,eAAe;QAAA;MACxB;IAER;;;;;ICrNa;;;;;;AAAN,IAAM,cAAN,cAA0B,KACjC;MAWI,YAAY,SAAkB,WAAoB,WAClD;AACU,cAAA,gBAAgB,IAAI,cAAc,QAAQ,OAAO,QAAQ,QAAQ,WAAW,SAAS;AAC3F,cAAM,eAAe,IAAI,aAAa,QAAQ,KAAK;AAEnD,cAAM,eAAe,YAAY;AAGjC,aAAK,UAAU;AACf,aAAK,aAAa;MAAA;MAOtB,iBACA;AACS,aAAA,aAAa,KAAK,OAAO,QAAQ;AAEtC,cAAM,WAA0B,KAAK;AACrC,cAAM,EAAE,OAAO,OAAW,IAAA,KAAK,OAAO;AAEtC,YAAI,KAAK,eAAe,SAAS,UAAU,SAAS,SAAS,WAAW,SACxE;AACa,mBAAA,QAAQ,KAAK,OAAO,QAAQ;AAC5B,mBAAA,SAAS,KAAK,OAAO,QAAQ;AACtC,mBAAS,MAAM;QAAA;MACnB;MAGJ,IAAI,QAAQ,OACZ;AAKQ,YAAA,KAAK,OAAO,YAAY,OAC5B;AACI;QAAA;AAGJ,aAAK,OAAO,UAAU;AACtB,aAAK,aAAa;AAEd,YAAA,MAAM,YAAY,OACtB;AACI,eAAK,eAAe;QAAA,OAGxB;AACI,gBAAM,KAAK,UAAU,KAAK,gBAAgB,IAAI;QAAA;MAClD;MAGJ,IAAI,UACJ;AACI,eAAO,KAAK,OAAO;MAAA;MAGvB,QAAQ,UACR;AACI,YAAI,KAAK,eAAe,KAAK,OAAO,QAAQ,WAC5C;AACI,eAAK,eAAe;QAAA;AAGxB,cAAM,QAAQ,QAAQ;MAAA;MAGnB,QAAQ,SACf;AACI,aAAK,OAAO,QAAQ,IAAI,UAAU,KAAK,gBAAgB,IAAI;AAC3D,cAAM,QAAQ,OAAO;MAAA;IAE7B;;;;;ICpGM,qBAgCO;;;;;AAhCb,IAAM,sBAAsB;AAgCrB,IAAM,iBAAN,cAA6B,YACpC;MAmCI,YACI,SACA,WACA,WACA,YACA,cAEJ;;AACU,cAAA,QAAQ,OAAO,GAAG,CAAC;AAEpB,aAAA,aAAa,QAAQ,KAAK;AAC1B,aAAA,cAAc,QAAQ,KAAK;AAGhC,aAAK,SAAS,KAAK;AAGnB,aAAK,UAAU,KAAK;AAEpB,aAAK,aAAa,eAAa,aAAQ,mBAAR,mBAAwB,SAAQ;AAC/D,aAAK,cAAc,gBAAc,aAAQ,mBAAR,mBAAwB,UAAS;AAClE,aAAK,aAAa,eAAa,aAAQ,mBAAR,mBAAwB,QAAO;AAC9D,aAAK,gBAAgB,kBAAgB,aAAQ,mBAAR,mBAAwB,WAAU;AAGvE,aAAK,UAAU;MAAA;MAGnB,iBACA;AACS,aAAA,aAAa,KAAK,OAAO,QAAQ;AACtC,aAAK,SAAS;MAAA;MAGlB,IAAI,WACJ;AACI,eAAO,KAAK,SAAS,UAAU,iBAAiB,EAAE;MAAA;MAGtD,IAAI,SAAS,OACb;AACI,aAAK,SAAS,UAAU,iBAAiB,EAAE,OAAO;MAAA;MAItD,2BACA;AACI,cAAM,WAAW,KAAK;AAEhB,cAAA,QAAQ,KAAK,aAAa;AAEvB,iBAAA,CAAA,IAAK,SAAS,EAAM,IAAA,SAAS,EAAA,IAAM,SAAS,EAAA,IAAM,KAAK,aAAa;AACpE,iBAAA,EAAA,IAAM,SAAS,EAAA,IAAM,SAAS,EAAA,IAAM,SAAS,EAAM,IAAA,KAAK,UAAW,KAAK,gBAAgB;AACjG,iBAAS,EAAA,IAAM,SAAS,EAAA,IAAM,SAAS,EAAM,IAAA,SAAS,EAAA,IAAM,KAAK;MAAA;MAIrE,yBACA;AACI,cAAM,WAAW,KAAK;AAEhB,cAAA,QAAQ,KAAK,aAAa;AAEvB,iBAAA,CAAA,IAAK,SAAS,EAAM,IAAA,SAAS,EAAA,IAAM,SAAS,EAAA,IAAM,KAAK,aAAa;AACpE,iBAAA,CAAA,IAAK,SAAS,EAAA,IAAM,SAAS,EAAA,IAAM,SAAS,EAAM,IAAA,KAAK,SAAU,KAAK,cAAc;AAC7F,iBAAS,CAAA,IAAK,SAAS,EAAA,IAAM,SAAS,EAAM,IAAA,SAAS,EAAA,IAAM,KAAK;MAAA;MAOpE,eACA;AACU,cAAA,IAAI,KAAK,aAAa,KAAK;AACjC,cAAM,SAAS,KAAK,SAAS,IAAI,IAAM,KAAK,SAAS;AAE/C,cAAA,IAAI,KAAK,aAAa,KAAK;AACjC,cAAM,SAAS,KAAK,UAAU,IAAI,IAAM,KAAK,UAAU;AAEvD,cAAM,QAAQ,KAAK,IAAI,QAAQ,MAAM;AAE9B,eAAA;MAAA;MAIX,IAAI,QACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,MAAM,OACV;AACI,aAAK,SAAS;AACd,aAAK,SAAS;MAAA;MAIlB,IAAI,SACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,OAAO,OACX;AACI,aAAK,UAAU;AACf,aAAK,SAAS;MAAA;MAIlB,IAAI,YACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,UAAU,OACd;AACI,aAAK,aAAa;AAClB,aAAK,SAAS;MAAA;MAIlB,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,WAAW,OACf;AACI,aAAK,cAAc;AACnB,aAAK,SAAS;MAAA;MAIlB,IAAI,YACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,UAAU,OACd;AACI,aAAK,aAAa;AAClB,aAAK,SAAS;MAAA;MAIlB,IAAI,eACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,aAAa,OACjB;AACI,aAAK,gBAAgB;AACrB,aAAK,SAAS;MAAA;MAIlB,WACA;AACI,cAAM,UAAU,KAAK;AAErB,cAAM,MAAM,KAAK,SAAS,QAAQ,CAAG,EAAA;AAEhC,aAAA,aAAa,QAAQ,KAAK;AAC1B,aAAA,cAAc,QAAQ,KAAK;AAE1B,cAAA,OAAO,IAAM,KAAK;AAClB,cAAA,OAAO,IAAM,KAAK;AAExB,YAAI,CAAA,IAAK,IAAI,CAAA,IAAK,IAAI,EAAA,IAAM,IAAI,EAAM,IAAA;AACtC,YAAI,CAAA,IAAK,IAAI,CAAA,IAAK,IAAI,CAAA,IAAK,IAAI,CAAK,IAAA;AACpC,YAAI,CAAA,IAAK,IAAI,EAAA,IAAM,IAAI,EAAA,IAAM,IAAI,EAAM,IAAA;AACvC,YAAI,EAAA,IAAM,IAAI,EAAA,IAAM,IAAI,EAAA,IAAM,IAAI,EAAM,IAAA;AAEpC,YAAA,CAAA,IAAK,IAAI,EAAM,IAAA,IAAI,EAAA,IAAM,IAAI,EAAA,IAAM,OAAO,KAAK;AAC/C,YAAA,CAAA,IAAK,IAAI,EAAM,IAAA,IAAI,EAAA,IAAM,IAAI,EAAA,IAAM,IAAK,OAAO,KAAK;AACpD,YAAA,CAAA,IAAK,IAAI,EAAM,IAAA,IAAI,EAAA,IAAM,IAAI,EAAA,IAAM,OAAO,KAAK;AAC/C,YAAA,EAAA,IAAM,IAAI,EAAM,IAAA,IAAI,EAAA,IAAM,IAAI,EAAA,IAAM,IAAK,OAAO,KAAK;AAEzD,aAAK,yBAAyB;AAC9B,aAAK,uBAAuB;AAEvB,aAAA,SAAS,QAAQ,CAAA,EAAG,OAAO;AAC3B,aAAA,SAAS,QAAQ,CAAA,EAAG,OAAO;MAAA;IAExC;;;;;ICzPa;;;;;AAAN,IAAM,aAAN,cAAyB,KAChC;MAWI,YACI,UAAmB,QAAQ,OAC3B,UACA,KACAC,UACA,UAEJ;AACI,cAAM,WAAW,IAAI,aAAa,UAAU,KAAKA,QAAO;AAE/C,iBAAA,UAAU,iBAAiB,EAAE,SAAS;AAEzC,cAAA,eAAe,IAAI,aAAa,OAAO;AAEvC,cAAA,UAAU,cAAc,MAAM,QAAQ;AAE5C,aAAK,aAAa;MAAA;MAOtB,IAAI,WACJ;AACI,eAAO,KAAK,SAAS,UAAU,iBAAiB,EAAE;MAAA;MAEtD,IAAI,SAAS,OACb;AACI,aAAK,SAAS,UAAU,iBAAiB,EAAE,OAAO;MAAA;MAGtD,QAAQ,UACR;AACI,YAAI,KAAK,YACT;AACI,eAAK,SAAS,UAAU,iBAAiB,EAAE,OAAO;QAAA;AAGtD,cAAM,QAAQ,QAAQ;MAAA;IAE9B;;;;;IC9Ca;;;;;;AAAN,IAAM,aAAN,cAAyB,KAChC;MAWI,YAAY,SAAkB,QAAkB,eAAe,GAC/D;AACI,cAAM,eAAe,IAAI,aAAa,QAAQ,QAAQ,QAAQ,YAAY;AACpE,cAAA,eAAe,IAAI,aAAa,OAAO;AAE7C,YAAI,eAAe,GACnB;AAEY,kBAAA,YAAY,WAAW,WAAW;QAAA;AAE9C,cAAM,cAAc,YAAY;AAMhC,aAAK,aAAa;MAAA;MAGtB,QAAQ,UACR;AACI,cAAM,WAAyB,KAAK;AAEpC,YAAI,KAAK,cAAc,SAAS,WAAW,KAAK,OAAO,QAAQ,QAC/D;AACa,mBAAA,SAAS,KAAK,OAAO,QAAQ;AACtC,mBAAS,OAAO;QAAA;AAGpB,cAAM,QAAQ,QAAQ;MAAA;IAE9B;;;;;AC5DA,IAAAC,YAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;ICqCa;;;;;AAAN,IAAM,oBAAN,cAAgC,UACvC;MA8EI,YAAY,UAAU,MAAM,YAAkC,YAAY,OAAO,aAAa,OAC9F;AACU,cAAA;AAKN,cAAM,eAAe;AAErB,YAAI,YAAY,cAChB;AACgB,sBAAA;QAAA;AAGhB,aAAK,cAAc,CAAC,OAAO,MAAM,OAAO,OAAO,KAAK;AACpD,aAAK,WAAW;AAChB,aAAK,aAAa;AAClB,aAAK,WAAW;AAChB,aAAK,mBAAmB,CAAA;AACxB,aAAK,YAAY;AAEjB,aAAK,sBAAsB;AAC3B,aAAK,YAAY,YAAY;AAC7B,aAAK,aAAa;AAClB,aAAK,cAAc;AACnB,aAAK,cAAc;AAEnB,aAAK,cAAc,UAAU;AAExB,aAAA,aAAa,IAAI,MAAM,CAAC;AACxB,aAAA,UAAU,IAAI,aAAa,CAAC;AACjC,aAAK,OAAO;MAAA;MAOT,cAAc,YACrB;AACI,YAAI,YACJ;AACI,eAAK,YAAY,CAAA,IAAK,cAAc,cAAc,WAAW,aACvD,CAAC,CAAC,WAAW,YAAY,CAAC,CAAC,WAAW,QAAQ,KAAK,YAAY,CAAA;AAChE,eAAA,YAAY,CAAA,IAAK,cAAc,aAAa,CAAC,CAAC,WAAW,WAAW,KAAK,YAAY,CAAA;AACrF,eAAA,YAAY,CAAA,IAAK,cAAc,aAAa,CAAC,CAAC,WAAW,WAAW,KAAK,YAAY,CAAA;AACrF,eAAA,YAAY,CAAA,IAAK,SAAS,aAAa,CAAC,CAAC,WAAW,MAAM,KAAK,YAAY,CAAA;AAChF,eAAK,YAAY,CAAA,IAAK,UAAU,cAAc,WAAW,aACnD,CAAC,CAAC,WAAW,QAAQ,CAAC,CAAC,WAAW,QAAQ,KAAK,YAAY,CAAA;QAAA;MACrE;MAGJ,kBACA;AAEI,aAAK,6BAA6B;MAAA;MAStC,IAAI,OACJ;AACI,eAAO,KAAK,WAAW;MAAA;MAG3B,IAAI,KAAK,OACT;AACS,aAAA,WAAW,SAAS,KAAK;AACzB,aAAA,WAAW,WAAW,KAAK,OAAO;MAAA;MAOpC,OAAO,UACd;AACI,YAAI,CAAC,KAAK,WAAW,KAAK,cAAc,KAAK,CAAC,KAAK,SAAS,UAAU,CAAC,KAAK,YAC5E;AACI;QAAA;AAGA,YAAA,CAAC,KAAK,aACV;AACI,eAAK,cAAc,KAAK,SAAS,CAAA,EAAG,SAAS;AACzC,cAAA,CAAC,KAAK,YAAY,OACtB;AACI,iBAAK,YAAY,KAAK,UAAU,MAAM,KAAK,iBAAiB,CAAC,CAAC;UAAA;QAClE;AAGJ,iBAAS,MAAM,kBAAkB,SAAS,QAAQ,QAAQ;AACjD,iBAAA,QAAQ,SAAS,OAAO,IAAI;MAAA;MAO/B,iBAAiB,oBAC3B;AACI,cAAM,cAAc,KAAK,MAAM,qBAAqB,KAAK,UAAU;AAE5D,eAAA,KAAK,iBAAiB,SAAS,aACtC;AACS,eAAA,iBAAiB,KAAK,CAAC;QAAA;AAE3B,aAAA,iBAAiB,WAAe,IAAA,EAAE,KAAK;MAAA;MAGhD,UACA;AACI,YAAI,KAAK,UACT;AACI,mBAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,EAAE,GAC5C;AACS,iBAAA,SAAS,CAAA,EAAG,QAAQ;UAAA;AAG7B,eAAK,WAAW;QAAA;MACpB;MAcG,QAAQ,SACf;AACI,cAAM,QAAQ,OAAO;AAErB,aAAK,QAAQ;AAEb,aAAK,cAAc;AACnB,aAAK,WAAW;AAChB,aAAK,mBAAmB;MAAA;IAEhC;;;;;ICvPa;;;;AAAN,IAAM,iBAAN,MACP;MA6BI,YAAY,YAAyC,sBAAiC,MACtF;AACS,aAAA,WAAW,IAAI,SAAS;AAE7B,aAAK,cAAc;AAEnB,aAAK,OAAO;AACZ,aAAK,oBAAoB,CAAA;AACzB,aAAK,mBAAmB,CAAA;AAExB,iBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,EAAE,GACzC;AACI,cAAI,WAAW,WAAW,CAAA;AAIf,qBAAA;YACP,eAAe,SAAS;YACxB,MAAM,SAAS;YACf,gBAAgB,SAAS;YACzB,MAAM,SAAS,QAAQ,MAAM;YAC7B,QAAQ,SAAS;UAAA;AAGrB,cAAI,qBAAqB,CACzB,GAAA;AACS,iBAAA,kBAAkB,KAAK,QAAQ;UAAA,OAGxC;AACS,iBAAA,iBAAiB,KAAK,QAAQ;UAAA;QACvC;AAGJ,aAAK,eAAe;AACpB,aAAK,eAAe;AACpB,aAAK,aAAa;AAClB,aAAK,mBAAmB;AAExB,aAAK,gBAAgB;AACrB,aAAK,gBAAgB;AACrB,aAAK,cAAc;AACnB,aAAK,oBAAoB;AAEzB,aAAK,YAAY;AAEjB,aAAK,YAAY;MAAA;MAIrB,cACA;AACI,cAAM,WAAW,KAAK;AAEtB,YAAI,gBAAgB;AAEf,aAAA,cAAc,IAAI,OAAO,YAAM,sBAAsB,KAAK,IAAI,GAAG,MAAM,IAAI;AACvE,iBAAA,SAAS,KAAK,WAAW;AAElC,aAAK,gBAAgB;AAErB,iBAAS,IAAI,GAAG,IAAI,KAAK,kBAAkB,QAAQ,EAAE,GACrD;AACU,gBAAA,WAAW,KAAK,kBAAkB,CAAA;AAExC,mBAAS,SAAS;AAClB,2BAAiB,SAAS;AAC1B,eAAK,iBAAiB,SAAS;QAAA;AAG7B,cAAA,YAAY,IAAI,YAAY,KAAK,OAAO,KAAK,gBAAgB,IAAI,CAAC;AAEnE,aAAA,cAAc,IAAI,aAAa,SAAS;AACxC,aAAA,oBAAoB,IAAI,YAAY,SAAS;AAClD,aAAK,gBAAgB,IAAI,OAAO,KAAK,aAAa,OAAO,KAAK;AAG9D,YAAI,eAAe;AAEnB,aAAK,eAAe;AAEpB,iBAAS,IAAI,GAAG,IAAI,KAAK,iBAAiB,QAAQ,EAAE,GACpD;AACU,gBAAA,WAAW,KAAK,iBAAiB,CAAA;AAEvC,mBAAS,SAAS;AAClB,0BAAgB,SAAS;AACzB,eAAK,gBAAgB,SAAS;QAAA;AAG5B,cAAA,aAAa,IAAI,YAAY,KAAK,OAAO,KAAK,eAAe,IAAI,CAAC;AAEnE,aAAA,aAAa,IAAI,aAAa,UAAU;AACxC,aAAA,mBAAmB,IAAI,YAAY,UAAU;AAClD,aAAK,eAAe,IAAI,OAAO,KAAK,YAAY,MAAM,KAAK;AAE3D,iBAAS,IAAI,GAAG,IAAI,KAAK,kBAAkB,QAAQ,EAAE,GACrD;AACU,gBAAA,WAAW,KAAK,kBAAkB,CAAA;AAExC,mBAAS,aACL,SAAS,eACT,KAAK,eACL,GACA,SAAS,SAAS,MAAM,eACxB,SAAS,MACT,KAAK,gBAAgB,GACrB,SAAS,SAAS,CACtB;QAAA;AAGJ,iBAAS,IAAI,GAAG,IAAI,KAAK,iBAAiB,QAAQ,EAAE,GACpD;AACU,gBAAA,WAAW,KAAK,iBAAiB,CAAA;AAEvC,mBAAS,aACL,SAAS,eACT,KAAK,cACL,GACA,SAAS,SAAS,MAAM,eACxB,SAAS,MACT,KAAK,eAAe,GACpB,SAAS,SAAS,CACtB;QAAA;MACJ;MASJ,cAAc,UAAoB,YAAoB,QACtD;AACI,iBAAS,IAAI,GAAG,IAAI,KAAK,kBAAkB,QAAQ,KACnD;AACU,gBAAA,WAAW,KAAK,kBAAkB,CAAA;AAExC,mBAAS,eAAe,UAAU,YAAY,QAC1C,SAAS,SAAS,MAAM,gBAAgB,KAAK,oBAAoB,KAAK,aACtE,KAAK,eAAe,SAAS,MAAM;QAAA;AAG3C,aAAK,cAAc;MAAA;MASvB,aAAa,UAAoB,YAAoB,QACrD;AACI,iBAAS,IAAI,GAAG,IAAI,KAAK,iBAAiB,QAAQ,KAClD;AACU,gBAAA,WAAW,KAAK,iBAAiB,CAAA;AAEvC,mBAAS,eAAe,UAAU,YAAY,QAC1C,SAAS,SAAS,MAAM,gBAAgB,KAAK,mBAAmB,KAAK,YACrE,KAAK,cAAc,SAAS,MAAM;QAAA;AAG1C,aAAK,aAAa;MAAA;MAItB,UACA;AACI,aAAK,cAAc;AAEnB,aAAK,oBAAoB;AACzB,aAAK,gBAAgB;AACrB,aAAK,cAAc;AACnB,aAAK,oBAAoB;AAEzB,aAAK,mBAAmB;AACxB,aAAK,eAAe;AACpB,aAAK,aAAa;AAClB,aAAK,mBAAmB;AAExB,aAAK,SAAS,QAAQ;MAAA;IAE9B;;;;;AC5OA,IAAIC;AAAJ;AAAA;AAAA,IAAIA,YAAW;AAAA;AAAA;;;ACAf,IAAIC;AAAJ;AAAA;AAAA,IAAIA,UAAS;AAAA;AAAA;;;ICkCA;;;;;;;AAAN,IAAM,mBAAN,cAA+B,eACtC;MAkBI,YAAY,UACZ;AACI,cAAM,QAAQ;AAQd,aAAK,SAAS;AAEd,aAAK,aAAa;AAEb,aAAA,aAAa,IAAI,OAAO;AAE7B,aAAK,aAAa;UAEd;YACI,eAAe;YACf,MAAM;YACN,gBAAgB,KAAK;YACrB,QAAQ;UAAA;UAGZ;YACI,eAAe;YACf,MAAM;YACN,gBAAgB,KAAK;YACrB,QAAQ;UAAA;UAGZ;YACI,eAAe;YACf,MAAM;YACN,gBAAgB,KAAK;YACrB,QAAQ;UAAA;UAGZ;YACI,eAAe;YACf,MAAM;YACN,gBAAgB,KAAK;YACrB,QAAQ;UAAA;UAGZ;YACI,eAAe;YACf,MAAM;YACN,MAAM,MAAM;YACZ,gBAAgB,KAAK;YACrB,QAAQ;UAAA;QACZ;AAGJ,aAAK,SAAS,OAAO,KAAKC,SAAQC,WAAU,CAAA,CAAE;AACzC,aAAA,QAAQ,MAAM,MAAM;MAAA;MAOtB,OAAO,WACd;AACI,cAAM,WAAW,UAAU;AAC3B,cAAM,UAAU,UAAU;AAC1B,cAAM,YAAY,UAAU;AAC5B,cAAM,WAAW,KAAK;AACtB,YAAI,gBAAgB,SAAS;AAE7B,YAAI,kBAAkB,GACtB;AACI;QAAA,WAEK,gBAAgB,WAAW,CAAC,UAAU,YAC/C;AACoB,0BAAA;QAAA;AAGpB,YAAI,UAAU,UAAU;AAExB,YAAI,CAAC,SACL;AACI,oBAAU,UAAU,WAAW,KAAK,gBAAgB,SAAS;QAAA;AAG3D,cAAA,cAAc,SAAS,CAAA,EAAG,SAAS;AACnC,cAAA,gBAAgB,YAAY,YAAY;AAG9C,aAAK,MAAM,YAAY,YAAM,iBAAiB,UAAU,WAAW,aAAa;AACvE,iBAAA,MAAM,IAAI,KAAK,KAAK;AAE7B,cAAM,KAAK,SAAS;AAEpB,cAAM,IAAI,UAAU,eAAe,OAAO,KAAK,UAAU;AAEzD,UAAE,QAAQ,SAAS,eAAe,SAAS,gBAAgB;AAE3D,aAAK,OAAO,SAAS,oBAAoB,EAAE,QAAQ,IAAI;AAEvD,aAAK,OAAO,SAAS,SAAS,MAAM,OAC/B,SAAS,UAAU,OAAO,EAC1B,YAAY,UAAU,YAAY,aAAa,EAC/C,QAAQ,KAAK,OAAO,SAAS,MAAM;AAEnC,aAAA,OAAO,SAAS,WAAW;AAEhC,aAAK,SAAS,OAAO,KAAK,KAAK,MAAM;AAErC,YAAI,eAAe;AAGV,iBAAA,IAAI,GAAG,IAAI,GAAG,IAAI,eAAe,KAAK,WAAW,KAAK,GAC/D;AACI,cAAI,SAAU,gBAAgB;AAE9B,cAAI,SAAS,WACb;AACa,qBAAA;UAAA;AAGT,cAAA,KAAK,QAAQ,QACjB;AACI,oBAAQ,KAAK,KAAK,uBAAuB,SAAS,CAAC;UAAA;AAGvD,gBAAM,SAAS,QAAQ,CAAA;AAGhB,iBAAA,cAAc,UAAU,GAAG,MAAM;AAElC,gBAAA,MAAM,UAAU,iBAAiB,CAAM,KAAA;AAE9B,yBAAA,gBAAiB,OAAO,YAAY;AAEnD,cAAI,cACJ;AACI,mBAAO,YAAY,UAAU;AACtB,mBAAA,aAAa,UAAU,GAAG,MAAM;UAAA;AAIlC,mBAAA,SAAS,KAAK,OAAO,QAAQ;AACtC,aAAG,aAAa,GAAG,WAAW,SAAS,GAAG,GAAG,gBAAgB,CAAC;QAAA;MAClE;MAQI,gBAAgB,WACxB;AACI,cAAM,UAAU,CAAA;AAChB,cAAM,OAAO,UAAU;AACvB,cAAM,YAAY,UAAU;AAC5B,cAAM,uBAAuB,UAAU;AAEvC,iBAAS,IAAI,GAAG,IAAI,MAAM,KAAK,WAC/B;AACI,kBAAQ,KAAK,IAAI,eAAe,KAAK,YAAY,sBAAsB,SAAS,CAAC;QAAA;AAG9E,eAAA;MAAA;MAQH,uBAAuB,WAC/B;AACI,cAAM,YAAY,UAAU;AAC5B,cAAM,uBAAuB,UAAU;AAEvC,eAAO,IAAI,eAAe,KAAK,YAAY,sBAAsB,SAAS;MAAA;MAY9E,eACI,UAAoB,YAAoB,QACxC,OAAiB,QAAgB,QAErC;AACI,YAAI,KAAK;AACT,YAAI,KAAK;AACT,YAAI,KAAK;AACT,YAAI,KAAK;AAET,iBAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAC9B;AACU,gBAAA,SAAS,SAAS,aAAa,CAAA;AACrC,gBAAM,UAAU,OAAO;AACjB,gBAAA,KAAK,OAAO,MAAM;AAClB,gBAAA,KAAK,OAAO,MAAM;AACxB,gBAAM,OAAO,QAAQ;AACrB,gBAAM,OAAO,QAAQ;AAErB,cAAI,MACJ;AAGI,iBAAK,KAAK,IAAK,OAAO,OAAO,IAAI,KAAK;AACtC,iBAAK,KAAK,KAAK;AAEf,iBAAK,KAAK,IAAK,OAAO,OAAO,IAAI,KAAK;AACtC,iBAAK,KAAK,KAAK;UAAA,OAGnB;AACI,iBAAM,KAAK,SAAc,IAAA,OAAO,OAAO;AACvC,iBAAM,KAAK,QAAS,CAAC,OAAO,OAAO;AAEnC,iBAAK,KAAK,UAAc,IAAA,OAAO,OAAO;AACtC,iBAAK,KAAK,SAAS,CAAC,OAAO,OAAO;UAAA;AAGtC,gBAAM,MAAA,IAAU,KAAK;AACf,gBAAA,SAAS,CAAA,IAAK,KAAK;AAEnB,gBAAA,SAAS,MAAA,IAAU,KAAK;AACxB,gBAAA,SAAS,SAAS,CAAA,IAAK,KAAK;AAE5B,gBAAA,SAAU,SAAS,CAAA,IAAM,KAAK;AACpC,gBAAM,SAAU,SAAS,IAAK,CAAA,IAAK,KAAK;AAElC,gBAAA,SAAU,SAAS,CAAA,IAAM,KAAK;AACpC,gBAAM,SAAU,SAAS,IAAK,CAAA,IAAK,KAAK;AAExC,oBAAU,SAAS;QAAA;MACvB;MAYJ,eACI,UAAoB,YAAoB,QACxC,OAAiB,QAAgB,QAErC;AACI,iBAAS,IAAI,GAAG,IAAI,QAAQ,KAC5B;AACU,gBAAA,iBAAiB,SAAS,aAAa,CAAG,EAAA;AAEhD,gBAAM,MAAA,IAAU,eAAe;AACzB,gBAAA,SAAS,CAAA,IAAK,eAAe;AAE7B,gBAAA,SAAS,MAAA,IAAU,eAAe;AAClC,gBAAA,SAAS,SAAS,CAAA,IAAK,eAAe;AAEtC,gBAAA,SAAU,SAAS,CAAA,IAAM,eAAe;AAC9C,gBAAM,SAAU,SAAS,IAAK,CAAA,IAAK,eAAe;AAE5C,gBAAA,SAAU,SAAS,CAAA,IAAM,eAAe;AAC9C,gBAAM,SAAU,SAAS,IAAK,CAAA,IAAK,eAAe;AAElD,oBAAU,SAAS;QAAA;MACvB;MAYJ,eACI,UAAoB,YAAoB,QACxC,OAAiB,QAAgB,QAErC;AACI,iBAAS,IAAI,GAAG,IAAI,QAAQ,KAC5B;AACU,gBAAA,iBAAiB,SAAS,aAAa,CAAG,EAAA;AAEhD,gBAAM,MAAU,IAAA;AAChB,gBAAM,SAAS,MAAU,IAAA;AACnB,gBAAA,SAAU,SAAS,CAAM,IAAA;AACzB,gBAAA,SAAU,SAAS,CAAM,IAAA;AAE/B,oBAAU,SAAS;QAAA;MACvB;MAYJ,UACI,UAAoB,YAAoB,QACxC,OAAiB,QAAgB,QAErC;AACI,iBAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAC9B;AACI,gBAAM,aAAa,SAAS,aAAa,CAAA,EAAG,SAAS;AAErD,cAAI,YACJ;AACI,kBAAM,MAAA,IAAU,WAAW;AACrB,kBAAA,SAAS,CAAA,IAAK,WAAW;AAEzB,kBAAA,SAAS,MAAA,IAAU,WAAW;AAC9B,kBAAA,SAAS,SAAS,CAAA,IAAK,WAAW;AAElC,kBAAA,SAAU,SAAS,CAAA,IAAM,WAAW;AAC1C,kBAAM,SAAU,SAAS,IAAK,CAAA,IAAK,WAAW;AAExC,kBAAA,SAAU,SAAS,CAAA,IAAM,WAAW;AAC1C,kBAAM,SAAU,SAAS,IAAK,CAAA,IAAK,WAAW;AAE9C,sBAAU,SAAS;UAAA,OAGvB;AAEI,kBAAM,MAAU,IAAA;AAChB,kBAAM,SAAS,CAAK,IAAA;AAEpB,kBAAM,SAAS,MAAU,IAAA;AACnB,kBAAA,SAAS,SAAS,CAAK,IAAA;AAEvB,kBAAA,SAAU,SAAS,CAAM,IAAA;AACzB,kBAAA,SAAU,SAAS,IAAK,CAAK,IAAA;AAE7B,kBAAA,SAAU,SAAS,CAAM,IAAA;AACzB,kBAAA,SAAU,SAAS,IAAK,CAAK,IAAA;AAEnC,sBAAU,SAAS;UAAA;QACvB;MACJ;MAYJ,WACI,UAAoB,YAAoB,QACxC,OAAiB,QAAgB,QAErC;AACI,iBAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAC9B;AACU,gBAAA,SAAS,SAAS,aAAa,CAAA;AACrC,gBAAM,SAAS,MAAM,OAChB,SAAS,OAAO,QAAQ,EACxB,gBAAgB,OAAO,OAAO,OAAO,QAAQ,YAAY,YAAY,CAAC;AAE3E,gBAAM,MAAU,IAAA;AAChB,gBAAM,SAAS,MAAU,IAAA;AACnB,gBAAA,SAAU,SAAS,CAAM,IAAA;AACzB,gBAAA,SAAU,SAAS,CAAM,IAAA;AAE/B,oBAAU,SAAS;QAAA;MACvB;MAIJ,UACA;AACI,cAAM,QAAQ;AAEd,YAAI,KAAK,QACT;AACI,eAAK,OAAO,QAAQ;AACpB,eAAK,SAAS;QAAA;AAGlB,aAAK,aAAa;MAAA;IAE1B;AAtaa,qBAGF,YAA+B;MAClC,MAAM;MACN,MAAM,cAAc;IACxB;AAkaJ,eAAW,IAAI,gBAAgB;;;;;AC1c/B,IAAAC,aAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;ICoCa;;;;;AAAN,IAAM,iBAAN,MAAM,wBAAuB,OACpC;MAgFI,YAAY,UAAqC,aAAa,MAC9D;AACI,cAAM,SAAS,CAAc,aAAA,UAAU,SAAS,CAAK,IAAA,SAAS,CAAA,EAAG,OAAO;AAExE,aAAK,YAAY;AACjB,aAAK,aAAa;AAClB,aAAK,cAAc;AACnB,aAAK,uBAAuB;AAE5B,aAAK,iBAAiB;AACtB,aAAK,OAAO;AACZ,aAAK,eAAe;AACpB,aAAK,aAAa;AAClB,aAAK,gBAAgB;AACrB,aAAK,SAAS;AAEd,aAAK,eAAe;AAEpB,aAAK,WAAW;AAChB,aAAK,iBAAiB;AAEtB,aAAK,WAAW;MAAA;MAIpB,OACA;AACQ,YAAA,CAAC,KAAK,UACV;AACI;QAAA;AAGJ,aAAK,WAAW;AACZ,YAAA,KAAK,eAAe,KAAK,sBAC7B;AACI,iBAAO,OAAO,OAAO,KAAK,QAAQ,IAAI;AACtC,eAAK,uBAAuB;QAAA;MAChC;MAIJ,OACA;AACI,YAAI,KAAK,UACT;AACI;QAAA;AAGJ,aAAK,WAAW;AAChB,YAAI,KAAK,eAAe,CAAC,KAAK,sBAC9B;AACI,iBAAO,OAAO,IAAI,KAAK,QAAQ,MAAM,gBAAgB,IAAI;AACzD,eAAK,uBAAuB;QAAA;MAChC;MAOG,YAAY,aACnB;AACI,aAAK,KAAK;AACV,aAAK,eAAe;MAAA;MAOjB,YAAY,aACnB;AACI,aAAK,eAAe;AACpB,aAAK,KAAK;MAAA;MAOd,OAAO,WACP;AACQ,YAAA,CAAC,KAAK,UACV;AACI;QAAA;AAGE,cAAA,UAAU,KAAK,iBAAiB;AACtC,cAAM,gBAAgB,KAAK;AAEvB,YAAA,KAAK,eAAe,MACxB;AACI,cAAI,MAAM,KAAK,eAAe,IAAI,KAAK,WAAW,KAAK,YAAA;AAEvD,iBAAO,UAAU,KAAK;AAEtB,iBAAO,MAAM,GACb;AACS,iBAAA;AACE,mBAAA,KAAK,WAAW,KAAK,YAAA;UAAA;AAGhC,gBAAM,OAAO,KAAK,KAAK,KAAK,iBAAiB,SAAS;AAEtD,eAAK,eAAe,KAAK,MAAM,KAAK,YAAY;AAEhD,iBAAO,OAAO,KAAK,WAAW,KAAK,YACnC,GAAA;AACW,mBAAA,KAAK,WAAW,KAAK,YAAgB,IAAA;AAC5C,iBAAK,gBAAgB;UAAA;AAGzB,eAAK,gBAAgB,MAAM,KAAK,WAAW,KAAK,YAAA;QAAA,OAGpD;AACI,eAAK,gBAAgB;QAAA;AAGzB,YAAI,KAAK,eAAe,KAAK,CAAC,KAAK,MACnC;AACI,eAAK,YAAY,CAAC;AAElB,cAAI,KAAK,YACT;AACI,iBAAK,WAAW;UAAA;QACpB,WAEK,KAAK,gBAAgB,KAAK,UAAU,UAAU,CAAC,KAAK,MAC7D;AACI,eAAK,YAAY,KAAK,UAAU,SAAS,CAAC;AAE1C,cAAI,KAAK,YACT;AACI,iBAAK,WAAW;UAAA;QACpB,WAEK,kBAAkB,KAAK,cAChC;AACQ,cAAA,KAAK,QAAQ,KAAK,QACtB;AACS,gBAAA,KAAK,iBAAiB,KAAK,KAAK,eAAe,iBAC5C,KAAK,iBAAiB,KAAK,KAAK,eAAe,eACvD;AACI,mBAAK,OAAO;YAAA;UAChB;AAGJ,eAAK,cAAc;QAAA;MACvB;MAIJ,gBACA;AACI,cAAM,eAAe,KAAK;AAEtB,YAAA,KAAK,mBAAmB,cAC5B;AACI;QAAA;AAGJ,aAAK,iBAAiB;AAEjB,aAAA,WAAW,KAAK,UAAU,YAAA;AAC/B,aAAK,aAAa;AAClB,aAAK,oBAAoB;AACzB,aAAK,cAAc;AACd,aAAA,MAAM,KAAK,SAAS,KAAK;AAE9B,YAAI,KAAK,cACT;AACI,eAAK,QAAQ,SAAS,KAAK,SAAS,aAAa;QAAA;AAGrD,YAAI,KAAK,eACT;AACS,eAAA,cAAc,KAAK,YAAY;QAAA;MACxC;MAYG,QAAQ,SACf;AACI,aAAK,KAAK;AACV,cAAM,QAAQ,OAAO;AAErB,aAAK,aAAa;AAClB,aAAK,gBAAgB;AACrB,aAAK,SAAS;MAAA;MAQlB,OAAc,WAAW,QACzB;AACI,cAAM,WAAW,CAAA;AAEjB,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GACrC;AACI,mBAAS,KAAK,QAAQ,KAAK,OAAO,CAAA,CAAE,CAAC;QAAA;AAGlC,eAAA,IAAI,gBAAe,QAAQ;MAAA;MAQtC,OAAc,WAAW,QACzB;AACI,cAAM,WAAW,CAAA;AAEjB,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GACrC;AACI,mBAAS,KAAK,QAAQ,KAAK,OAAO,CAAA,CAAE,CAAC;QAAA;AAGlC,eAAA,IAAI,gBAAe,QAAQ;MAAA;MAStC,IAAI,cACJ;AACI,eAAO,KAAK,UAAU;MAAA;MAI1B,IAAI,WACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,SAAS,OACb;AACQ,YAAA,MAAM,CAAA,aAAc,SACxB;AACI,eAAK,YAAY;AACjB,eAAK,aAAa;QAAA,OAGtB;AACI,eAAK,YAAY,CAAA;AACjB,eAAK,aAAa,CAAA;AAElB,mBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAClC;AACI,iBAAK,UAAU,KAAM,MAAM,CAAA,EAAmB,OAAO;AACrD,iBAAK,WAAW,KAAM,MAAM,CAAA,EAAmB,IAAI;UAAA;QACvD;AAEJ,aAAK,iBAAiB;AACtB,aAAK,YAAY,CAAC;AAClB,aAAK,cAAc;MAAA;MAIvB,IAAI,eACJ;AACI,YAAI,eAAe,KAAK,MAAM,KAAK,YAAY,IAAI,KAAK,UAAU;AAElE,YAAI,eAAe,GACnB;AACI,0BAAgB,KAAK,UAAU;QAAA;AAG5B,eAAA;MAAA;MAGX,IAAI,aAAa,OACjB;AACI,YAAI,QAAQ,KAAK,QAAQ,KAAK,cAAc,GAC5C;AACI,gBAAM,IAAI,MAAM,+CAA+C,KAAA,8CACb,KAAK,WAAc,GAAA;QAAA;AAGzE,cAAM,gBAAgB,KAAK;AAE3B,aAAK,eAAe;AAEhB,YAAA,kBAAkB,KAAK,cAC3B;AACI,eAAK,cAAc;QAAA;MACvB;MAOJ,IAAI,UACJ;AACI,eAAO,KAAK;MAAA;MAIhB,IAAI,aACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,WAAW,OACf;AACQ,YAAA,UAAU,KAAK,aACnB;AACI,eAAK,cAAc;AAEnB,cAAI,CAAC,KAAK,eAAe,KAAK,sBAC9B;AACI,mBAAO,OAAO,OAAO,KAAK,QAAQ,IAAI;AACtC,iBAAK,uBAAuB;UAAA,WAEvB,KAAK,eAAe,CAAC,KAAK,wBAAwB,KAAK,UAChE;AACI,mBAAO,OAAO,IAAI,KAAK,QAAQ,IAAI;AACnC,iBAAK,uBAAuB;UAAA;QAChC;MACJ;IAER;;;;;ACxcA,IAAAC,aAAA;AAAA;AAAA;AAAA;AAAA;;;ICMMC,YASO;;;;;AATb,IAAMA,aAAY,IAAI,MAAM;AASrB,IAAM,eAAN,MAAM,sBAAqB,OAClC;MAwBI,YAAY,SAAkB,QAAQ,KAAK,SAAS,KACpD;AACI,cAAM,OAAO;AAER,aAAA,gBAAgB,IAAI,UAAU;AAGnC,aAAK,SAAS;AAGd,aAAK,UAAU;AAEf,aAAK,WAAW,KAAK,QAAQ,YAAY,IAAI,cAAc,OAAO;AAOlE,aAAK,aAAa;AAElB,aAAK,kBAAkB;MAAA;MAQ3B,IAAI,cACJ;AACI,eAAO,KAAK,SAAS;MAAA;MAGzB,IAAI,YAAY,OAChB;AACI,aAAK,SAAS,cAAc;AACvB,aAAA,SAAS,OAAO,IAAI;MAAA;MAI7B,IAAI,YACJ;AACI,eAAO,KAAK,cAAc;MAAA;MAG9B,IAAI,UAAU,OACd;AACS,aAAA,cAAc,MAAM,SAAS,KAAe;MAAA;MAIrD,IAAI,eACJ;AACI,eAAO,KAAK,cAAc;MAAA;MAG9B,IAAI,aAAa,OACjB;AACS,aAAA,cAAc,SAAS,SAAS,KAAe;MAAA;MAMxD,mBACA;AACI,YAAI,KAAK,UACT;AACS,eAAA,SAAS,UAAU,KAAK;QAAA;AAEjC,aAAK,cAAc;MAAA;MAOb,QAAQ,UAClB;AAEI,cAAM,UAAU,KAAK;AAErB,YAAI,CAAC,WAAW,CAAC,QAAQ,OACzB;AACI;QAAA;AAGJ,aAAK,cAAc,qBAAqB;AACxC,aAAK,SAAS,OAAO;AAErB,iBAAS,MAAM,kBAAkB,SAAS,QAAQ,KAAK,UAAW,CAAA;AAClE,iBAAS,QAAQ,KAAK,UAAY,EAAA,OAAO,IAAI;MAAA;MAIjD,mBACA;AACI,cAAM,OAAO,KAAK,SAAS,CAAC,KAAK,QAAQ;AACzC,cAAM,OAAO,KAAK,UAAU,CAAC,KAAK,QAAQ;AAC1C,cAAM,OAAO,KAAK,UAAU,IAAI,KAAK,QAAQ;AAC7C,cAAM,OAAO,KAAK,WAAW,IAAI,KAAK,QAAQ;AAE9C,aAAK,QAAQ,SAAS,KAAK,WAAW,MAAM,MAAM,MAAM,IAAI;MAAA;MAQzD,eAAe,MACtB;AAEQ,YAAA,KAAK,SAAS,WAAW,GAC7B;AACI,eAAK,QAAQ,OAAO,KAAK,SAAS,CAAC,KAAK,QAAQ;AAChD,eAAK,QAAQ,OAAO,KAAK,UAAU,CAAC,KAAK,QAAQ;AACjD,eAAK,QAAQ,OAAO,KAAK,UAAU,IAAI,KAAK,QAAQ;AACpD,eAAK,QAAQ,OAAO,KAAK,WAAW,IAAI,KAAK,QAAQ;AAErD,cAAI,CAAC,MACL;AACQ,gBAAA,CAAC,KAAK,kBACV;AACS,mBAAA,mBAAmB,IAAI,UAAU;YAAA;AAG1C,mBAAO,KAAK;UAAA;AAGT,iBAAA,KAAK,QAAQ,aAAa,IAAI;QAAA;AAGzC,eAAO,MAAM,eAAe,KAAK,MAAM,IAAI;MAAA;MAQxC,cAAc,OACrB;AACS,aAAA,eAAe,aAAa,OAAOA,UAAS;AAEjD,cAAM,QAAQ,KAAK;AACnB,cAAM,SAAS,KAAK;AACpB,cAAM,KAAK,CAAC,QAAQ,KAAK,OAAO;AAEhC,YAAIA,WAAU,KAAK,MAAMA,WAAU,IAAI,KAAK,OAC5C;AACI,gBAAM,KAAK,CAAC,SAAS,KAAK,OAAO;AAEjC,cAAIA,WAAU,KAAK,MAAMA,WAAU,IAAI,KAAK,QAC5C;AACW,mBAAA;UAAA;QACX;AAGG,eAAA;MAAA;MAYJ,QAAQ,SACf;AACI,cAAM,QAAQ,OAAO;AAErB,aAAK,gBAAgB;AACrB,aAAK,WAAW;MAAA;MAapB,OAAO,KAAK,QAAiC,SAC7C;AACI,cAAM,UAAW,kBAAkB,UAC7B,SACA,QAAQ,KAAK,QAAQ,OAAO;AAElC,eAAO,IAAI,cACP,SACA,QAAQ,OACR,QAAQ,MACZ;MAAA;MAIJ,IAAI,QACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,MAAM,OACV;AACI,aAAK,SAAS;MAAA;MAIlB,IAAI,SACJ;AACI,eAAO,KAAK;MAAA;MAGhB,IAAI,OAAO,OACX;AACI,aAAK,UAAU;MAAA;IAEvB;;;;;ACxQA,IAAI;AAAJ;AAAA;AAAA,IAAI,iBAAiB;AAAA;AAAA;;;ACArB,IAAI;AAAJ;AAAA;AAAA,IAAI,eAAe;AAAA;AAAA;;;ACAnB,IAAI;AAAJ;AAAA;AAAA,IAAI,iBAAiB;AAAA;AAAA;;;ACArB,IAAI;AAAJ;AAAA;AAAA,IAAI,eAAe;AAAA;AAAA;;;ACAnB,IAAI;AAAJ;AAAA;AAAA,IAAI,oBAAoB;AAAA;AAAA;;;ICqBlB,SAQO;;;;;;;;;AARb,IAAM,UAAU,IAAI,OAAO;AAQpB,IAAM,uBAAN,cAAmC,eAC1C;MAgBI,YAAY,UACZ;AACI,cAAM,QAAQ;AAGL,iBAAA,QAAQ,cAAc,IAAI,IAAI;AAElC,aAAA,OAAO,IAAI,OAAO;AAOlB,aAAA,QAAQ,MAAM,MAAM;MAAA;MAI7B,gBACA;AACI,cAAM,WAAW,KAAK;AACtB,cAAM,WAAW,EAAE,SAAS,SAAS,eAAe;AAEpD,aAAK,eAAe,OAAO,KAAK,cAAc,mBAAmB,QAAQ;AACzE,aAAK,SAAS,SAAS,QAAQ,eAAe,IACxC,OAAO,KAAK,cAAc,gBAAgB,QAAQ,IAClD,OAAO,KAAK,cAAc,gBAAgB,QAAQ;MAAA;MAMrD,OAAO,IACd;AACI,cAAM,WAAW,KAAK;AACtB,cAAM,OAAO,KAAK;AAElB,YAAI,WAAW,KAAK;AAEpB,iBAAS,CAAA,IAAK,SAAS,CAAA,IAAM,GAAG,SAAU,CAAC,GAAG,OAAO;AACrD,iBAAS,CAAA,IAAK,SAAS,CAAA,IAAK,GAAG,UAAU,CAAC,GAAG,OAAO;AAEpD,iBAAS,CAAA,IAAK,SAAS,CAAA,IAAM,GAAG,UAAW,IAAM,GAAG,OAAO;AAC3D,iBAAS,CAAA,IAAK,SAAS,CAAA,IAAK,GAAG,WAAW,IAAM,GAAG,OAAO;AAE1D,cAAM,UAAU,GAAG,kBAAkB,GAAG,OAAO,IAAI;AACnD,cAAM,UAAU,GAAG,kBAAkB,GAAG,OAAO,IAAI;AAEnD,mBAAW,KAAK;AAEP,iBAAA,CAAA,IAAK,SAAS,CAAA,IAAK,CAAC;AACpB,iBAAA,CAAA,IAAK,SAAS,CAAA,IAAK,CAAC;AAEpB,iBAAA,CAAA,IAAK,SAAS,CAAA,IAAK,IAAM;AACzB,iBAAA,CAAA,IAAK,SAAS,CAAA,IAAK,IAAM;AAElC,aAAK,WAAW;AAEhB,cAAM,MAAM,GAAG;AACf,cAAM,UAAU,IAAI;AACd,cAAA,gBAAgB,QAAQ,YAAY;AACpC,cAAA,KAAK,GAAG,cAAc;AAC5B,cAAM,KAAK,GAAG;AACV,YAAA,WAAW,QAAQ,gBAChB,IAAI,MAAM,UAAU,QAAQ,SAAS,IAAI,MAAM,WAAW,QAAQ;AAGzE,YAAI,UACJ;AACI,cAAI,CAAC,QAAQ,YAAY,SAAS,WAClC,GAAA;AACQ,gBAAA,QAAQ,aAAa,WAAW,OACpC;AACI,sBAAQ,WAAW,WAAW;YAAA;UAClC,OAGJ;AACe,uBAAA,QAAQ,aAAa,WAAW;UAAA;QAC/C;AAGJ,cAAM,SAAS,WAAW,KAAK,eAAe,KAAK;AAEnD,cAAM,IAAI,IAAI;AACd,cAAM,IAAI,IAAI;AACd,cAAM,IAAI,GAAG;AACb,cAAM,IAAI,GAAG;AAEL,gBAAA,IAAI,GAAG,IAAI,IAAI,GACnB,GAAG,IAAI,IAAI,GACX,GAAG,IAAI,IAAI,GACX,GAAG,IAAI,IAAI,GACX,GAAG,KAAK,GACR,GAAG,KAAK,CAAC;AAQb,gBAAQ,OAAO;AACf,YAAI,UACJ;AACY,kBAAA,QAAQ,GAAG,QAAQ;QAAA,OAG/B;AACI,iBAAO,SAAS,YAAY,GAAG,SAAS,QAAQ,IAAI;AAC7C,iBAAA,SAAS,cAAc,GAAG;AAC1B,iBAAA,SAAS,eAAe,GAAG;QAAA;AAGtC,eAAO,SAAS,aAAa,QAAQ,QAAQ,IAAI;AACjD,eAAO,SAAS,SAAS,MAAM,OAC1B,SAAS,GAAG,IAAI,EAChB,YAAY,GAAG,YAAY,aAAa,EACxC,QAAQ,OAAO,SAAS,MAAM;AAEnC,eAAO,SAAS,oBAAoB,GAAG,UAAU,eAAe,QAAQ,IAAI;AAC5E,eAAO,SAAS,WAAW;AAElB,iBAAA,OAAO,KAAK,MAAM;AAClB,iBAAA,SAAS,KAAK,IAAI;AAE3B,aAAK,MAAM,YAAY,YAAM,iBAAiB,GAAG,WAAW,aAAa;AAChE,iBAAA,MAAM,IAAI,KAAK,KAAK;AAC7B,iBAAS,SAAS,KAAK,KAAK,SAAS,GAAG,WAAW,GAAG,CAAC;MAAA;IAE/D;AAnJa,yBAGF,YAA+B;MAClC,MAAM;MACN,MAAM,cAAc;IACxB;AA+IJ,eAAW,IAAI,oBAAoB;;;;;AClLnC,IAAAC,aAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;ICiDa,cAAA;;;;;AAAN,IAAM,eAAN,MACP;MAmBI,YAAY,SACZ;AAZO,aAAA,QAAmB,IAAI,UAAU;AAcpC,kBAAU,OAAO,OAAO;UACpB,aAAa;QAAA,GACd,OAAO;AAEL,aAAA,WAAW,mBAAyB,OAAO;AAGpC,qBAAA,SAAS,QAAQ,CAAC,WAC9B;AACW,iBAAA,KAAK,KAAK,MAAM,OAAO;QAAA,CACjC;MAAA;MAIL,SACA;AACS,aAAA,SAAS,OAAO,KAAK,KAAK;MAAA;MAQnC,IAAI,OACJ;AACI,eAAO,KAAK,SAAS;MAAA;MAQzB,IAAI,SACJ;AACI,eAAO,KAAK,SAAS;MAAA;MAelB,QAAQ,YAAsB,cACrC;AAGI,cAAM,UAAU,aAAY,SAAS,MAAM,CAAC;AAE5C,gBAAQ,QAAQ;AACR,gBAAA,QAAQ,CAAC,WACjB;AACW,iBAAA,QAAQ,KAAK,IAAI;QAAA,CAC3B;AAEI,aAAA,MAAM,QAAQ,YAAY;AAC/B,aAAK,QAAQ;AAER,aAAA,SAAS,QAAQ,UAAU;AAChC,aAAK,WAAW;MAAA;IAExB;AA5FO,IAAM,cAAN;AAGH,gBAAO,WAAiC,CAAA;AA2F5C,eAAW,aAAa,cAAc,aAAa,YAAY,QAAQ;;;;;IC5H1D;;;;AAAN,IAAM,eAAN,MACP;MAmBI,OAAO,KAAK,SACZ;AACW,eAAA,eAAe,MAAM,YAQxB;UACI,IAAI,KACJ;AACe,uBAAA,oBAAoB,UAAU,KAAK,WAAW;AACzD,iBAAK,YAAY;AACjB,gBAAI,KACJ;AACe,yBAAA,iBAAiB,UAAU,KAAK,WAAW;AACtD,mBAAK,OAAO;YAAA;UAChB;UAEJ,MACA;AACI,mBAAO,KAAK;UAAA;QAChB,CACH;AASL,aAAK,cAAc,MACnB;AACQ,cAAA,CAAC,KAAK,WACV;AACI;UAAA;AAGJ,eAAK,aAAa;AAGlB,eAAK,YAAY,sBAAsB,MAAM,KAAK,OAAA,CAAQ;QAAA;AAS9D,aAAK,eAAe,MACpB;AACI,cAAI,KAAK,WACT;AACI,iCAAqB,KAAK,SAAS;AACnC,iBAAK,YAAY;UAAA;QACrB;AAUJ,aAAK,SAAS,MACd;AACQ,cAAA,CAAC,KAAK,WACV;AACI;UAAA;AAIJ,eAAK,aAAa;AAEd,cAAA;AACA,cAAA;AAGA,cAAA,KAAK,cAAc,WAAW,QAClC;AACI,oBAAQ,WAAW;AACnB,qBAAS,WAAW;UAAA,OAIxB;AACU,kBAAA,EAAE,aAAa,aAAA,IAAiB,KAAK;AAEnC,oBAAA;AACC,qBAAA;UAAA;AAGR,eAAA,SAAS,OAAO,OAAO,MAAM;AAClC,eAAK,OAAO;QAAA;AAIhB,aAAK,YAAY;AACjB,aAAK,YAAY;AACZ,aAAA,WAAW,QAAQ,YAAY;MAAA;MAQxC,OAAO,UACP;AACe,mBAAA,oBAAoB,UAAU,KAAK,WAAW;AACzD,aAAK,aAAa;AAClB,aAAK,eAAe;AACpB,aAAK,cAAc;AACnB,aAAK,WAAW;AAChB,aAAK,SAAS;MAAA;IAEtB;AA1II,iBAAO,YAA+B,cAAc;AA4IxD,eAAW,IAAI,YAAY;;;;;ACnK3B,IAAAC,aAAA;AAAA;AAAA;AACA;AAAA;AAAA;",
  "names": ["init_lib", "init_lib", "tempPoint", "indices", "init_lib", "init_utils", "init_utils", "init_utils", "formats", "formats", "formats", "formats", "init_parsers", "init_parsers", "init_parsers", "init_parsers", "init_parsers", "init_types", "init_parsers", "init_types", "init_lib", "init_utils", "init_lib", "init_const", "indices", "indices", "indices", "indices", "indices", "indices", "indices", "init_lib", "fragment", "vertex", "vertex", "fragment", "init_lib", "init_lib", "tempPoint", "init_lib", "init_lib"]
}
